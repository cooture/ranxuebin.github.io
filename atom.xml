<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ran Xuebin&#39;s Blog</title>
  <subtitle>永远相信美好的事情即将发生</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ranxb.cn/"/>
  <updated>2018-01-06T08:23:13.442Z</updated>
  <id>http://ranxb.cn/</id>
  
  <author>
    <name>冉学斌</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数字电路第六章：同步时序逻辑电路——上（状态编码之前）</title>
    <link href="http://ranxb.cn/2018/01/06/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E5%90%8C%E6%AD%A5%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E2%80%94%E2%80%94%E4%B8%8A%EF%BC%88%E7%8A%B6%E6%80%81%E7%BC%96%E7%A0%81%E4%B9%8B%E5%89%8D%EF%BC%89/"/>
    <id>http://ranxb.cn/2018/01/06/数字电路第六章：同步时序逻辑电路——上（状态编码之前）/</id>
    <published>2018-01-05T16:55:39.000Z</published>
    <updated>2018-01-06T08:23:13.442Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数字电路第六章：同步时序逻辑电路——上（状态编码之前）"><a href="#数字电路第六章：同步时序逻辑电路——上（状态编码之前）" class="headerlink" title="数字电路第六章：同步时序逻辑电路——上（状态编码之前）"></a>数字电路第六章：同步时序逻辑电路——上（状态编码之前）</h1><blockquote>
<p>讲同步时序逻辑电路的工作原理、分析方法和设计方法。<br>逻辑电路分为：组合逻辑电路和时序逻辑电路。<br>组合逻辑电路是指典礼在任何时刻所产生的输出仅取决于该时刻电路的输入。<br>时序逻辑电路按其工作方式不同分为：同步时序逻辑电路、异步时序逻辑电路。<br>本章介绍同步时序逻辑电路的分析与设计。    </p>
</blockquote>
<h2 id="同步时序逻辑电路的模型和描述方法"><a href="#同步时序逻辑电路的模型和描述方法" class="headerlink" title="同步时序逻辑电路的模型和描述方法"></a>同步时序逻辑电路的模型和描述方法</h2><h3 id="同步时序逻辑电路的结构模型"><a href="#同步时序逻辑电路的结构模型" class="headerlink" title="同步时序逻辑电路的结构模型"></a>同步时序逻辑电路的结构模型</h3><p>同步时序逻辑电路是一种与时序有关的电路，一般说来，是由组合电路和存储电路两部分组成，并形成反馈电路。<br><img src="a.png" alt=""><br><strong>组合逻辑电路的输出</strong>  </p>
<ol>
<li>向外输出 Z   </li>
<li>内部输出 Q </li>
</ol>
<p><strong>组合逻辑电路的输入</strong>  </p>
<ol>
<li>外部输入：整个时序电路的输入 X  </li>
<li>内部输入：存储电路的内部输出 Y  </li>
</ol>
<p><strong>函数的意义</strong><br>Zi称为输出函数<br>Yj称为驱动方程<br>Mealy型电路：Z的输出既和存储电路的输出有关有和当前状态的输入x有关。<br>Moore型电路：Z的输出只和存储电路的输出有关。<br><strong>采用时钟控制的触发器构成存储电路</strong><br>存储时序电路中的二进制信息被定义为电路的状态，触发器的状态就称为时序电路的状态。<br><strong>向量函数</strong><br><img src="b.png" alt=""><br>时钟信号不能间隔过短，要状态状态稳定后再一个信号再来。  </p>
<h3 id="同步时序逻辑电路的描述方法"><a href="#同步时序逻辑电路的描述方法" class="headerlink" title="同步时序逻辑电路的描述方法"></a>同步时序逻辑电路的描述方法</h3><p>为了形象的表示时序逻辑电路的全过程性，把电路在一系列的时钟信号作用下状态转换的全过程找出来，则电路的逻辑功能就一目了然了。<br>描述时序电路状态的转换全部过程的方法：  </p>
<ol>
<li>状态方程  </li>
<li>状态转换表（状态转换真值表）  </li>
<li>状态转换图（简称状态图）  </li>
<li>时序图（波形图）  </li>
</ol>
<h4 id="状态方程"><a href="#状态方程" class="headerlink" title="状态方程"></a>状态方程</h4><p>输出方程：表示输出与输入和现态的关系<br>驱动方程：表示现态向次态转换所需的条件<br>状态方程：表示在给定的输入下将使现态转向状态  </p>
<h4 id="状态转换表"><a href="#状态转换表" class="headerlink" title="状态转换表"></a>状态转换表</h4><p>由现态Q、次态Qn+1和输出Z组成。<br>例：<br><img src="c.png" alt=""><br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="d.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="e.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<h4 id="状态转换图"><a href="#状态转换图" class="headerlink" title="状态转换图"></a>状态转换图</h4><p>在状态转换图中以圆圈表示电路的各个状态，以箭头表示状态转换的方向。 同时，还在箭头旁注明了状态转换前的输入变量取 值和输出值。通常将输入变量取值写在斜线以上，将输出值写在斜线以下。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="f.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>  </p>
<h4 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h4><p>将状态转换表的内容画成时间波形图。在时钟脉冲序列作用下，电路状态、输出状态随时间变化的波形图叫做时序图。而且便于用实验观察的方法检查时序电路的逻辑功能。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="g.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<h2 id="同步时序逻辑电路的分析方法"><a href="#同步时序逻辑电路的分析方法" class="headerlink" title="同步时序逻辑电路的分析方法"></a>同步时序逻辑电路的分析方法</h2><p>根据给定的逻辑电路图，找出他的状态方程、输出方程、状态图和时序图。用这些方法来描述电路的工作全过程及输入输出关系。</p>
<h3 id="时序逻辑电路的分析步骤"><a href="#时序逻辑电路的分析步骤" class="headerlink" title="时序逻辑电路的分析步骤"></a>时序逻辑电路的分析步骤</h3><p>找出给定时序电路的逻辑功能即找出在输入信号和时钟信号作用下，电路的次态和输出。一般步骤如下：  </p>
<ol>
<li>根据给定的逻辑电路图，写出每个触发器的驱动方程（控制方程）。  </li>
<li>把得到的驱动方程带入相应的触发器的特性方程，得出每个触发器的状态方程，从而写出这些状态方程的方程组。并写出输出方程。  </li>
<li>建立状态转换真值表  </li>
<li>做出状态图和时序波形图。  </li>
<li>总结功能。  </li>
</ol>
<h3 id="同步时序电路分析的例子"><a href="#同步时序电路分析的例子" class="headerlink" title="同步时序电路分析的例子"></a>同步时序电路分析的例子</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="h.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>  
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="i.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="j.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>  
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="k.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<ol>
<li>找每个触发器的输入端，写方程，=1的框框是环和。  </li>
<li>把写好的方程带入触发器的特征方程例，写出次态的状态方程，在找输出端写出输出方程。  </li>
<li>列表，横纵分别有触发器现态和输入值，结果是触发器次态和输出值。  </li>
<li>画圈圈，把触发器的变化过程用圈圈画出来，箭头写上输入值和输出值。  </li>
<li>总结。  </li>
</ol>
<p><strong>注意</strong>，Moore型的因为次态和输入无关，所以只列输出的表的顺序即可，Mealy型的因为和输入有关所以要建和输入有关的表，注意没有排列到的状态要单独加上，类似于：<br><img src="l.png" alt=""><br>整个例如Moore型的例题：<br><img src="m.png" alt=""><br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="n.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<h2 id="同步时序逻辑电路的设计"><a href="#同步时序逻辑电路的设计" class="headerlink" title="同步时序逻辑电路的设计"></a>同步时序逻辑电路的设计</h2><h3 id="设计同步时序逻辑电路的过程"><a href="#设计同步时序逻辑电路的过程" class="headerlink" title="设计同步时序逻辑电路的过程"></a>设计同步时序逻辑电路的过程</h3><ol>
<li>根据实际要求进行逻辑抽象，得出电路的原始状态转换图和转换表。   </li>
<li>状态化简，求最简状态化简表。  </li>
<li>状态编码。第一步. 确定触发器的数目n 第二步. 给每个电路状态分配一组二进制代码，称为状态编码。  </li>
<li>选定触发器类型，求出电路的状态方程。根据状态转换图(或状态转换表)和选定的状态编码、触发器的类型，就可写出电路的状态方程、驱动方程和输出方程。  </li>
<li>根据方程式画出逻辑电路图。  </li>
<li>检查自启动，解决办法：一、通过预置数。二、修改逻辑设计。  </li>
</ol>
<p>整体步骤如图所示：<br><img src="o.png" alt=""></p>
<h3 id="建立原始状态转换图和转换表"><a href="#建立原始状态转换图和转换表" class="headerlink" title="建立原始状态转换图和转换表"></a>建立原始状态转换图和转换表</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="p.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h3 id="完全确定原始状态表化简"><a href="#完全确定原始状态表化简" class="headerlink" title="完全确定原始状态表化简"></a>完全确定原始状态表化简</h3><p>状态表化简的原则（若状态表中的任意两个状态Si和Sj，同时满足下列两个条件，则他们可以合并成一个状态）：  </p>
<ol>
<li>在所有可能的现输入下，两个（或多个）状态相应的现输出分别相同。</li>
<li>在所有可能的现输入下，次态分别为下列情况之一：<br> a. 两个次态完全相同<br> b. 两个次态为状态对循环的一个状态对<br> c. 两个次态为其现态本身或交错<br> d. 两个次态的某一后序状态可以合并  </li>
</ol>
<p>上述的第一个条件是状态合并的必要条件，该条件不满足就无需再考虑第二个条件。  </p>
<p>根据状态表化简的原则，利用下列判别方法造出状态表中全部的出状态并对进行分类合并。 </p>
<ol>
<li>等效状态和等效类<br><strong>等效状态</strong>—满足上述合并条件的两个状态如Si和Sj称为等效状态，或称等效状态对，记为{Si, Sj}。<br><strong>等效状态的传递性</strong>——若状态Si和Sj等效,状态Sj和Sm等效，则状态Si必和Sm等效,称为等效状态的传递性，记为{Si,Sj}{Sj,Sm}→{Si,Sm}   </li>
</ol>
<p><strong>等效类</strong>——彼此等效状态的集合。<br><strong>最大等效类</strong>——若一个等效类不包含在任何其它等效类之中，则称它为最大等效类。这里说的最大，并不是指包含的状态最多，而是指他的<strong>独立性</strong>！。  </p>
<p>显然，状态表的化简的根本任务在于从原始状态表中找出最大等效类，并用一个状态代替。例如：<br><img src="q.png" alt="">  </p>
<ol>
<li>用隐含表法化简<br>隐含表是一个斜边为阶梯型的直角三角形网络。及横向和纵向格数相同，格数为原始状态表的状态数减一。<br>然后顺序比较，往表格里填东西。依次比较，若两个状态不是等效对就画X，如果两个状态是等效对则画√，若不确定的则写出下一组状态对，如表：<br><img src="r.png" alt=""><br>例如CF对完全相同则画✅，又例如AD输出Z都不一样则画叉。还有比如AB两个，输出一样，但是X=0时的次态不同，则无法确定则将CF写入，X=1时因为是两个交换对所以是满足的条件，不用将其写入。最后列出下表：<br><img src="s.png" alt=""><br>根据等效关系的传递性，对等效状态对 {A,B}、{A,E}、{B,E}构成等效类{A,B,E}。 等效状态对{C,F}也是等效类。由于等效类 {A,B,E}和{C,F}互不包含在对方的等效类中， 所以，等效类{A,B,E}和{C,F}都是最大等效类。而状态G和D不和任何其它状态等效，因此,它们本身也是一个最大等效类,分别记作{G}和{D}。因此最大等效集合<code>{A,B,E}，{C,F}，{D}，{G}</code>  </li>
</ol>
<p>建立最简状态表。最大等效类集合必须覆盖原始状态表的全部状态。原始状态表中每一个状态只能属于一个最大等效类。这样，每个最大等效类可用一个状态代替。即:<code>a={ABE} b={CF} c={D} d={G}</code>由此可得最简状态表：<br><img src="t.png" alt=""></p>
<h3 id="不完全确定状态表的化简"><a href="#不完全确定状态表的化简" class="headerlink" title="不完全确定状态表的化简"></a>不完全确定状态表的化简</h3><p>这种电路的 状态表包含着不确定的次态或输出，所以，是一种不完全确定电路。并不是任何输出序列都是有效的。不完全确定状态表的化简是基于相容状态的，再利用任意项可使状态表 化的更简。<br><strong>相容状态</strong>——再不完全确定表中，假设S1和S2为初始状态，如果对于所有的有效输入序列从状态S1和S2除法他们相应的输出序列（除不确定的那些之外）是完全相同的，那么状态S1和S2是相容的，或者说S1和S2是相容对，记作（S1，S2）<br><strong>相容状态的条件</strong>——在所有可能输入条件下，两个状态对应的输出相同，或者其中一个（或两个）输出为任意值；并且它们的次态相同、交错、循环、相容，或者其中一个（或两个）为任意状态，那么这两个状态是相容的。<br><strong>相容类</strong>——由彼此相容的状态构成的集合，处于同一相容类 中的所有状态之间都是两两相容的。<br><strong>非传递性</strong>——状态等效具有传递性，而<strong>状态相容不具有传递性</strong>。 因此，若要求(S1, S2，S3)相容，则必须(S1,S2)， (S2,S3)，(S1,S3)都是相容对。也就是说，相容类中所有状态之间都分别是两两相容的。<br><strong>最大相容类</strong>——若一个相容类不是任何其他相容类的子集，则该相容类称为最大相容类。<br>例题：<br><img src="u.png" alt=""><br>表中由于部分状态的次态和输出无法确定，所以是不完全确定状态表。  </p>
<ol>
<li>做隐含表并比较，如图<br><img src="v.png" alt=""><br>2.在相容状态对中找最大相容类<br><img src="w.png" alt="">  </li>
<li>确定原始状态表的最小闭合覆盖集  </li>
<li><strong>选择一个</strong>同时满足<em>覆盖、闭合和最小</em>三个条件的<strong>相容类集合</strong>，将每个相容类用一个新状态来代替，以得到一个新的状态表。  </li>
</ol>
<p><strong>覆盖</strong>——指相容类集合中包含了原始状态表的全部状态。即原始状态表中任何一个状态至少包含在相容类集合中的一个相容类(包括最大相容类)中，而不能遗漏。<br><strong>闭合</strong>——指一个相容类集合中,任一相容类的所有隐含条件都必须属于该集合中某一个相容类(包括最大相容类)。<br><strong>最小</strong>——是指满足覆盖和闭合的相容类数目最少。不完全状态表的简化，就是寻找一个最小闭合覆盖<br>为了反应闭合和覆盖这两个性质，建立闭合覆盖表：<br><img src="x.png" alt=""><br>在表的左边自上而下列出所选相容类，表的中间覆盖部分自左到右列出全部状态，表的右边闭合部分列出各相容类在输入各种取值组合下的次态组合。必须指出，这里所说的相容类包括最大相容类和它们的子类。<br>找到了覆盖闭合最小之后，就可以画出最简状态表：<br><img src="y.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数字电路第六章：同步时序逻辑电路——上（状态编码之前）&quot;&gt;&lt;a href=&quot;#数字电路第六章：同步时序逻辑电路——上（状态编码之前）&quot; class=&quot;headerlink&quot; title=&quot;数字电路第六章：同步时序逻辑电路——上（状态编码之前）&quot;&gt;&lt;/a&gt;数字电路第
    
    </summary>
    
      <category term="数字电路" scheme="http://ranxb.cn/categories/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"/>
    
    
      <category term="数字电路" scheme="http://ranxb.cn/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"/>
    
      <category term="笔记" scheme="http://ranxb.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言第十二。。章：内外中断和int指令</title>
    <link href="http://ranxb.cn/2018/01/05/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AC%AC%E5%8D%81%E4%BA%8C%E3%80%82%E3%80%82%E7%AB%A0%EF%BC%9A%E5%86%85%E5%A4%96%E4%B8%AD%E6%96%AD%E5%92%8Cint%E6%8C%87%E4%BB%A4/"/>
    <id>http://ranxb.cn/2018/01/05/汇编语言第十二。。章：内外中断和int指令/</id>
    <published>2018-01-04T16:33:03.000Z</published>
    <updated>2018-01-05T16:54:54.210Z</updated>
    
    <content type="html"><![CDATA[<h1 id="汇编语言第十二。。章：内外中断和int指令"><a href="#汇编语言第十二。。章：内外中断和int指令" class="headerlink" title="汇编语言第十二。。章：内外中断和int指令"></a>汇编语言第十二。。章：内外中断和int指令</h1><blockquote>
<p>不再过多说中断是什么了，就是可以随时控制CPU停止当前的指令干其他的事的意思，下面内中断程序的步骤：  </p>
<ol>
<li>将程序写入0:200开始的空间内，同时把字符什么的也要定义进去。  </li>
<li>设置中断向量表，前面是ip，后面是cs。注意高低位。  </li>
</ol>
</blockquote>
<h2 id="单步中断的操作"><a href="#单步中断的操作" class="headerlink" title="单步中断的操作"></a>单步中断的操作</h2><ol>
<li>取得中断类型码</li>
<li>标志寄存器入栈</li>
<li>标志寄存器TF和IF置零，防止在中断程序中在中断。  </li>
<li>CS内容入栈</li>
<li>IP入栈</li>
<li>根据中断类型码从中断向量表中设置中断程序的CS和IP。</li>
</ol>
<h2 id="中断处理程序的编写方法"><a href="#中断处理程序的编写方法" class="headerlink" title="中断处理程序的编写方法"></a>中断处理程序的编写方法</h2><ol>
<li>保存用到的寄存器</li>
<li>处理中断</li>
<li>恢复寄存器</li>
<li>iret</li>
</ol>
<p>iret用来返回程序：操作为：  </p>
<pre><code>pop ip
pop cs
popf
</code></pre><p>目的是回到执行中断处理程序之前的执行点继续执行程序。</p>
<h2 id="编写0号中断程序"><a href="#编写0号中断程序" class="headerlink" title="编写0号中断程序"></a>编写0号中断程序</h2><pre><code>assume cs:code ss:satck ds:data
code segment
start:    mov ax,cs
            mov ds,ax
            mov si,offset do0    ;ds:si指向do0中断程序部分
            mov ax,0
            mov es,ax
            mov di,200h
            mov cx offset do0end - do0
            cld
            rep movsb
            mov ax,0            ;安装中断程序
            mov es,ax
            mov word ptr es:[0],200h
            mov word ptr es:[0+2],0

            mov ax,4c00h
            int 21h

do0:        jmp short do0start
            db &quot;overflow!&quot;

do0start:
            mov ax,cs
            mov ds,ax
            mov si,202h            ;ds:si指向字符串
            mov ax,0b800h
            mov es,ax
            mov di,12*160+36*2    ;es:di指向显存空间
            mov cx,9
        s:    mov al,[si]
            mov es:[di],al
            inc si
            add di,2
            loop s

            mov ax,4c00h
            int 21h
</code></pre><h2 id="中断的特殊情况"><a href="#中断的特殊情况" class="headerlink" title="中断的特殊情况"></a>中断的特殊情况</h2><p>设置栈的操作不会响应中断，因为中断会进行栈操作，需要设置正确的栈顶，所以设置sp的指令应当紧接着设置ss的指令</p>
<h2 id="int指令"><a href="#int指令" class="headerlink" title="int指令"></a>int指令</h2><p>格式：int n，n为中断类型码<br>int指令的最终功能和call类似，都是调用一段程序。<br>中断处理程序简称为中断例程  </p>
<h2 id="编写供应用程序调用的中断例程"><a href="#编写供应用程序调用的中断例程" class="headerlink" title="编写供应用程序调用的中断例程"></a>编写供应用程序调用的中断例程</h2><p>明天再写详细的</p>
<h2 id="BIOS和DOS多提供的中断例程的安装过程"><a href="#BIOS和DOS多提供的中断例程的安装过程" class="headerlink" title="BIOS和DOS多提供的中断例程的安装过程"></a>BIOS和DOS多提供的中断例程的安装过程</h2><ol>
<li>CPU加电，初始化(CS) = 0FFFFH，(IP) = 0，从FFFF：0开始执行程序。此处有一条跳转指令，跳转后开始执行BIOS中的硬件系统检测和初始化程序  </li>
<li>初始化程序建立BIOS所支持的中断向量表，只需登记中断向量表，中断程序在ROM中，一直在内存中存在  </li>
<li>硬件检测和初始化完成之后，调用int 19h，进入操作系统引导程序。</li>
<li>DOS启动，将所提供的中断例程装入内存，并建立中断向量表。</li>
</ol>
<h2 id="BIOS和DOS的中断例程的应用"><a href="#BIOS和DOS的中断例程的应用" class="headerlink" title="BIOS和DOS的中断例程的应用"></a>BIOS和DOS的中断例程的应用</h2><p>就是应用了，比如BIOS中的彩色显示int 10h和DOS中的输出字符串int 21h。明天再写</p>
<h2 id="汇编语言：完～"><a href="#汇编语言：完～" class="headerlink" title="汇编语言：完～"></a>汇编语言：完～</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;汇编语言第十二。。章：内外中断和int指令&quot;&gt;&lt;a href=&quot;#汇编语言第十二。。章：内外中断和int指令&quot; class=&quot;headerlink&quot; title=&quot;汇编语言第十二。。章：内外中断和int指令&quot;&gt;&lt;/a&gt;汇编语言第十二。。章：内外中断和int指令&lt;/
    
    </summary>
    
      <category term="汇编语言" scheme="http://ranxb.cn/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="笔记" scheme="http://ranxb.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="汇编语言" scheme="http://ranxb.cn/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言第十一章：标志寄存器</title>
    <link href="http://ranxb.cn/2018/01/05/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%EF%BC%9A%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8/"/>
    <id>http://ranxb.cn/2018/01/05/汇编语言第十一章：标志寄存器/</id>
    <published>2018-01-04T16:26:41.000Z</published>
    <updated>2018-01-04T16:28:56.877Z</updated>
    
    <content type="html"><![CDATA[<h1 id="汇编语言第十一章：标志寄存器"><a href="#汇编语言第十一章：标志寄存器" class="headerlink" title="汇编语言第十一章：标志寄存器"></a>汇编语言第十一章：标志寄存器</h1><blockquote>
<p>标志寄存器就是CPU处理数据的时候做标记的<br>这一章学的有ZF，SF，PF，CF，OF标志寄存器，还有adc，sbb，movsb，movsw，cld，std，rep等操作</p>
</blockquote>
<h2 id="第六位：ZF"><a href="#第六位：ZF" class="headerlink" title="第六位：ZF"></a>第六位：ZF</h2><p>zero flag<br>零标志位<br>处理完之后是否为零，0的话ZF则为一</p>
<h2 id="第二位：PF"><a href="#第二位：PF" class="headerlink" title="第二位：PF"></a>第二位：PF</h2><p>Parity flag<br>奇偶校验位<br>换成二进制之后，1的个数是偶数？PF = 1 ：PF = 0  </p>
<h2 id="第七位：SF"><a href="#第七位：SF" class="headerlink" title="第七位：SF"></a>第七位：SF</h2><p>sign flag<br>符号标志位<br>结果是否为负，只看第一位符号位</p>
<h2 id="第零位：CF"><a href="#第零位：CF" class="headerlink" title="第零位：CF"></a>第零位：CF</h2><p>carry flag<br>进位标识符<br>是否有进位或者借位<br><strong>inc和loop不影响CF位</strong></p>
<h2 id="第十一位：OF"><a href="#第十一位：OF" class="headerlink" title="第十一位：OF"></a>第十一位：OF</h2><p>overflow flag<br>溢出标志位</p>
<h2 id="adc指令"><a href="#adc指令" class="headerlink" title="adc指令"></a>adc指令</h2><p>带进位的加法指令add carry<br>adc a,b<br>相当于a = a + b + cf<br>作用：</p>
<pre><code>add ax,bx

相当于

add al,bl
adc ah,bh
</code></pre><h2 id="sbb指令"><a href="#sbb指令" class="headerlink" title="sbb指令"></a>sbb指令</h2><p>带借位的减法指令sub borrow<br>sbb a,b<br>相当于a = a - b - CF</p>
<h2 id="CMP指令"><a href="#CMP指令" class="headerlink" title="CMP指令"></a>CMP指令</h2><p>相当于减法，但不保存结果，只会影响标志寄存器CF和ZF  </p>
<h3 id="检测比较结果的条件转移指令"><a href="#检测比较结果的条件转移指令" class="headerlink" title="检测比较结果的条件转移指令"></a>检测比较结果的条件转移指令</h3><p>和CMP配合使用</p>
<ol>
<li>je    equal</li>
<li>jne    not equal</li>
<li>jb    below</li>
<li>jnb    not below</li>
<li>ja    above</li>
<li>jna    not above</li>
</ol>
<h2 id="第十位：DF标志和串的传送"><a href="#第十位：DF标志和串的传送" class="headerlink" title="第十位：DF标志和串的传送"></a>第十位：DF标志和串的传送</h2><p>DF direcition(down?) flag<br>格式：movsb  （mov string byte？）<br>功能：复制一段数据？差不多，主要就是执行以下操作  </p>
<ol>
<li>((es)*16+di) = ((ds)*16+si)  </li>
<li>若df = 0:   si++; di++  </li>
<li>若df = 1:   si–; di–</li>
</ol>
<p>上面的是传一个内存单元，也可以传一个字<br>格式：movsw  （mov string word？）  </p>
<ol>
<li>mov word ptr es:[di],ds:[si](并不支持这样的指令，只是描述)  </li>
<li>若df = 0:   si+=2; di+=2  </li>
<li>若df = 1:   si-=2; di-=2</li>
</ol>
<p>可以配合rep使用，rep就是重复cx次当前指令，例如</p>
<pre><code>rep mov sb

相当于

s:
    movsb
    loop s
</code></pre><p>这样就可以实现cx个字符的传送  </p>
<h3 id="设置DF的指令"><a href="#设置DF的指令" class="headerlink" title="设置DF的指令"></a>设置DF的指令</h3><ol>
<li>cld：将DF设置为零（clear df）</li>
<li>std：将DF设置为一 (set df)</li>
</ol>
<h2 id="pushf和popf"><a href="#pushf和popf" class="headerlink" title="pushf和popf"></a>pushf和popf</h2><p>标志寄存器的出入栈</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;汇编语言第十一章：标志寄存器&quot;&gt;&lt;a href=&quot;#汇编语言第十一章：标志寄存器&quot; class=&quot;headerlink&quot; title=&quot;汇编语言第十一章：标志寄存器&quot;&gt;&lt;/a&gt;汇编语言第十一章：标志寄存器&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;标志寄存器就是CP
    
    </summary>
    
      <category term="汇编语言" scheme="http://ranxb.cn/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="笔记" scheme="http://ranxb.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="汇编语言" scheme="http://ranxb.cn/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言第十章：CALL和RET指令</title>
    <link href="http://ranxb.cn/2018/01/04/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AC%AC%E5%8D%81%E7%AB%A0%EF%BC%9ACALL%E5%92%8CRET%E6%8C%87%E4%BB%A4/"/>
    <id>http://ranxb.cn/2018/01/04/汇编语言第十章：CALL和RET指令/</id>
    <published>2018-01-04T15:33:06.000Z</published>
    <updated>2018-01-04T16:27:28.652Z</updated>
    
    <content type="html"><![CDATA[<h1 id="汇编语言第十章：CALL和RET指令"><a href="#汇编语言第十章：CALL和RET指令" class="headerlink" title="汇编语言第十章：CALL和RET指令"></a>汇编语言第十章：CALL和RET指令</h1><blockquote>
<p>都是修改ip的，重点不多，会用就行，随便写写。</p>
</blockquote>
<h2 id="ret和retf"><a href="#ret和retf" class="headerlink" title="ret和retf"></a>ret和retf</h2><p><strong>ret进行近转移，只修改IP</strong><br><strong>retf进行远转移，修改IP和CS</strong>  </p>
<h3 id="ret指令的操作"><a href="#ret指令的操作" class="headerlink" title="ret指令的操作"></a>ret指令的操作</h3><p><strong>出栈操作</strong>  </p>
<ol>
<li>(IP) = ((ss)*16+sp)  </li>
<li>(sp) = (sp)+2<br>相当于pop IP</li>
</ol>
<h3 id="retf指令的操作"><a href="#retf指令的操作" class="headerlink" title="retf指令的操作"></a>retf指令的操作</h3><p><strong>先出ip，再出cs</strong>  </p>
<ol>
<li>(IP) = ((ss)*16+sp)  </li>
<li>(sp) = (sp)+2  </li>
<li>(CS) = ((ss)*16+sp)  </li>
<li>(sp) = (sp)+2<br>相当于pop ip；pop cs</li>
</ol>
<h2 id="CALL指令"><a href="#CALL指令" class="headerlink" title="CALL指令"></a>CALL指令</h2><blockquote>
<p>两步操作  </p>
<ol>
<li>IP或CS和IP压入栈  </li>
<li>转移</li>
</ol>
</blockquote>
<p>(CALL的转移位移是16位的，也就是短转移，不支持近转移)</p>
<h3 id="根据位移进行转移的CALL指令"><a href="#根据位移进行转移的CALL指令" class="headerlink" title="根据位移进行转移的CALL指令"></a>根据位移进行转移的CALL指令</h3><p><strong>先压栈，在转移</strong>  </p>
<ol>
<li>(sp) = (sp)-2  </li>
<li>((ss)*16+sp) = ip  </li>
<li>ip转移  </li>
</ol>
<p>格式：CALL 标号  </p>
<h3 id="根据目的地址转移的CALL指令"><a href="#根据目的地址转移的CALL指令" class="headerlink" title="根据目的地址转移的CALL指令"></a>根据目的地址转移的CALL指令</h3><p>格式： </p>
<pre><code>call far prt 标号
</code></pre><p>实现的是段间转移<br>执行此命令时进行如下操作：  </p>
<ol>
<li>push CS</li>
<li>push IP</li>
<li>CS：IP转移</li>
</ol>
<h3 id="地址在寄存器中的CALL指令"><a href="#地址在寄存器中的CALL指令" class="headerlink" title="地址在寄存器中的CALL指令"></a>地址在寄存器中的CALL指令</h3><p>格式： call 16位的reg<br>例如： call ax<br>相当于：<br>push ip<br>jmp ax</p>
<h3 id="转移地址在内存中的CALL指令"><a href="#转移地址在内存中的CALL指令" class="headerlink" title="转移地址在内存中的CALL指令"></a>转移地址在内存中的CALL指令</h3><h4 id="CALL-WORD-PRT-地址"><a href="#CALL-WORD-PRT-地址" class="headerlink" title="CALL WORD PRT 地址"></a>CALL WORD PRT 地址</h4><p>两个字节16位，只转移IP</p>
<h4 id="CALL-DWOERD-PRT-地址"><a href="#CALL-DWOERD-PRT-地址" class="headerlink" title="CALL DWOERD PRT 地址"></a>CALL DWOERD PRT 地址</h4><p>四个字节32位，转移CS和IP</p>
<h2 id="RET和CALL的配合使用"><a href="#RET和CALL的配合使用" class="headerlink" title="RET和CALL的配合使用"></a>RET和CALL的配合使用</h2><p>当正常函数用，没什么区别<br>要先push 前面用到的寄存器的值<br>前面CALL，后面RET</p>
<h2 id="MUL指令"><a href="#MUL指令" class="headerlink" title="MUL指令"></a>MUL指令</h2><p>乘法指令，和除法指令类似，只是要不都是8位的，要不都是16位的。  </p>
<h3 id="8位的"><a href="#8位的" class="headerlink" title="8位的"></a>8位的</h3><p>AL放一个，然后MUL一个8位的内存单元，结果放在AX里面<br>如100*10:  </p>
<pre><code>mov al,100
mov bl,10
mul bl
</code></pre><p>最后结果在AX里<br>或者mul一个内存单元，还是例如：</p>
<pre><code>mov al,100
mov ds:[0],10
mul byte ptr ds:[0]
</code></pre><h3 id="16位的"><a href="#16位的" class="headerlink" title="16位的"></a>16位的</h3><p>AX放一个，然后MUL一个16位寄存器或者内存单元，结果高位在DX里，低位在AX里。<br>例如1000*10：</p>
<pre><code>mov ax,1000
mov bx,10
mul bx
</code></pre><p>结果换成16进制，高位在DX里，低位在AX里。</p>
<p><strong>除法在第八章</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;汇编语言第十章：CALL和RET指令&quot;&gt;&lt;a href=&quot;#汇编语言第十章：CALL和RET指令&quot; class=&quot;headerlink&quot; title=&quot;汇编语言第十章：CALL和RET指令&quot;&gt;&lt;/a&gt;汇编语言第十章：CALL和RET指令&lt;/h1&gt;&lt;blockquo
    
    </summary>
    
      <category term="汇编语言" scheme="http://ranxb.cn/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="笔记" scheme="http://ranxb.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="汇编语言" scheme="http://ranxb.cn/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>数字电路第五章：集成双稳态触发器</title>
    <link href="http://ranxb.cn/2018/01/04/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9A%E9%9B%86%E6%88%90%E5%8F%8C%E7%A8%B3%E6%80%81%E8%A7%A6%E5%8F%91%E5%99%A8/"/>
    <id>http://ranxb.cn/2018/01/04/数字电路第五章：集成双稳态触发器/</id>
    <published>2018-01-04T11:31:33.000Z</published>
    <updated>2018-01-04T14:53:13.378Z</updated>
    
    <content type="html"><![CDATA[<h1 id="集成双稳态触发器"><a href="#集成双稳态触发器" class="headerlink" title="集成双稳态触发器"></a>集成双稳态触发器</h1><blockquote>
<p>主要内容有  </p>
<ol>
<li>触发器的特点及分类  </li>
<li>基本的RS触发器  </li>
<li>事中控制的RS触发器，D触发器，JK触发器，T触发器的电路结构、逻辑功能及其描述方法。  </li>
<li>触发器的性能参数。  </li>
</ol>
</blockquote>
<h2 id="触发器的基本特点及分类"><a href="#触发器的基本特点及分类" class="headerlink" title="触发器的基本特点及分类"></a>触发器的基本特点及分类</h2><h3 id="输入量和输出量的设置"><a href="#输入量和输出量的设置" class="headerlink" title="输入量和输出量的设置"></a>输入量和输出量的设置</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="a.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>  
<p>s0和R0代表初始状态预置输入量，X1和X2是正常工作的时候的输入量，Q为输出量，要求有两个相反的所以叫Q和非Q。<br>钟控式的再加一个CP为时钟控制输入量。  </p>
<h3 id="触发器输出与约束方程的一般表达式"><a href="#触发器输出与约束方程的一般表达式" class="headerlink" title="触发器输出与约束方程的一般表达式"></a>触发器输出与约束方程的一般表达式</h3><p><strong>设触发器输出次态的取值记作Qn+1，现态取值记Qn</strong><br>触发器正常时要求R0 = S0 = 1！。  </p>
<h3 id="触发器的分类"><a href="#触发器的分类" class="headerlink" title="触发器的分类"></a>触发器的分类</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="b.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h2 id="基本RS双稳态触发器及其分析"><a href="#基本RS双稳态触发器及其分析" class="headerlink" title="基本RS双稳态触发器及其分析"></a>基本RS双稳态触发器及其分析</h2><blockquote>
<p>本RS触发器是各种触发器电路中结构形式最简单的一种。同时，它又是复杂电路结构触发器的一个基本组成都分。</p>
</blockquote>
<h3 id="RS型（set-reset）的电路结构和基本原理"><a href="#RS型（set-reset）的电路结构和基本原理" class="headerlink" title="RS型（set reset）的电路结构和基本原理"></a>RS型（set reset）的电路结构和基本原理</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="c.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>习惯上将电路画成图5-4(b)的对称形式。<br>Q和Q称为输出端，并且定义Q=1、Q=0为触发器的1状态， Q=0、Q=1为触发器的0状态。<br><strong>S为置位端或置1输入端，R成为复位端或置0输入端。</strong><br>(1)当S=1，R=0时，Q=1,非Q=0。<br>(2)当S=0，R=1时，Q=0,非Q=1。<br>(3)当S=R=0时，电路维持原来状态不变。<br>(4)当S=R=1时，Q = 非Q= 0，既不是定义的1状态， 也不是定义的0状态。<br>真值表如下<br><img src="d.png" alt=""><br>输入信号在S或R为1的全部作用时间里， 都能直接改变输出端Q和Q的状态，这就是基本RS触发器的工作特点。<br>这个缘故，<strong>也把S(非S)叫做直接置位端; 把R(非R)叫做直接复位端</strong></p>
<h2 id="时钟RS触发器及其分析"><a href="#时钟RS触发器及其分析" class="headerlink" title="时钟RS触发器及其分析"></a>时钟RS触发器及其分析</h2><p>触发器翻转的状态仍由输入控制端的电平情况决定，但翻转的时刻应由统一的脉冲信号来进行控制，这类控制信号称为<strong>时钟脉冲</strong>，CP (Clock Pulse)表示。<br>这类触发器成为<strong>同步触发器</strong></p>
<h3 id="时钟RS触发器结构与工作特性"><a href="#时钟RS触发器结构与工作特性" class="headerlink" title="时钟RS触发器结构与工作特性"></a>时钟RS触发器结构与工作特性</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="e.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>真值表如下（即为只有CP为一时即触发）<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="f.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>一般在使用同步触发器时，有时还需要在cp信号来之前将触发器预置成指定状态，所以可能会出现专门的异步置位输入端S和异步复位输入端R，使触发器置于指定状态。</p>
<h4 id="空翻现象"><a href="#空翻现象" class="headerlink" title="空翻现象"></a>空翻现象</h4><p>如果CP=1的期间内输入信号多次发生变化，则触发器的状态也会发生多次翻转，这就降低了电路的抗干扰能力，也叫“空翻”现象。</p>
<h3 id="主从触发器"><a href="#主从触发器" class="headerlink" title="主从触发器"></a>主从触发器</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="g.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p><strong>主从RS触发器动作特点</strong>：<br>主从RS触发器的动作分两步完成。<br>先在CP=1期间，主触发器接收输入驱动RS信号进行主触发器的状态修改，但从触发器不动作。<br>第二步，在CP=0时刻，从触发器按照此时主触发器的状态进行动作。</p>
<p>主从RS触发器解决了空翻问题，但在CP=1期间，RS仍存在约束条件。<br><strong>RS = 0 (约束条件）</strong><br>特征表如下：<br><img src="h.png" alt=""></p>
<h2 id="时钟D触发器及其分析"><a href="#时钟D触发器及其分析" class="headerlink" title="时钟D触发器及其分析"></a>时钟D触发器及其分析</h2><h3 id="电路结构与工作原理"><a href="#电路结构与工作原理" class="headerlink" title="电路结构与工作原理"></a>电路结构与工作原理</h3><p>为了适用于单端输入信号的场合，在有些集成电路中也把同步RS触发器作成下图的结构形式 通常把这种电路叫D型触发器(或D型锁存器)。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="i.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<h3 id="逻辑功能及其描述方法"><a href="#逻辑功能及其描述方法" class="headerlink" title="逻辑功能及其描述方法"></a>逻辑功能及其描述方法</h3><h4 id="功能真值表和激励表"><a href="#功能真值表和激励表" class="headerlink" title="功能真值表和激励表"></a>功能真值表和激励表</h4><p>RS触发器演变而来，它克服了RS触发器在 S=R=1时，次态不定的功能不完善缺点。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="j.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<h4 id="D触发器的空翻"><a href="#D触发器的空翻" class="headerlink" title="D触发器的空翻"></a>D触发器的空翻</h4><p>D触发器依然存在“空翻”现象，实际广泛使用的集成D触 发器采用了维持阻塞结构，称为<strong>维持阻塞D触发器。</strong><br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="k.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<p><strong>维持阻塞D触发器状态变化产升在时钟脉冲的上升沿，其次态决定于该时刻前瞬间输入信号D。</strong></p>
<h2 id="时钟JK触发器及其分析"><a href="#时钟JK触发器及其分析" class="headerlink" title="时钟JK触发器及其分析"></a>时钟JK触发器及其分析</h2><p>为了消除时钟控制RS 触发器输入信号的约束条件，又使触发器有两个输入端，可在时钟控制RS触发器中增加两条交叉反馈线，并将输入端S改为J，R改为K。<br><img src="l.png" alt=""></p>
<h3 id="逻辑功能及其描述方法-1"><a href="#逻辑功能及其描述方法-1" class="headerlink" title="逻辑功能及其描述方法"></a>逻辑功能及其描述方法</h3><p>功能真值表和激励表<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="m.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>特征方程：<br>  Qn+1 = J 非Q + 非k Q</p>
<h3 id="主从集成JK触发器"><a href="#主从集成JK触发器" class="headerlink" title="主从集成JK触发器"></a>主从集成JK触发器</h3><p>和RS触发差不多</p>
<h2 id="时钟T触发器及其分析"><a href="#时钟T触发器及其分析" class="headerlink" title="时钟T触发器及其分析"></a>时钟T触发器及其分析</h2><p>T触发器可看成是JK触发器在J=K条件下的特例<br>T触发器的逻辑功能可概括为：T=0时触发器保持原状太不变；T=1时触发器翻转。  </p>
<p><img src="n.png" alt=""></p>
<h2 id="特征方程总结"><a href="#特征方程总结" class="headerlink" title="特征方程总结"></a>特征方程总结</h2><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="o.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;集成双稳态触发器&quot;&gt;&lt;a href=&quot;#集成双稳态触发器&quot; class=&quot;headerlink&quot; title=&quot;集成双稳态触发器&quot;&gt;&lt;/a&gt;集成双稳态触发器&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;主要内容有  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;触发器的特点及分类  &lt;
    
    </summary>
    
      <category term="数字电路" scheme="http://ranxb.cn/categories/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"/>
    
    
      <category term="数字电路" scheme="http://ranxb.cn/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"/>
    
      <category term="笔记" scheme="http://ranxb.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>数字电路电路板汇总</title>
    <link href="http://ranxb.cn/2018/01/04/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E7%94%B5%E8%B7%AF%E6%9D%BF%E6%B1%87%E6%80%BB/"/>
    <id>http://ranxb.cn/2018/01/04/数字电路电路板汇总/</id>
    <published>2018-01-04T03:22:16.000Z</published>
    <updated>2018-01-04T11:25:38.584Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数字电路电路板汇总"><a href="#数字电路电路板汇总" class="headerlink" title="数字电路电路板汇总"></a>数字电路电路板汇总</h1><h2 id="变量译码器74138"><a href="#变量译码器74138" class="headerlink" title="变量译码器74138"></a>变量译码器74138</h2><p>三输入、八输出。<br>s1为一，s2和s3为零即可正常工作。<br>根据二进制输入输出十进制的特定端口。<br>两个同时使用的时候，低位s1接1，s2接高位s1作为输入的第四端口。如图<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="a.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<h2 id="7448显示译码器"><a href="#7448显示译码器" class="headerlink" title="7448显示译码器"></a>7448显示译码器</h2><h2 id="TS547显示器"><a href="#TS547显示器" class="headerlink" title="TS547显示器"></a>TS547显示器</h2><h2 id="数据选择器74LS153"><a href="#数据选择器74LS153" class="headerlink" title="数据选择器74LS153"></a>数据选择器74LS153</h2><p>针脚如图所示<br><img src="b.png" alt=""><br>真值表如图所示<br><img src="c.png" alt=""><br>做题时会给多个输入端，此时想A0A1当成两个输入端，再从D端口中根据选择器的输出表达式连接相应第三段口即可，例如：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="d.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="e.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="f.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>  </p>
<h2 id="多位数值比较器7485"><a href="#多位数值比较器7485" class="headerlink" title="多位数值比较器7485"></a>多位数值比较器7485</h2><p>下图为数值比较器7485的单位针脚图<br><img src="g.png" alt=""><br>下图为用多个数值比较器7485的多位数值比较器的基本原理<br><img src="h.png" alt="">  </p>
<h2 id="奇偶校验器74LS280"><a href="#奇偶校验器74LS280" class="headerlink" title="奇偶校验器74LS280"></a>奇偶校验器74LS280</h2><p>四位二进制奇偶校验的真值表<br><img src="i.png" alt=""><br>奇偶校验位逻辑表达式<br><img src="j.png" alt=""></p>
<p>74LS280奇偶校验/发生器<br><img src="k.png" alt="">  </p>
<p>实际应用如下    </p>
<p><img src="l.png" alt="">  </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数字电路电路板汇总&quot;&gt;&lt;a href=&quot;#数字电路电路板汇总&quot; class=&quot;headerlink&quot; title=&quot;数字电路电路板汇总&quot;&gt;&lt;/a&gt;数字电路电路板汇总&lt;/h1&gt;&lt;h2 id=&quot;变量译码器74138&quot;&gt;&lt;a href=&quot;#变量译码器74138&quot; cla
    
    </summary>
    
      <category term="数字电路" scheme="http://ranxb.cn/categories/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"/>
    
    
      <category term="数字电路" scheme="http://ranxb.cn/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"/>
    
      <category term="笔记" scheme="http://ranxb.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>汇编第九章：转移指令的原理</title>
    <link href="http://ranxb.cn/2017/12/30/%E6%B1%87%E7%BC%96%E7%AC%AC%E4%B9%9D%E7%AB%A0%EF%BC%9A%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <id>http://ranxb.cn/2017/12/30/汇编第九章：转移指令的原理/</id>
    <published>2017-12-30T09:41:24.000Z</published>
    <updated>2017-12-30T13:30:04.582Z</updated>
    
    <content type="html"><![CDATA[<h1 id="汇编第九章：转移指令的原理"><a href="#汇编第九章：转移指令的原理" class="headerlink" title="汇编第九章：转移指令的原理"></a>汇编第九章：转移指令的原理</h1><blockquote>
<p>概括地讲，转移指令就是可以控制CPU执行内存中某处代码的指令。<br>表现为可以修改IP或者同时修改CS和IP的指令。</p>
</blockquote>
<p>以下讨论8086<br><strong><em>转移行为的分类</em></strong><br><strong>第一类：只修改IP的转移行为叫做段内转移</strong>  </p>
<blockquote>
<p>根据转一指令对IP的修改范围不同，段内转移可分为。  </p>
</blockquote>
<ol>
<li>短转移：IP的修改范围为-128 ～ 127.</li>
<li>近转移：IP的修改范围为-32768 ～ 32767.</li>
</ol>
<p><strong>第二类：同时修改CS和IP的转移行为叫段间转移</strong>   </p>
<p><strong><em>转一指令的分类</em></strong> </p>
<ol>
<li>无条件转移指令，例如jmp  </li>
<li>条件转移指令  </li>
<li>循环指令，例如loop  </li>
<li>过程  </li>
<li>中断  </li>
</ol>
<p>本章主要通过深入学习无条件转移指令jmp来理解CPU执行转移指令的基本原理  </p>
<h2 id="offset"><a href="#offset" class="headerlink" title="offset"></a>offset</h2><p><strong>功能是取得标号地址的偏移地址</strong></p>
<pre><code>code segment
start:
    mov ax,offset start        ;相当于mov ax,0
s:
    mov ax,offset s            ;相当于mov ax,3                                    
</code></pre><h2 id="jmp"><a href="#jmp" class="headerlink" title="jmp"></a>jmp</h2><p>jmp为无条件跳转指令，可以只修改IP，也可以同时修改CS和IP。<br>jmp指令要给出两种信息：  </p>
<ol>
<li>转移的目的地址  </li>
<li>转移的距离（段间转移、段内转移、段内近转移）</li>
</ol>
<h3 id="依据位移进行转移的jmp指令"><a href="#依据位移进行转移的jmp指令" class="headerlink" title="依据位移进行转移的jmp指令"></a>依据位移进行转移的jmp指令</h3><p>NO.1</p>
<pre><code>jmp short 标号（转到标号处执行指令）
</code></pre><p>这种格式实现的事段内短转移，他对IP的修改范围是-128 ～ 127，转移指令结束后，CS:IP应该指向标号指令。  </p>
<p>根据机器码可得出<strong>CPU执行jmp指令时机器码中并不需要转移的目的地址</strong>  </p>
<blockquote>
<p>CPU执行指令的过程  </p>
<ol>
<li>从CS:IP执行内存单元读取指令，读取的指令进入指令缓冲器;  </li>
<li>(IP) = (IP) + 读取的长度，从而指向下一个指令;  </li>
<li>执行指令。转到(1)，重复.</li>
</ol>
</blockquote>
<p>由此可得，执行jmp并不需要目的地址，而是需要<strong>位移地址</strong><br>short的位移量存储空间占一个字节，8个二进制位，首位为符号位，用补码表示，因此可表示的位移量为-128 ～ 127。<br>同理，near的位移量储存空间占两个字节，16个二进制位，首位为符号位，用补码表示，因此可表示的位移量为-32768 ～ 32767。</p>
<p>由上引入近转移</p>
<pre><code>jmp near ptr 标号（段内近转移）
</code></pre><h3 id="转移的目的地址在指令中的jmp指令"><a href="#转移的目的地址在指令中的jmp指令" class="headerlink" title="转移的目的地址在指令中的jmp指令"></a>转移的目的地址在指令中的jmp指令</h3><p>前面讲的是段内转移，因此jmp只需要位移地址即可进行对IP的修改。</p>
<pre><code>jmp far ptr 标号
</code></pre><p>以上实现的是段间转移，又称远转移。可以让(CS) = 标号所在的段地址;(IP) = 标号所在的偏移地址。</p>
<h3 id="转移地址在寄存器中的jmp指令"><a href="#转移地址在寄存器中的jmp指令" class="headerlink" title="转移地址在寄存器中的jmp指令"></a>转移地址在寄存器中的jmp指令</h3><pre><code>jmp 16位reg
</code></pre><p>功能：(IP) = (16位reg)<br>用寄存器中的值修改IP。</p>
<h3 id="转移地址在内存中的jmp指令"><a href="#转移地址在内存中的jmp指令" class="headerlink" title="转移地址在内存中的jmp指令"></a>转移地址在内存中的jmp指令</h3><blockquote>
<p>两种格式  </p>
</blockquote>
<p><strong>段内转移</strong></p>
<pre><code>jmp word ptr 内存单元地址 ;(段内转移)
</code></pre><p>从内存单元地址处开始存放着一个字，是转移的目的的偏移地址。<br>例如：</p>
<pre><code>mov ax,0123H
mov ds:[0],ax
jmp word ptr ds:[0]
</code></pre><p>执行后(IP) = 0123H </p>
<p><strong>段间转移</strong></p>
<pre><code>jmp dword ptr 内存单元地址  ;(段间转移)
</code></pre><p>从内存单元地址处开始存放着两个字节，是转移的目的的段地址和偏移地址，<strong>高地址是段地址</strong>，<strong>低地址是偏移地址</strong><br>(CS) = 内存单元地址+2<br>(IP) = 内存单元地址<br>比如一下指令：  </p>
<pre><code>mov ax,0123H
mov ds:[0],ax
mov ax,4567H
mov ds:[2],ax
jmp dword ptr ds:[0]
</code></pre><p>执行完后(CS) = 4567H,(IP) = 0123H。 </p>
<h2 id="jcxz指令"><a href="#jcxz指令" class="headerlink" title="jcxz指令"></a>jcxz指令</h2><p>jcxz是有条件转移指令，<strong>所有的有条件转移指令都是短转移指令</strong>，对应的机器码中包含的是转移位移，不是目的地址。对IP的修改范围都是-128 ~ 127。</p>
<p><strong>jcxz == jmp when cx is zero</strong><br>当cx为零时，执行转移指令，若不为零，则不转移<br>使用格式：</p>
<pre><code>jcxz 标号
</code></pre><h2 id="loop指令"><a href="#loop指令" class="headerlink" title="loop指令"></a>loop指令</h2><p>loop指令位循环指令，所有的循环指令都是短转移。<br><strong>详见第五章</strong></p>
<h2 id="根据位移进行转移的意义"><a href="#根据位移进行转移的意义" class="headerlink" title="根据位移进行转移的意义"></a>根据位移进行转移的意义</h2><pre><code>jmp short x
jmp near ptr x
jcxz x
loop
</code></pre><p>以上都是根据转移的位移量进行转移的，这样有利于程序在内存中的浮动装配，意思就是把这段程序装在内存中的任意一段空间内都可以执行，不会因为转移的地址不同而导致程序不能执行。</p>
<h2 id="编译器对转移位移超界的检测"><a href="#编译器对转移位移超界的检测" class="headerlink" title="编译器对转移位移超界的检测"></a>编译器对转移位移超界的检测</h2><p><strong>jmp超界编译器会报错</strong>，别的没其他知识点</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;汇编第九章：转移指令的原理&quot;&gt;&lt;a href=&quot;#汇编第九章：转移指令的原理&quot; class=&quot;headerlink&quot; title=&quot;汇编第九章：转移指令的原理&quot;&gt;&lt;/a&gt;汇编第九章：转移指令的原理&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;概括地讲，转移指令就是可以
    
    </summary>
    
      <category term="汇编语言" scheme="http://ranxb.cn/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="笔记" scheme="http://ranxb.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="汇编语言" scheme="http://ranxb.cn/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>汇编第八章：数据处理的两个基本问题</title>
    <link href="http://ranxb.cn/2017/12/29/%E6%B1%87%E7%BC%96%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98/"/>
    <id>http://ranxb.cn/2017/12/29/汇编第八章：数据处理的两个基本问题/</id>
    <published>2017-12-28T19:23:25.000Z</published>
    <updated>2017-12-30T09:40:34.461Z</updated>
    
    <content type="html"><![CDATA[<h1 id="汇编第八章：数据处理的两个基本问题"><a href="#汇编第八章：数据处理的两个基本问题" class="headerlink" title="汇编第八章：数据处理的两个基本问题"></a>汇编第八章：数据处理的两个基本问题</h1><blockquote>
<p>章前言说的是对前面所有的内容是有总结性的，这里主要探讨两个问题：  </p>
<ol>
<li>处理的数据在什么地方？  </li>
<li>处理的数据有多长？</li>
</ol>
</blockquote>
<p>定义两个符号<strong>reg</strong>和<strong>sreg</strong><br><strong>reg</strong>代表寄存器，包括：ax,bx,cx,dx,ah,al,bh,bl,ch,cl,dh,dl,sp,bp,si,di<br><strong>sreg</strong>代表段寄存器，包括：ds,ss,cs,es</p>
<h2 id="bx、si、di、bp的使用规则"><a href="#bx、si、di、bp的使用规则" class="headerlink" title="bx、si、di、bp的使用规则"></a>bx、si、di、bp的使用规则</h2><blockquote>
<p>三个规则，一会总结，字比较多，等会打。</p>
</blockquote>
<ol>
<li><p>只有这四个寄存器可以用在[…]中进行寻址  </p>
<pre><code>mov ax,[bx]
mov ax,[bx+si]
</code></pre><p>以下的是错误的</p>
<pre><code>mov ax,[cx]
mov ax,[ax]
</code></pre></li>
<li><p>这四个可以单独出现，但是组合的情况只有四种可以使用：bx和si、bx和di、bp和si、bp和di。  </p>
<pre><code>mov ax,[bx+si]
mov ax,[bx+di]
mov ax,[bp+si]
mov ax,[bp+di+idata]
</code></pre><p>以下的是错误的</p>
<pre><code>mov ax.[bx+dp]
mov ax,[si+di]
</code></pre></li>
<li><p>只要使用[…]中bp寄存器时，若没有显式的给出段寄存器，则默认为段地址在ss中</p>
<pre><code>mov ax,[bp]             ;(ax) = ((ss)*16+(bp))
</code></pre></li>
</ol>
<h2 id="机器指令处理的数据在什么地方"><a href="#机器指令处理的数据在什么地方" class="headerlink" title="机器指令处理的数据在什么地方"></a>机器指令处理的数据在什么地方</h2><p>机器指令都是经过处理过的数据：1、读取。2、存入。3、运行  </p>
<p>所有处理的数据可以在三个地方：CPU内部、内存、端口（后面说先不用管）<br>例如：</p>
<pre><code>mov bx,[0]                ;内存
mov bx,ax                ;CPU内部ax寄存器
mov bx,1                ;CPU内部指令缓冲器
</code></pre><h2 id="汇编语言中数据位置的表达"><a href="#汇编语言中数据位置的表达" class="headerlink" title="汇编语言中数据位置的表达"></a>汇编语言中数据位置的表达</h2><p>汇编语言用3个概念来表达数据的位置：  </p>
<ol>
<li><p>立即数[idata]<br>例如：</p>
<p> mov ax,1<br> add bx,2000H<br> or bx,00010000B<br> mov al,’a’</p>
</li>
</ol>
<p>以上   </p>
<ol>
<li><p>寄存器<br>例如</p>
<p> mov ax,bx<br> push ds<br>以上  </p>
</li>
<li><p>段地址和偏移地址<br>例如</p>
<p> mov ax,[bx]            ;段地址默认在ds中</p>
</li>
</ol>
<h2 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h2><p><strong>五种寻址方式：</strong>  </p>
<ol>
<li>[idata] <strong>直接寻址</strong>  </li>
<li>[bx] <strong>寄存器间接寻址</strong>  </li>
<li>[bx+idata] <strong>寄存器相对寻址</strong>  </li>
<li>[bx+si] <strong>基址变址寻址</strong>  </li>
<li>[bx+si+idata] <strong>相对基址变址寻址</strong></li>
</ol>
<p>总结：<strong>有两个寄存器就是基址变址，只要有idata就是相对（只有idata是直接寻址，只有一个寄存器是寄存器间接寻址）</strong></p>
<h2 id="指令要处理的数据有多长"><a href="#指令要处理的数据有多长" class="headerlink" title="指令要处理的数据有多长"></a>指令要处理的数据有多长</h2><ol>
<li>通过寄存器名可以致命处理的数据长度</li>
<li><p>在没有寄存器的情况下，用操作符“X ptr”指明要操作的长度，X可以是byte或者是word。<br>例如</p>
<pre><code>mov word prt ds:[0],1
inc word prt [bx]

mov byte ptr ds:[0],1
add byte ptr [bx],2
</code></pre><h2 id="寻址的综合应用"><a href="#寻址的综合应用" class="headerlink" title="寻址的综合应用"></a>寻址的综合应用</h2><blockquote>
<p>主要就是类c语言的数组的操作，看看书看就行了。</p>
</blockquote>
</li>
</ol>
<h2 id="div"><a href="#div" class="headerlink" title="div"></a><strong>div</strong></h2><blockquote>
<p>两种div方式！(被除数是除号之前的。)</p>
</blockquote>
<ol>
<li>16位寄存器除以8位寄存器：16位做被除数放在AX里面。商在AL里，余数在AH里</li>
<li>32位寄存器除以16位寄存器：高16位放在DX，低16位放在AX里，共32位做被除数。商在AX里，余数在DX里。  </li>
</ol>
<p><strong>商都放在低位寄存器中，余数放在高位，除数放在一个内存单元或者reg中</strong><br>例如：</p>
<pre><code>16位/8位：
    div byte ptr ds:[0]        
    ;(al) = (ax)/((ds)*16+0)
    ;(ah) = (ax)mod((ds)*16+0)

32位/8位：
    div word ptr ds:[0]        
    ;(ax) = [(dx)*10000H + (ax)] / ((ds)*16+0)
    ;(dx) = [(dx)*10000H + (ax)] mod ((ds)*16+0)
</code></pre><p>实际应用，例如100001/100,100001 = 186A1H</p>
<pre><code>mov dx,1H
mov ax,86A1H
mov bx,100
div bx
;商在AX里，余数在DX里
</code></pre><h2 id="dd"><a href="#dd" class="headerlink" title="dd"></a>dd</h2><blockquote>
<p>dd（define double）,用于定义双精度字节，一个双精度占2个字，4个字节。</p>
</blockquote>
<pre><code>data segment
    db 1
    dw 1
    dd 1
data ends
</code></pre><p>上面这段：  </p>
<pre><code>1. 第一个数据是01H，在data:[0]处  
2. 第二个数据是0001H，在data:[1] - data:[2]处  
3. 第三个数据是00000001H，在data:[3] - data:[6]处  
</code></pre><h2 id="dup"><a href="#dup" class="headerlink" title="dup"></a>dup</h2><p>和dd一样都是一个操作符，它是和db、dw、dd等数据定义伪指令配合使用的，用来进行数据的重复，比如：</p>
<pre><code>db 3 dup (0)
</code></pre><p>定义了3个字节，他们的值都是0，相当于</p>
<pre><code>db 0,0,0
</code></pre><p>又例如：</p>
<pre><code>db 3 dup (0,1,2)
</code></pre><p>定义了9个字节，分别是0,1,2,0,1,2,0,1,2,相当于</p>
<pre><code>db 0,1,2,0,1,2,0,1,2
</code></pre><p><strong>使用规范如下</strong></p>
<pre><code>db 重复次数 dup (内容)        ;(重复的字节型数据)
dw 重复次数 dup (内容)        ;(重复的字型数据)
dd 重复次数 dup (内容)        ;(重复的双精度字型数据)
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;汇编第八章：数据处理的两个基本问题&quot;&gt;&lt;a href=&quot;#汇编第八章：数据处理的两个基本问题&quot; class=&quot;headerlink&quot; title=&quot;汇编第八章：数据处理的两个基本问题&quot;&gt;&lt;/a&gt;汇编第八章：数据处理的两个基本问题&lt;/h1&gt;&lt;blockquote&gt;

    
    </summary>
    
      <category term="汇编语言" scheme="http://ranxb.cn/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="笔记" scheme="http://ranxb.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="汇编语言" scheme="http://ranxb.cn/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>汇编第七章：更灵活的定位内存地址的方式</title>
    <link href="http://ranxb.cn/2017/12/29/%E6%B1%87%E7%BC%96%E7%AC%AC%E4%B8%83%E7%AB%A0%EF%BC%9A%E6%9B%B4%E7%81%B5%E6%B4%BB%E7%9A%84%E5%AE%9A%E4%BD%8D%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E7%9A%84%E6%96%B9%E5%BC%8F/"/>
    <id>http://ranxb.cn/2017/12/29/汇编第七章：更灵活的定位内存地址的方式/</id>
    <published>2017-12-28T18:46:40.000Z</published>
    <updated>2017-12-28T19:12:36.919Z</updated>
    
    <content type="html"><![CDATA[<h1 id="汇编第七章：更灵活的定位内存地址的方式"><a href="#汇编第七章：更灵活的定位内存地址的方式" class="headerlink" title="汇编第七章：更灵活的定位内存地址的方式"></a>汇编第七章：更灵活的定位内存地址的方式</h1><h2 id="and、or指令"><a href="#and、or指令" class="headerlink" title="and、or指令"></a>and、or指令</h2><p><strong>and</strong> 按位与 </p>
<pre><code>mov al,01100011B
and al,00111011B
</code></pre><p>结果为<strong><em>al = 00100011B</em></strong>    </p>
<p><strong>or</strong> 按位和  </p>
<pre><code>mov al,01100011B
or al,00111011B
</code></pre><p>结果为<strong><em>al = 01111011B</em></strong>  </p>
<h2 id="关于ASCII码"><a href="#关于ASCII码" class="headerlink" title="关于ASCII码"></a>关于ASCII码</h2><pre><code>data segment
    db &apos;unIX&apos;
data ends
</code></pre><p>相当于</p>
<pre><code>data segment
    db 75H,6EH,49H,58H
data ends
</code></pre><p>一个字母一个字节  </p>
<ol>
<li><strong>小写字母ASCII码比大写字母大</strong>  </li>
<li><strong>将’a’的ASCII码减20H就可以变成大写字母’A’</strong>  </li>
<li><strong>将’A’的ASCII码加20H就可以变成小写字母’a’</strong>  </li>
<li><strong>当ASCII码大于61H的时候是小写字母</strong>  </li>
<li><strong>ASCII码的二进制形式第五位为1时是小写字母，0时大写字母</strong>  </li>
</ol>
<blockquote>
<p>根据上面第五条可以进行大小写转换！  </p>
</blockquote>
<pre><code>and al,11101111B
</code></pre><p>可以把字母变成大写  </p>
<pre><code>or al,00010000B
</code></pre><p>可以把字母变成小写  </p>
<h2 id="bx-idata"><a href="#bx-idata" class="headerlink" title="[bx+idata]"></a>[bx+idata]</h2><p><strong><em>[bx+idata]表示一个内存单元,他的偏移地址是(bx)+idata(bx的值加上idata)</em></strong>  </p>
<blockquote>
<p>mov ax,[bx+200] == ax = ((dx)*16 + (bx) + 200)  </p>
</blockquote>
<p>该指令也可以写成</p>
<pre><code>mov ax,[200+bx]
mov ax,200[bx]
mov ax,[bx].200
</code></pre><p>因此，[bx+idata]的方式为高级语言实现数组提供了便利机制  </p>
<pre><code>C语言：a[i],b[i]
汇编语言：0[bx],5[bx]([bx+0],[bx+5])
</code></pre><h2 id="SI和DI"><a href="#SI和DI" class="headerlink" title="SI和DI"></a>SI和DI</h2><p><strong>SI和DI是8086中和bx相似的寄存器</strong>，但是不能像bx一样分成两个八位寄存器来使用<br>因此我们可以更灵活的使用：<strong><em>[bx+si]</em></strong>类似的方式表示一个内存一个内存单元<br>例如：</p>
<pre><code>mov ax,[bx+si]
</code></pre><p>意为(ax) = (dx*16) + (bx) + (si)<br>也可以写成</p>
<pre><code>mov ax,[bx][si]
</code></pre><h2 id="不同的寻址方式的灵活应用"><a href="#不同的寻址方式的灵活应用" class="headerlink" title="不同的寻址方式的灵活应用"></a>不同的寻址方式的灵活应用</h2><ol>
<li>[idata]用一个常量来表示地址，可用于直接定位一个内存</li>
<li>[bx]用一个变量来表示一个内存，可用于间接定位一个内存单元</li>
<li>[bx+idata]用一个变量和一个常量来表示内存地址，可在一个起始地址的基础上用变量简介定位一个内存，例如数组。</li>
<li>[bx+si]用两个变量表示一个内存地址</li>
<li>[bx+si+idata]用两个变量和一个常量表示一个内存地址</li>
</ol>
<h2 id="一道大题问题7-9（先复习，回头再写）"><a href="#一道大题问题7-9（先复习，回头再写）" class="headerlink" title="一道大题问题7.9（先复习，回头再写）"></a>一道大题问题7.9（先复习，回头再写）</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;汇编第七章：更灵活的定位内存地址的方式&quot;&gt;&lt;a href=&quot;#汇编第七章：更灵活的定位内存地址的方式&quot; class=&quot;headerlink&quot; title=&quot;汇编第七章：更灵活的定位内存地址的方式&quot;&gt;&lt;/a&gt;汇编第七章：更灵活的定位内存地址的方式&lt;/h1&gt;&lt;h2 i
    
    </summary>
    
      <category term="汇编语言" scheme="http://ranxb.cn/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="笔记" scheme="http://ranxb.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="汇编语言" scheme="http://ranxb.cn/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>现代第二章</title>
    <link href="http://ranxb.cn/2017/12/28/%E7%8E%B0%E4%BB%A3%E7%AC%AC%E4%BA%8C%E7%AB%A0/"/>
    <id>http://ranxb.cn/2017/12/28/现代第二章/</id>
    <published>2017-12-28T12:08:13.000Z</published>
    <updated>2017-12-28T19:34:15.439Z</updated>
    
    <content type="html"><![CDATA[<h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><h2 id="向量引入"><a href="#向量引入" class="headerlink" title="向量引入"></a>向量引入</h2><h3 id="线性相关无关性"><a href="#线性相关无关性" class="headerlink" title="线性相关无关性"></a>线性相关无关性</h3><h3 id="向量的秩"><a href="#向量的秩" class="headerlink" title="向量的秩"></a>向量的秩</h3><h2 id="矩阵的运算"><a href="#矩阵的运算" class="headerlink" title="矩阵的运算"></a>矩阵的运算</h2><pre><code>1）！*不可逆乘*
2）一个行 * 一个列 = 一个数
3）对角全为一的矩阵是单位矩阵计为E
4）单位矩阵相当于乘法中的1
5）任何矩阵与单位矩阵相乘都等于本身
6）若AB == BA ，则称AB是可交换的
7）矩阵的乘法不满足消除律
8）矩阵的转置计为A
9）（AB）t == Bt*At
10) (kA)t == kAt
11）如果At == A，那么这个矩阵式是对称的
12）如果At == -A，那么这个矩阵式是反对称的
13）对角矩阵是只有对角线上的矩阵，A = diag(a,b,c,d...)
14）对角矩阵的数都一样的时候是数量矩阵，全是一的时候单位矩阵。
</code></pre><h3 id="可交换矩阵-逆矩阵"><a href="#可交换矩阵-逆矩阵" class="headerlink" title="可交换矩阵(逆矩阵)"></a>可交换矩阵(逆矩阵)</h3><pre><code>可交换矩阵的充要条件：

(1) 设A , B 至少有一个为零矩阵,则A , B 可交换;
(2) 设A , B 至少有一个为单位矩阵, 则A , B可交换;
(3) 设A , B 至少有一个为数量矩阵, 则A , B可交换;
(4) 设A , B 均为对角矩阵,则A , B 可交换;
(5) 设A , B 均为准对角矩阵（准对角矩阵是分块矩阵概念下的一种矩阵。即除去主对角线上分块矩阵不为零矩阵外，其余分块矩阵均为零矩阵）,且对角线上的子块均可交换，则A , B 可交换;
(6) 设A*是A 的伴随矩阵,则A*与A可交换;
(7) 设A可逆,则A 与其逆矩阵可交换;
注：A的逆矩阵经过数乘变换所得到的矩阵也可以与A进行交换。
(8)（n=0,1...,   ）可与  (m=0,1...,   )交换.这一点由矩阵乘法的结合律证明。
</code></pre><p>求所有可交换矩阵</p>
<pre><code>求A的所有可交换矩阵，所以设AZ == ZA，Z = [a,b;c,d]，求出Z即可～
</code></pre><h2 id="矩阵的初等变化及其标准型"><a href="#矩阵的初等变化及其标准型" class="headerlink" title="矩阵的初等变化及其标准型"></a>矩阵的初等变化及其标准型</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;矩阵&quot;&gt;&lt;a href=&quot;#矩阵&quot; class=&quot;headerlink&quot; title=&quot;矩阵&quot;&gt;&lt;/a&gt;矩阵&lt;/h1&gt;&lt;h2 id=&quot;向量引入&quot;&gt;&lt;a href=&quot;#向量引入&quot; class=&quot;headerlink&quot; title=&quot;向量引入&quot;&gt;&lt;/a&gt;向量引入&lt;/h
    
    </summary>
    
      <category term="线性代数" scheme="http://ranxb.cn/categories/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
    
      <category term="笔记" scheme="http://ranxb.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="线性代数" scheme="http://ranxb.cn/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>汇编第六章：包含多个短的程序</title>
    <link href="http://ranxb.cn/2017/12/28/%E6%B1%87%E7%BC%96%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E5%8C%85%E5%90%AB%E5%A4%9A%E4%B8%AA%E7%9F%AD%E7%9A%84%E7%A8%8B%E5%BA%8F/"/>
    <id>http://ranxb.cn/2017/12/28/汇编第六章：包含多个短的程序/</id>
    <published>2017-12-28T12:07:59.000Z</published>
    <updated>2017-12-28T18:21:14.005Z</updated>
    
    <content type="html"><![CDATA[<h1 id="汇编第六章：包含多个短的程序"><a href="#汇编第六章：包含多个短的程序" class="headerlink" title="汇编第六章：包含多个短的程序"></a>汇编第六章：包含多个短的程序</h1><blockquote>
<p>dw  == define word  </p>
</blockquote>
<p>一个dw：<strong>16位两字节</strong>  </p>
<h2 id="start…end-start"><a href="#start…end-start" class="headerlink" title="start…end start"></a>start…end start</h2><p>如果程序入口不是我们想要执行的指令可以使用start指令指明程序入口所在  </p>
<pre><code>assume cs:code
code segment
        .
        .
        .
        dw 0123h,1456h;数据
        .
        .
        .
start:
        .
        .
        .
        mov ax,0;代码
        .
        .
        .
        mov ax,4c00H
        int 21H
code ends
end start
</code></pre><p><strong>一个段的容量不能大于64kb</strong><br>因此可以考虑使用多个段来存放数据、代码、和栈。<br><strong>stack</strong> == 栈  </p>
<blockquote>
<p>8086不允许将一个数值直接送入段寄存器，例如“mov ds,data”。data也会被编译器处理为表示一个段地址的数值  </p>
</blockquote>
<p>data、satck、code也仅仅是命名而已，就跟标号一样，需要用assume将他们和cpu联系起来<br>因此程序有以下模板  </p>
<pre><code>assume cs:code,ss:stack,ds:data

data segment
    dw ..........
data ends

stack segment
    dw 0,0,0,0,0,0.....
stack ends

code segment

    start:
        mov ax,data                ;数据段空间
        mov ds,ax
        mov bx,0

        mov ax,stack            ;栈空间
        mov ss,ax
        mov sp,0
        .
        .
        .
code ends

start end 
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;汇编第六章：包含多个短的程序&quot;&gt;&lt;a href=&quot;#汇编第六章：包含多个短的程序&quot; class=&quot;headerlink&quot; title=&quot;汇编第六章：包含多个短的程序&quot;&gt;&lt;/a&gt;汇编第六章：包含多个短的程序&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;dw  == de
    
    </summary>
    
      <category term="汇编语言" scheme="http://ranxb.cn/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="笔记" scheme="http://ranxb.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="汇编语言" scheme="http://ranxb.cn/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>汇编第五章 [BX]和loop指令</title>
    <link href="http://ranxb.cn/2017/12/28/%E6%B1%87%E7%BC%96%E7%AC%AC%E4%BA%94%E7%AB%A0-BX-%E5%92%8Cloop%E6%8C%87%E4%BB%A4/"/>
    <id>http://ranxb.cn/2017/12/28/汇编第五章-BX-和loop指令/</id>
    <published>2017-12-28T12:07:35.000Z</published>
    <updated>2017-12-28T19:33:59.114Z</updated>
    
    <content type="html"><![CDATA[<h1 id="汇编第五章-BX-和loop指令"><a href="#汇编第五章-BX-和loop指令" class="headerlink" title="汇编第五章 [BX]和loop指令"></a>汇编第五章 [BX]和loop指令</h1><p><strong>[bx]</strong>表示偏移地址<br><strong>ss:ip</strong>   表示栈段<br><strong>push ax</strong>的具体流程  </p>
<pre><code>push ax:
sp = sp - 2;
(ss:sp) = ax;
</code></pre><p><strong>pop ax</strong>的具体操作  </p>
<pre><code>pop ax:
ax = (ss:sp);
sp+=2;  
</code></pre><p><strong>inc ax</strong>  ax的内容加1  </p>
<p><strong>mov ax,2000H</strong>   其中ah = 20 al = 00  </p>
<pre><code>当
BE   21000H
00   21001H
.
.
.

mov ax,2100H;
mox dx,ax;
mov bx,0;
mov ax,[bx]

此时 ax = 00BE
</code></pre><p>！！意为先存低位，在存高位。  </p>
<h2 id="LOOP指令"><a href="#LOOP指令" class="headerlink" title="LOOP指令"></a>LOOP指令</h2><p><strong>LOOP执行顺序</strong></p>
<pre><code>LOOP执行顺序：
1.CX--;
2.CX==0?顺序执行:循环
</code></pre><p><strong>CX设置循环次数</strong></p>
<pre><code>  例如：
  mov cx,11
L:add ax,1
  LOOP L
</code></pre><p><strong>将ffff传入ax中的时候要前面加零</strong></p>
<pre><code>mov ax,0ffffH
mov dx,ax
.
.
.
</code></pre><p><strong>汇编语言程序中，数据不能以字母开头</strong></p>
<h2 id="DEBUG和汇编编译器MASM对指令的不同处理"><a href="#DEBUG和汇编编译器MASM对指令的不同处理" class="headerlink" title="DEBUG和汇编编译器MASM对指令的不同处理"></a>DEBUG和汇编编译器MASM对指令的不同处理</h2><p><strong>DEBUG中：</strong><br><em>mov al,[0]</em> ;含义：(al) = ((dx)<em>16+0)<br><strong>源程序中:</strong>     
</em>mov al,[0]* ;含义：(al) = 0  </p>
<blockquote>
<p>在源程序中，如果用指令访问一个内存单元，则在指令中必须用“[…]”来表示内存单元<br>，如果在“[]”里直接用一个常量idata直接给出内存单元的偏移地址，就要在”[]”的前面<br>显示的给出段地址所在的段寄存器。  </p>
</blockquote>
<p>例如：</p>
<pre><code>mov ax,dx:[0]
</code></pre><h2 id="段前缀"><a href="#段前缀" class="headerlink" title="段前缀"></a>段前缀</h2><p>以上这样的表示方法dx叫做<strong>段前缀</strong><br>类似的比如  </p>
<pre><code>mov ax,ds:[0]
mov ax,cx:[0]
mov ax,ss:[0]
mov ax,es:[0]
</code></pre><p>等等ds:、cx:、ss:、es:、都叫做段前缀  </p>
<h2 id="一段安全的空间"><a href="#一段安全的空间" class="headerlink" title="一段安全的空间"></a>一段安全的空间</h2><p>直接向内存中写入数据时，要用：<br><strong>0:200 ～ 0:2ff</strong>  </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;汇编第五章-BX-和loop指令&quot;&gt;&lt;a href=&quot;#汇编第五章-BX-和loop指令&quot; class=&quot;headerlink&quot; title=&quot;汇编第五章 [BX]和loop指令&quot;&gt;&lt;/a&gt;汇编第五章 [BX]和loop指令&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;[bx]
    
    </summary>
    
      <category term="汇编语言" scheme="http://ranxb.cn/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="笔记" scheme="http://ranxb.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="汇编语言" scheme="http://ranxb.cn/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言中寄存器ESP和EBP的理解</title>
    <link href="http://ranxb.cn/2017/11/04/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%AF%84%E5%AD%98%E5%99%A8ESP%E5%92%8CEBP%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://ranxb.cn/2017/11/04/汇编语言中寄存器ESP和EBP的理解/</id>
    <published>2017-11-04T04:31:45.000Z</published>
    <updated>2017-12-28T19:25:54.068Z</updated>
    
    <content type="html"><![CDATA[<h1 id="汇编语言中寄存器ESP和EBP的理解"><a href="#汇编语言中寄存器ESP和EBP的理解" class="headerlink" title="汇编语言中寄存器ESP和EBP的理解"></a>汇编语言中寄存器ESP和EBP的理解</h1><blockquote>
<p>   学校在做信息活动月，有个活动是对xp系统中的一个应用程序进行反汇编，了解他的运行机制，但是在中间有一部分对寄存器的概念有点生疏，所以在网上看到一个好的材料，所以码一下</p>
</blockquote>
<p>一直对寄存器ESP和EBP的概念总是有些混淆，查看定义ESP是栈顶指针，EBP是存取堆栈指针。还是不能很透彻理解。之后借于一段汇编代码，总算是对两者有个比较清晰的理解。<br>下面是按调用约定__stdcall 调用函数test(int p1,int p2)的汇编代码</p>
<pre><code>;假设执行函数前堆栈指针ESP为NN
push   p2    ;参数2入栈, ESP -= 4h , ESP = NN - 4h
push   p1    ;参数1入栈, ESP -= 4h , ESP = NN - 8h
call test    ;压入返回地址 ESP -= 4h, ESP = NN - 0Ch  
;//进入函数内
</code></pre><p>看完汇编后,再看EBP和ESP的定义,哦,豁然开朗,<br>原来ESP就是一直指向栈顶的指针,而EBP只是存取某时刻的栈顶指针,以方便对栈的操作,如获取函数参数、局部变量等。</p>
<pre><code>{
        push   ebp                        ;保护先前EBP指针， EBP入栈， ESP-=4h, ESP = NN - 10h
        mov    ebp, esp                   ;设置EBP指针指向栈顶 NN-10h
        mov    eax, dword ptr  [ebp+0ch]  ;ebp+0ch为NN-4h,即参数2的位置
        mov    ebx, dword ptr  [ebp+08h]  ;ebp+08h为NN-8h,即参数1的位置
        sub    esp, 8                     ;局部变量所占空间ESP-=8, ESP = NN-18h
        ...
        add    esp, 8                     ;释放局部变量, ESP+=8, ESP = NN-10h
        pop    ebp                        ;出栈,恢复EBP, ESP+=4, ESP = NN-0Ch
        ret    8                          ;ret返回,弹出返回地址,ESP+=4, ESP=NN-08h,
                                            后面加操作数8为平衡堆栈,ESP+=8,ESP=NN, 恢复进入函数前的堆栈.
}
</code></pre><p>转自：<a href="http://blog.csdn.net/zsjum/article/details/6117043" target="_blank" rel="external">通过一段汇编，加深对寄存器ESP和EBP的理解</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;汇编语言中寄存器ESP和EBP的理解&quot;&gt;&lt;a href=&quot;#汇编语言中寄存器ESP和EBP的理解&quot; class=&quot;headerlink&quot; title=&quot;汇编语言中寄存器ESP和EBP的理解&quot;&gt;&lt;/a&gt;汇编语言中寄存器ESP和EBP的理解&lt;/h1&gt;&lt;blockquo
    
    </summary>
    
      <category term="汇编语言" scheme="http://ranxb.cn/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="笔记" scheme="http://ranxb.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="汇编语言" scheme="http://ranxb.cn/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>成都的流水账</title>
    <link href="http://ranxb.cn/2017/11/03/%E6%88%90%E9%83%BD%E7%9A%84%E6%B5%81%E6%B0%B4%E8%B4%A6/"/>
    <id>http://ranxb.cn/2017/11/03/成都的流水账/</id>
    <published>2017-11-03T09:57:01.000Z</published>
    <updated>2017-11-03T10:03:42.908Z</updated>
    
    <content type="html"><![CDATA[<h1 id="成都的流水账"><a href="#成都的流水账" class="headerlink" title="成都的流水账"></a>成都的流水账</h1><blockquote>
<p>我文笔也不好，今天在图书馆心情复杂也不知道干点啥，我就记一记流水账吧。</p>
</blockquote>
<p>那我就开始了～<br>等等～脑婆叫我去吃饭！</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="UNADJUSTEDNONRAW_thumb_4.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;成都的流水账&quot;&gt;&lt;a href=&quot;#成都的流水账&quot; class=&quot;headerlink&quot; title=&quot;成都的流水账&quot;&gt;&lt;/a&gt;成都的流水账&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;我文笔也不好，今天在图书馆心情复杂也不知道干点啥，我就记一记流水账吧。&lt;/p&gt;
&lt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数电笔记：第一章数字逻辑基础</title>
    <link href="http://ranxb.cn/2017/10/29/%E6%95%B0%E7%94%B5%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E5%9F%BA%E7%A1%80/"/>
    <id>http://ranxb.cn/2017/10/29/数电笔记：第一章数字逻辑基础/</id>
    <published>2017-10-29T15:05:21.000Z</published>
    <updated>2017-12-28T12:12:28.786Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数电笔记2017-10-29"><a href="#数电笔记2017-10-29" class="headerlink" title="数电笔记2017-10-29"></a>数电笔记2017-10-29</h1><h2 id="第一章-数字逻辑基础"><a href="#第一章-数字逻辑基础" class="headerlink" title="第一章    数字逻辑基础"></a>第一章    数字逻辑基础</h2><blockquote>
<p>模拟信号<br>电信号</p>
</blockquote>
<h3 id="二进制的转换"><a href="#二进制的转换" class="headerlink" title="二进制的转换"></a>二进制的转换</h3><pre><code>按权展开
</code></pre><h4 id="整数转换"><a href="#整数转换" class="headerlink" title="整数转换"></a>整数转换</h4><p><strong><em>除2取余</em></strong></p>
<h4 id="纯小数转换"><a href="#纯小数转换" class="headerlink" title="纯小数转换"></a>纯小数转换</h4><p><strong><em>乘2取整</em></strong></p>
<h3 id="十进制转R进制数的转换"><a href="#十进制转R进制数的转换" class="headerlink" title="十进制转R进制数的转换"></a>十进制转R进制数的转换</h3><h4 id="整数转换-1"><a href="#整数转换-1" class="headerlink" title="整数转换"></a>整数转换</h4><p><strong><em>除R取余</em></strong></p>
<h4 id="纯小数转换-1"><a href="#纯小数转换-1" class="headerlink" title="纯小数转换"></a>纯小数转换</h4><p><strong><em>乘R取整</em></strong></p>
<h3 id="二、八、十六进制数之间的转换"><a href="#二、八、十六进制数之间的转换" class="headerlink" title="二、八、十六进制数之间的转换"></a>二、八、十六进制数之间的转换</h3><p><strong><em>三位二进制为一个八进制</em></strong><br><strong><em>四位二进制为一个十六进制</em></strong>  </p>
<blockquote>
<p>   例如：二进制转八进制从小数点向左或向右分别按三位一组转换为八进制，最后不满三位的用零补齐  </p>
</blockquote>
<h3 id="带符号数的代码表示"><a href="#带符号数的代码表示" class="headerlink" title="带符号数的代码表示"></a>带符号数的代码表示</h3><p>一个带符号的数由两部分组成：一部分表示数的符号；另一部分表示数的数值。<br>在计算机中习惯用0表示正数、1用来表示负数。  </p>
<blockquote>
<pre><code>为了在计算机中防止电路过于复杂，使乘法变成加法运算，人们提出了3种机器数的表示形式，称为：原码、补码、反码。
</code></pre></blockquote>
<h4 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h4><blockquote>
<p>   原码又称为“符号–数值表示”<br>特点：  </p>
<ol>
<li>当N为正数时，N的原码与N的区别仅为最高位增加一位用0表示的符号位，对本身数值并无影响。</li>
<li>当N为负数时，N的原码与N的区别是在最高位增加一位用1表示的符号位。</li>
<li>在原码表示中，有两种零，即为正负零。0.000和1.000</li>
</ol>
</blockquote>
<h4 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h4><blockquote>
<p>   反码又被称为“对1的补数”。<br>对于负数，反码的数值是将原码数值按位求反，即原码的某位为1，反码相应为0.<br>对于正数反码与原码相同</p>
</blockquote>
<h4 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h4><h3 id="计算机中的运算"><a href="#计算机中的运算" class="headerlink" title="计算机中的运算"></a>计算机中的运算</h3><h2 id="码制和字符的代码表示"><a href="#码制和字符的代码表示" class="headerlink" title="码制和字符的代码表示"></a>码制和字符的代码表示</h2><ol>
<li>8421码</li>
<li>余3码</li>
<li>2421码</li>
<li>余3循环码</li>
</ol>
<blockquote>
<p>可靠性编码  </p>
<ol>
<li>格雷码（循环码）  </li>
<li>奇偶校验码</li>
</ol>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数电笔记2017-10-29&quot;&gt;&lt;a href=&quot;#数电笔记2017-10-29&quot; class=&quot;headerlink&quot; title=&quot;数电笔记2017-10-29&quot;&gt;&lt;/a&gt;数电笔记2017-10-29&lt;/h1&gt;&lt;h2 id=&quot;第一章-数字逻辑基础&quot;&gt;&lt;a hr
    
    </summary>
    
      <category term="数字电路" scheme="http://ranxb.cn/categories/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"/>
    
    
      <category term="数字电路" scheme="http://ranxb.cn/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"/>
    
      <category term="笔记" scheme="http://ranxb.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Fragment的应用</title>
    <link href="http://ranxb.cn/2017/10/26/Fragment%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>http://ranxb.cn/2017/10/26/Fragment的应用/</id>
    <published>2017-10-25T16:33:22.000Z</published>
    <updated>2017-10-25T16:37:44.099Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Fragment的应用"><a href="#Fragment的应用" class="headerlink" title="Fragment的应用"></a>Fragment的应用</h1><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ol>
<li>新建一个类，并继承Fragment（android.support.v4.app)</li>
<li>为这个类创建一个布局文件作为fragment</li>
<li>重写onCreatView()方法要求其返回一个view</li>
</ol>
<h2 id="静态加载"><a href="#静态加载" class="headerlink" title="静态加载"></a>静态加载</h2><ol>
<li>建一个active以用来展示静态加载demo</li>
<li>注意：新建的xml文件中需要添加xml布局文件的ID</li>
<li>xml文件中添加一个fragment，其中添加    android:name=”刚刚建的fragment的包名”</li>
<li>预览种可能无法显示fragment，需要添加    tools:layout=”@layout/fragment_test”</li>
<li>在主active中添加按钮并跳转到xml文件定义的fragment_demo中        startActivity(new Intent(this,DemoFragmentActivity.class));</li>
</ol>
<h2 id="动态加载"><a href="#动态加载" class="headerlink" title="动态加载"></a>动态加载</h2><ol>
<li>在刚才的那个xml文件中新建一个framelayout标签（容器布局）以用来存放fragment，并添加ID</li>
<li>添加一个button用来触发动态加载并创建事件addfragment（）；</li>
<li>创建一个fragment管理器        FragmentManager fragmentManager = getSupportFragmentManager();    (如果主类使用继承的是activity的话则获取方法为getFragmentManager();)</li>
<li>创建一个FragmentTransaction开启事务，并用刚才的管理器获取到FragmentTransaction对象        FragmentTransaction transaction = fragmentManager.beginTransaction();</li>
<li>新建一个刚才的fragment类</li>
<li>通过fragmentTransaction事务添加fragment        transaction.add(添加到的容器的ID，添加的fragment对象)；</li>
<li>提交事务方可加载fragment        transition.commit();</li>
</ol>
<p><strong>动态加载的典型代码</strong>  </p>
<pre><code>public void addFragment(View view){
    FragmentManager fragmentManager = getSupportFragmentManager();
    FragmentTransaction transaction = fragmentManager.beginTransaction();
    FragmentDemo fragmentDemo = new FragmentDemo();
    transaction.add(R.id.framelayout，fragmentDemo)；
    transition.commit();
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Fragment的应用&quot;&gt;&lt;a href=&quot;#Fragment的应用&quot; class=&quot;headerlink&quot; title=&quot;Fragment的应用&quot;&gt;&lt;/a&gt;Fragment的应用&lt;/h1&gt;&lt;h2 id=&quot;准备&quot;&gt;&lt;a href=&quot;#准备&quot; class=&quot;head
    
    </summary>
    
      <category term="Android" scheme="http://ranxb.cn/categories/Android/"/>
    
    
      <category term="入门" scheme="http://ranxb.cn/tags/%E5%85%A5%E9%97%A8/"/>
    
      <category term="Android" scheme="http://ranxb.cn/tags/Android/"/>
    
      <category term="Fragment" scheme="http://ranxb.cn/tags/Fragment/"/>
    
  </entry>
  
  <entry>
    <title>我勒个去成都！！！————写在前面</title>
    <link href="http://ranxb.cn/2017/09/29/%E6%88%91%E5%8B%92%E4%B8%AA%E5%8E%BB%E6%88%90%E9%83%BD%EF%BC%81%EF%BC%81%EF%BC%81%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2/"/>
    <id>http://ranxb.cn/2017/09/29/我勒个去成都！！！————写在前面/</id>
    <published>2017-09-28T16:37:22.000Z</published>
    <updated>2017-09-28T16:38:59.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="我勒个去成都！！！————写在前面"><a href="#我勒个去成都！！！————写在前面" class="headerlink" title="我勒个去成都！！！————写在前面"></a>我勒个去成都！！！————写在前面</h1><h2 id="提前的准备"><a href="#提前的准备" class="headerlink" title="提前的准备"></a>提前的准备</h2><blockquote>
<p>一共两个背包一个小提箱；<br>箱子里主要放衣服杂物不常用的东西；<br>背包里面电脑相机卫生纸日常用的还有。。零食？   </p>
</blockquote>
<ol>
<li>身份证</li>
<li>学生证</li>
<li>手机</li>
<li>充电宝</li>
<li>流量</li>
<li>银行卡</li>
<li>各种充电器</li>
<li>电脑可以选择性的带一个🐒</li>
<li>相机（不带脚架）</li>
<li>各种衣服</li>
<li>伞！！！！！！！</li>
</ol>
<h3 id="衣物"><a href="#衣物" class="headerlink" title="衣物"></a>衣物</h3><blockquote>
<p>看天气预报大多是阴天和雨天？？难道是因为比较潮？？  </p>
</blockquote>
<p>30号到成都当晚阴天18度，然后1号到4号之间持续有雨有点蛋疼，56两天继续阴天，7号早上多云但是晚上走的时候继续下雨，8号早上到兰州6、7度，有点冷。。。<br>综合来看的话。。。。不需要太薄的衣服。。。日常衬衫+薄外套<br>全部大概准备三套左右差不多～别穿的太少  </p>
<h3 id="带上伞！！！"><a href="#带上伞！！！" class="headerlink" title="带上伞！！！"></a><strong>带上伞！！！</strong></h3><h2 id="交通"><a href="#交通" class="headerlink" title="交通"></a>交通</h2><h3 id="市区交通"><a href="#市区交通" class="headerlink" title="市区交通"></a>市区交通</h3><p><strong>出租车</strong><br>成都出租车白天(6-23点)起步价8元(速腾2.0和1.4T为9元),包2 公里,后1.9元/公里，10公里到60公里2.85元/公里。<br>夜间(23-6点)起 步价9元(速腾2.0和1.4T为10元),包2公里,后2.2元/公里，10公里到 60公里3.3元/公里。<br>打车后记径索要计秳収票。由亍公交车票价格不便宜，人多时比较合算。</p>
<p><strong>公交车🚌</strong><br>成都市公交网络四通八达，可以到达任何事被近郊的旅游景区、景点。<br>市内公交车分普通车和高档车两种，市区内的车次基本以两元为主以两元为主。</p>
<p><strong>地铁🚇</strong><br>一共两条线，均为分段收费，起步价两元，全程五元。  </p>
<p><strong>火三轮？？</strong><br>我也不知道是干啥的，可以去瞅瞅。起步大概是2～5元。  </p>
<h3 id="其他景区交通"><a href="#其他景区交通" class="headerlink" title="其他景区交通"></a>其他景区交通</h3><blockquote>
<p><strong>成都机场-峨眉山 収车时间:14:00，票价36元</strong><br><strong>成都机场-宜宾 収车时间:14:00，票价95元</strong><br><strong>成都机场-乐山 収车时间:14:00、15:50，票价46元。</strong></p>
</blockquote>
<p><strong>新南门车站(成都市旅游集散中心)</strong><br>位于新南路，成都新南门大桥边。可乘6、28、49、55路到达。<br>发往地区:成都周边，以及川内知名的旅游景区。</p>
<pre><code>TIPS:(我在百度攻略上看的）
什邡、绵竹两个地震遗址专线车已开通，票价98元，
费用包括:去去回程车票、餐费、保险、导游、地震遗址安全维护费。
路线为成都—幸汉—什邡—蓥华—绵竹—汉旺—绵竹—德阳—成都。
上午8:00发车， 晚上6时过卲可返回成都。
</code></pre><h2 id="游览地点汇总"><a href="#游览地点汇总" class="headerlink" title="游览地点汇总"></a>游览地点汇总</h2><h3 id="宽窄巷子"><a href="#宽窄巷子" class="headerlink" title="宽窄巷子"></a>宽窄巷子</h3><p>宽巷子的闲生活，窄巷子的慢生活，井巷子的新生活成为了成都的“上海新天地”触摸历史痕迹，体味成都原滋原味的休闲生活方式，</p>
<blockquote>
<p>门票/开放时间: 全天开放无门票<br>地址: 青羊区同仁路以东长顺街以西<br>交通: 公交车“长顺上街”站下车地铁2号线“人民公园”站下车。</p>
</blockquote>
<pre><code>宽窄巷子旅游最佳时间:
1、清晨: 人很少，拍风景和拍人像都很不错。  
2、下午: 特别是出太阳的下午，来宽窄巷子会很  
挤，很多人在茶馆喝茶，打牌，掏耳朵。这是宽窄  
巷子最成都的一个表现。来一杯盖碗茶，晒一下午  
的太阳。这时候，就不那么适合拍照啦~
3、晚上: 宽窄巷子里有一些酒吧，经常会举办各种各样的party,  
价格和品质都不菲。当然，环保一点的办法是，  
吃过晚饭之后到宽窄巷子散步，很惬意。很悠闲。  
4、如果周末来，在井巷子还能看到创意集市哦~
</code></pre><h3 id="武侯祠"><a href="#武侯祠" class="headerlink" title="武侯祠"></a>武侯祠</h3><p>我也不知道干啥的我就瞎转吧，是个历史遗迹啥的，就不废话了～  </p>
<blockquote>
<p>门票:60元，学生半价。<br>开放时间:夏 7:30-21:00冬 8:00-18:30<br>地址:武侯区武侯祠多街231号<br>交通:公交车在“武侯祠”站下车</p>
</blockquote>
<h3 id="锦里"><a href="#锦里" class="headerlink" title="锦里"></a>锦里</h3><p>这名字吉利，可以多转转。<br>400米长的老街上，传统小吃，饮食，客栈遍巷。感觉能玩两三天，我感觉旅店可以定在这附近。  </p>
<blockquote>
<p>全天开放无门票<br>地址:武侯区武侯祠多街231号<br>交通:同武侯祠</p>
</blockquote>
<h3 id="杜甫草堂"><a href="#杜甫草堂" class="headerlink" title="杜甫草堂"></a>杜甫草堂</h3><h3 id="春熙路"><a href="#春熙路" class="headerlink" title="春熙路"></a><strong>春熙路</strong></h3><h3 id="文殊院"><a href="#文殊院" class="headerlink" title="文殊院"></a>文殊院</h3><h3 id="望江楼"><a href="#望江楼" class="headerlink" title="望江楼"></a>望江楼</h3><h3 id="大熊猫基地"><a href="#大熊猫基地" class="headerlink" title="大熊猫基地"></a>大熊猫基地</h3><h3 id="稻城"><a href="#稻城" class="headerlink" title="稻城"></a>稻城</h3><h3 id="都江堰"><a href="#都江堰" class="headerlink" title="都江堰"></a>都江堰</h3><h3 id="青城山"><a href="#青城山" class="headerlink" title="青城山"></a>青城山</h3><h2 id="好吃的！！！"><a href="#好吃的！！！" class="headerlink" title="好吃的！！！"></a>好吃的！！！</h2><blockquote>
<p><strong>田姗平给的清单全吃一遍！！！</strong></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;我勒个去成都！！！————写在前面&quot;&gt;&lt;a href=&quot;#我勒个去成都！！！————写在前面&quot; class=&quot;headerlink&quot; title=&quot;我勒个去成都！！！————写在前面&quot;&gt;&lt;/a&gt;我勒个去成都！！！————写在前面&lt;/h1&gt;&lt;h2 id=&quot;提前的准备
    
    </summary>
    
      <category term="成都游记" scheme="http://ranxb.cn/categories/%E6%88%90%E9%83%BD%E6%B8%B8%E8%AE%B0/"/>
    
    
      <category term="游记" scheme="http://ranxb.cn/tags/%E6%B8%B8%E8%AE%B0/"/>
    
      <category term="随笔" scheme="http://ranxb.cn/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="成都" scheme="http://ranxb.cn/tags/%E6%88%90%E9%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>在Android中Menu的使用</title>
    <link href="http://ranxb.cn/2017/09/28/%E5%9C%A8Android%E4%B8%ADMenu%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://ranxb.cn/2017/09/28/在Android中Menu的使用/</id>
    <published>2017-09-27T16:58:26.000Z</published>
    <updated>2017-09-27T17:05:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在Android中Menu的使用"><a href="#在Android中Menu的使用" class="headerlink" title="在Android中Menu的使用"></a>在Android中Menu的使用</h1><h2 id="Menu的分类"><a href="#Menu的分类" class="headerlink" title="Menu的分类"></a>Menu的分类</h2><ol>
<li>选项菜单(Options Menu);当用户触发 menu 项时弹出的菜单</li>
<li>上下文菜单(Context Menu):用户长按那个控件时弹出的类似对话框</li>
<li>弹出菜单，当用户点击某个 View 视图是弹出的菜单</li>
</ol>
<h2 id="前提准备"><a href="#前提准备" class="headerlink" title="前提准备"></a>前提准备</h2><ol>
<li>java创建了menu对象</li>
<li>使用XML方法定义Menu要在XML文件中正确填写并添加ID</li>
</ol>
<h2 id="使用XML定义Menu"><a href="#使用XML定义Menu" class="headerlink" title="使用XML定义Menu"></a>使用XML定义Menu</h2><blockquote>
<p>XML文件的基本属性  </p>
</blockquote>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;
    &lt;item
        android:id=&quot;@+id/daxiao&quot;
        android:title=&quot;设置字体大小&quot;
        android:orderInCategory=&quot;3&quot;&gt;
    &lt;/item&gt;
    &lt;item
        android:id=&quot;@+id/yanse&quot;
        android:title=&quot;设置字体颜色&quot;
        android:orderInCategory=&quot;2&quot;
        &gt;
    &lt;/item&gt;
    &lt;item
        android:id=&quot;@+id/shuxing&quot;
        android:title=&quot;设置字体属性&quot;
        android:orderInCategory=&quot;1&quot;&gt;

    &lt;/item&gt;
&lt;/menu&gt;

                &lt;!--
                    android:id=&quot;@+id/lalala_mune&quot;  设置id
                    android:title=&quot;设置字体大小&quot;      设置title
                    android:orderInCategory=&quot;3&quot;     显示顺序
                --&gt;
</code></pre><blockquote>
<p>Menu 菜单的嵌套使用规则  </p>
</blockquote>
<ol>
<li>Item 中可以嵌套 menu，但是不能嵌套 group</li>
<li>Menu 中既可以嵌套 group，又可以嵌套 item。</li>
<li>Group 中只能嵌套 item，不能嵌套 menu</li>
</ol>
<h2 id="选项菜单的添加"><a href="#选项菜单的添加" class="headerlink" title="选项菜单的添加"></a>选项菜单的添加</h2><h3 id="添加XML文件中的Menu"><a href="#添加XML文件中的Menu" class="headerlink" title="添加XML文件中的Menu"></a>添加XML文件中的Menu</h3><blockquote>
<p>选项菜单需要重写在在java代码中重写onCreateOptionsMenu(Menu menu)方法  </p>
</blockquote>
<pre><code>public boolean onCreateOptionsMenu(Menu menu) {
    /*第一步需要加载菜单选项*/
    /*菜单填充器将菜单获取然后添加至active中*/
    /*第一种比较麻烦的方法*/
    /*MenuInflater inflater = getMenuInflater();
    inflater.inflate(R.menu.options_menu,menu);*/
    /*第二种方法*/
    getMenuInflater().inflate(R.menu.options_menu,menu);

    return true;
}
</code></pre><h3 id="在Java代码中动态定义Menu"><a href="#在Java代码中动态定义Menu" class="headerlink" title="在Java代码中动态定义Menu"></a>在Java代码中动态定义Menu</h3><blockquote>
<p>可以在java代码中的onCreateOptionsMenu(Menu menu)方法中使用menu.add()方法动态定义增加Menu</p>
</blockquote>
<pre><code>/*另外可以通过代码添加menu项*/
//menu.add(group id,itmeid  自己设置);里面填menu的分组  group可以是itme的父标签
menu.add(Menu.NONE,ITMEID,Menu.NONE,&quot;lalala我是后设置的&quot;);
</code></pre><h2 id="上下文菜单"><a href="#上下文菜单" class="headerlink" title="上下文菜单"></a>上下文菜单</h2><blockquote>
<p>定义后添加的方法与选项菜单类似<br>当用户长按 Activity 页面时，弹出的菜单我们称为上下文菜单。我们经常在 Windows 中用鼠<br>标右键单击弹出的菜单就是上下文菜单。</p>
</blockquote>
<ol>
<li>覆盖 Activity 的 onCreateContextMenu()方法，调用 Menu 的 add 方法添加菜单项<br>MenuItem</li>
<li>覆盖 onContextItemSelected()方法，响应菜单单击事件</li>
<li>调用 registerForContextMenu()方法，为视图注册上下文菜单</li>
</ol>
<h2 id="子菜单"><a href="#子菜单" class="headerlink" title="子菜单"></a>子菜单</h2><blockquote>
<p>定义后添加的方法与选项菜单类似<br>子菜单就是将相同功能的分组进行多级显示的一种菜单，比如，Windows 的“文件”菜单中就<br>有“新建”，“打开”，“关闭”等子菜单。创建子菜单的方法</p>
</blockquote>
<ol>
<li>覆盖 Activity 的 onCreateOptionsMenu()方法，调用 Menu 的 addSubMenu()方法 添加子菜单项</li>
<li>调用 SubMenu 的 add()饭饭，添加子菜单项</li>
<li>覆盖 onCreateItemSelected()方法，响应菜单单击事件</li>
</ol>
<h2 id="添加单击事件"><a href="#添加单击事件" class="headerlink" title="添加单击事件"></a>添加单击事件</h2><h3 id="选项菜单"><a href="#选项菜单" class="headerlink" title="选项菜单"></a>选项菜单</h3><blockquote>
<p>以下为对于使用XML文件加载的选项菜单为例<br>选项菜单需要重写onOptionsItemSelected(MenuItem item)方法使其触发  </p>
</blockquote>
<pre><code> /**
 * !!只针对选项菜单!!
 * 当选项菜单被选中时调用的方法
 * @param item  表示菜单项对象
 * @return      false表示不进行处理
 */
@Override
public boolean onOptionsItemSelected(MenuItem item) {
    //对于使用XML文件加载的菜单
    int itemid = item.getItemId();//获取触发的item的id
    float a;
    switch (itemid) {
        case R.id.daxiao:
            a =  ceshi.getTextSize();
            Toast.makeText(MainActivity.this,&quot;&quot;+a,Toast.LENGTH_SHORT).show();
            if (a==100) ceshi.setTextSize(TypedValue.COMPLEX_UNIT_PX,50);
                else ceshi.setTextSize(TypedValue.COMPLEX_UNIT_PX,100);
            break;
        case R.id.yanse:
            //随机生成颜色
            int red = (int) (Math.random()*256);
            int green = (int) (Math.random()*256);
            int blue = (int) (Math.random()*256);
            ceshi.setTextColor(Color.rgb(red,green,blue));
            break;
    }
    return super.onOptionsItemSelected(item);
}
</code></pre><h3 id="上下文菜单-1"><a href="#上下文菜单-1" class="headerlink" title="上下文菜单"></a>上下文菜单</h3><p>上下文菜单:上下文菜单是和某一种控件绑定使用的，也就是说每个控件只有注册了上下文菜单，并且长 按时弹出的菜单就是上下文菜单，<br>上下文菜单加载菜单是通过重写 onCreateContextMenu()来完成的，<br>上下文菜单的 点击事件是通过抽重写 onContextItemSelected()方法来实现的</p>
<h3 id="PopMenu"><a href="#PopMenu" class="headerlink" title="PopMenu"></a>PopMenu</h3><p>是通过创建 popMenu 的对象，再通过菜单加载器将其加载进来的， popMenu 的点击事件是通过 popMenu.setOnMenuItemClickListener()方法实现的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;在Android中Menu的使用&quot;&gt;&lt;a href=&quot;#在Android中Menu的使用&quot; class=&quot;headerlink&quot; title=&quot;在Android中Menu的使用&quot;&gt;&lt;/a&gt;在Android中Menu的使用&lt;/h1&gt;&lt;h2 id=&quot;Menu的分类&quot;&gt;
    
    </summary>
    
      <category term="Android" scheme="http://ranxb.cn/categories/Android/"/>
    
    
      <category term="入门" scheme="http://ranxb.cn/tags/%E5%85%A5%E9%97%A8/"/>
    
      <category term="Android" scheme="http://ranxb.cn/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Linux的常用命令（持续更新）</title>
    <link href="http://ranxb.cn/2017/09/08/Linux%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/"/>
    <id>http://ranxb.cn/2017/09/08/Linux的常用命令（持续更新）/</id>
    <published>2017-09-08T03:16:06.000Z</published>
    <updated>2017-09-08T03:30:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux的常用命令行"><a href="#Linux的常用命令行" class="headerlink" title="Linux的常用命令行"></a>Linux的常用命令行</h1><h2 id="基本入门操作"><a href="#基本入门操作" class="headerlink" title="基本入门操作"></a>基本入门操作</h2><pre><code>cd        --更换当前目录或文件夹
rm        --删除文件（删除目录加  -r 控制符）
mkdir        --创建文件夹
rmdir        --删除文件夹（只能是空的）
pwd        --显示当前目录
cp        --复制文件
ls        --显示当前目录下的文件
mvdir        --移动文件夹（可用作重命名操作）
</code></pre><h2 id="网络操作"><a href="#网络操作" class="headerlink" title="网络操作"></a>网络操作</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Linux的常用命令行&quot;&gt;&lt;a href=&quot;#Linux的常用命令行&quot; class=&quot;headerlink&quot; title=&quot;Linux的常用命令行&quot;&gt;&lt;/a&gt;Linux的常用命令行&lt;/h1&gt;&lt;h2 id=&quot;基本入门操作&quot;&gt;&lt;a href=&quot;#基本入门操作&quot; cla
    
    </summary>
    
      <category term="Linux" scheme="http://ranxb.cn/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://ranxb.cn/tags/Linux/"/>
    
      <category term="入门" scheme="http://ranxb.cn/tags/%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>近期的一些更新计划</title>
    <link href="http://ranxb.cn/2017/09/05/%E8%BF%91%E6%9C%9F%E7%9A%84%E4%B8%80%E4%BA%9B%E6%9B%B4%E6%96%B0%E8%AE%A1%E5%88%92/"/>
    <id>http://ranxb.cn/2017/09/05/近期的一些更新计划/</id>
    <published>2017-09-05T01:17:45.000Z</published>
    <updated>2017-09-08T03:31:04.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="近期的一些更新计划"><a href="#近期的一些更新计划" class="headerlink" title="近期的一些更新计划"></a>近期的一些更新计划</h1><blockquote>
<p>刚接触Blog没多久所以想写的东西有点多，但是这玩意吧~他得用MarkDown语法写，挺别扭的，我还得学一学，所以先列一下自己最近想要写的一些东西（可能刚开始都是比较基础的，但是还是主要做给自己看，相当于笔记的东西吧，但是因为在公网上，还是认认真真写比较好）。</p>
</blockquote>
<p><strong>MarkDown的一些基本语法<br>Linux的一些命令操作（持续更新）<br>常用的默认网络端口号<br>Linux布置http环境<br>个人Blog——Hexo在GitHub上的配置</strong></p>
]]></content>
    
    <summary type="html">
    
      刚刚建了Blog的一些计划
    
    </summary>
    
      <category term="随笔" scheme="http://ranxb.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://ranxb.cn/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
