<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ran Xuebin&#39;s Blog</title>
  <subtitle>永远相信美好的事情即将发生</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ranxb.cn/"/>
  <updated>2018-02-14T04:19:48.296Z</updated>
  <id>http://ranxb.cn/</id>
  
  <author>
    <name>冉学斌</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>无显示器条件下查询树莓派IP的方法</title>
    <link href="http://ranxb.cn/2018/02/14/%E6%97%A0%E6%98%BE%E7%A4%BA%E5%99%A8%E6%9D%A1%E4%BB%B6%E4%B8%8B%E6%9F%A5%E8%AF%A2%E6%A0%91%E8%8E%93%E6%B4%BEIP%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://ranxb.cn/2018/02/14/无显示器条件下查询树莓派IP的方法/</id>
    <published>2018-02-14T04:18:09.000Z</published>
    <updated>2018-02-14T04:19:48.296Z</updated>
    
    <content type="html"><![CDATA[<h1 id="无显示器条件下查询树莓派IP的方法"><a href="#无显示器条件下查询树莓派IP的方法" class="headerlink" title="无显示器条件下查询树莓派IP的方法"></a>无显示器条件下查询树莓派IP的方法</h1><blockquote>
<p>方法都根据树莓派的网卡物理地址为<code>b8:27:eb:</code>开头    。因此有以下自动化方法</p>
</blockquote>
<h2 id="Mac下打开网络实用工具"><a href="#Mac下打开网络实用工具" class="headerlink" title="Mac下打开网络实用工具"></a>Mac下打开网络实用工具</h2><p>直接查询Netstat下的路由表找到树莓派的物理地址对应的就是树莓派的IP地址。</p>
<h2 id="Shell脚本"><a href="#Shell脚本" class="headerlink" title="Shell脚本"></a>Shell脚本</h2><blockquote>
<p>整个代码逻辑为依次pingIP地址，之后通过arp映射找到对应的物理地址，取到对应的IP。</p>
</blockquote>
<p>代码如下</p>
<pre><code>clear


echo &quot;程序运行中...&quot;
ipLine=&quot;`ifconfig | grep &quot;inet 192.168&quot; `&quot;
preIp=${ipLine:5:11}
echo &quot;程序默认将在$preIp 2 - $preIp 255范围内进行扫描&quot;
echo &quot;但这将花费较多时间，请问是否进行手动设置？（y/n)&quot;
read choice
if test $choice = &quot;y&quot;
    then
        echo -n &quot;请输入起始位置(2-255):&quot;
        read i
        echo -n &quot;请输入结束位置($i-255):&quot;
        read j
        echo &quot;下面将对 $i 到 $j 范围进行扫描&quot;
    else
        i=2
        j=255
        echo &quot;下面将直接对2-255整个范围进行扫描&quot;
fi
while test $i -ne $j
do
    echo &quot;正在检测ip的连接情况，请耐心等待&quot;
    ip=$preIp$i
    echo &quot;正在ping端口$ip ...&quot;
    &quot;`ping -t 1 -q $ip `&quot;
    let i=i+1
    clear
done
clear
echo &quot;所有ip检测完毕，正在计算结果...&quot;
result=&quot;`arp -a | grep &quot;b8:27:eb:&quot; ` &quot;
resultIp=${result:3:14}
resultMac=${result:19:17}
clear
echo &quot;已经得到结果：&quot;
echo &quot;您的树莓派Mac地址为:$resultMac&quot;
echo &quot;    当前连接的IP为:$resultIp&quot;
echo
echo &quot;程序结束&quot;
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;无显示器条件下查询树莓派IP的方法&quot;&gt;&lt;a href=&quot;#无显示器条件下查询树莓派IP的方法&quot; class=&quot;headerlink&quot; title=&quot;无显示器条件下查询树莓派IP的方法&quot;&gt;&lt;/a&gt;无显示器条件下查询树莓派IP的方法&lt;/h1&gt;&lt;blockquote&gt;

    
    </summary>
    
      <category term="树莓派" scheme="http://ranxb.cn/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
    
      <category term="树莓派" scheme="http://ranxb.cn/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
      <category term="Unix" scheme="http://ranxb.cn/tags/Unix/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu上启动ftp服务</title>
    <link href="http://ranxb.cn/2018/02/07/Ubuntu%E4%B8%8A%E5%90%AF%E5%8A%A8ftp%E6%9C%8D%E5%8A%A1/"/>
    <id>http://ranxb.cn/2018/02/07/Ubuntu上启动ftp服务/</id>
    <published>2018-02-07T13:13:49.000Z</published>
    <updated>2018-02-07T13:16:20.832Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ubuntu上启动ftp服务"><a href="#Ubuntu上启动ftp服务" class="headerlink" title="Ubuntu上启动ftp服务"></a>Ubuntu上启动ftp服务</h1><h2 id="安装并启动VSFTPD"><a href="#安装并启动VSFTPD" class="headerlink" title="安装并启动VSFTPD"></a>安装并启动VSFTPD</h2><ul>
<li>安装VSFTPD<br><code>sudo apt-get install vsftpd -y</code></li>
<li>启动VSFTPD(会自动启动若未启动)<br><code>sudo systemctl start vsftpd.service</code></li>
<li>检测端口，判断是否启动。<br><code>sudo netstat -nltp | grep</code> </li>
</ul>
<h2 id="配置用户访问目录"><a href="#配置用户访问目录" class="headerlink" title="配置用户访问目录"></a>配置用户访问目录</h2><ul>
<li>新建主目录</li>
<li>新建用户并设置密码<br><code>sudo useradd -d /home/uftp -s /bin/bash uftp</code><br><code>sudo passwd uftp</code><br><code>sudo rm /etc/pam.d/vsftpd</code>(这里删除该配置文件，因为会导致使用用户名登录FTP失败)</li>
<li>限制用户只能通过FTP访问<br><code>sudo usermod -s /sbin/nologin uftp</code></li>
<li><p>修改VSFTPD配置<br><code>sudo chmod a+w /etc/vsftpd.conf</code><br>下面修改<code>/etc/vsftpd.conf</code>文件中的配置（添加到最下面）</p>
<pre><code># 限制用户对主目录以外目录访问
chroot_local_user=YES

# 指定一个 userlist 存放允许访问 ftp 的用户列表
userlist_deny=NO
userlist_enable=YES

# 记录允许访问 ftp 用户列表
userlist_file=/etc/vsftpd.user_list

# 不配置可能导致莫名的530问题
seccomp_sandbox=NO

# 允许文件上传
write_enable=YES

# 使用utf8编码
utf8_filesystem=YES
</code></pre><p>新建文件<code>/etc/vsftpd.user_list</code>用于存放允许访问FTP的用户<br><code>sudo touch /etc/vsftpd.user_list</code><br><code>sudo chmod a+w /etc/vsftpd.user_list</code><br>并修改，加入刚刚创建的用户</p>
</li>
<li><p>设置访问限权<br>设置主目录访问权限（只读）：<code>sudo chmod a-w /home/uftp</code><br>设置公共目录，设置可读写：<code>sudo mkdir /home/uftp/public &amp;&amp; sudo chmod 777 -R /home/uftp/public</code><br>重启VSFTPD服务：<code>sudo systemctl restart vsftpd.service</code></p>
</li>
</ul>
<h2 id="完"><a href="#完" class="headerlink" title="完"></a>完</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Ubuntu上启动ftp服务&quot;&gt;&lt;a href=&quot;#Ubuntu上启动ftp服务&quot; class=&quot;headerlink&quot; title=&quot;Ubuntu上启动ftp服务&quot;&gt;&lt;/a&gt;Ubuntu上启动ftp服务&lt;/h1&gt;&lt;h2 id=&quot;安装并启动VSFTPD&quot;&gt;&lt;a h
    
    </summary>
    
      <category term="Linux" scheme="http://ranxb.cn/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://ranxb.cn/tags/Linux/"/>
    
      <category term="FTP" scheme="http://ranxb.cn/tags/FTP/"/>
    
  </entry>
  
  <entry>
    <title>Linux的用户及用户组</title>
    <link href="http://ranxb.cn/2018/02/07/Linux%E7%9A%84%E7%94%A8%E6%88%B7%E5%8F%8A%E7%94%A8%E6%88%B7%E7%BB%84/"/>
    <id>http://ranxb.cn/2018/02/07/Linux的用户及用户组/</id>
    <published>2018-02-07T13:12:41.000Z</published>
    <updated>2018-02-07T13:18:16.931Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux的用户及用户组"><a href="#Linux的用户及用户组" class="headerlink" title="Linux的用户及用户组"></a>Linux的用户及用户组</h1><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><ul>
<li><code>/etc/group</code>  组信息配置文件</li>
<li><code>/etc/passwd</code> 用户信息配置文件</li>
<li><code>/etc/shadow</code> 用户密码配置文件</li>
<li><code>/etc/gshadow</code> 组密码配置文件</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="a.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>   
<p><img src="b.jpg" alt=""></p>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="组操作"><a href="#组操作" class="headerlink" title="组操作"></a>组操作</h3><p><code>groupadd NEWGROUP</code>添加一个组<br><code>groupadd -g 888 NEWGROUP</code>添加一个组并指定UID<br><code>grouddel NEWGROUP</code>删除一个组。<br><code>groupmod -n NEWGROUP OLDGROUP</code>更改组名<br><code>groupmod -g 888 NEWGROUP</code>更改组UID</p>
<h3 id="用户操作"><a href="#用户操作" class="headerlink" title="用户操作"></a>用户操作</h3><p><code>useradd -g GROUP USER</code>添加一个指定用户组的用户<br><code>useradd -d /home/xxx USER</code>添加一个指定目录的的用户<br><code>userdel USER</code>删除一个用户<br><code>userdel -r USER</code>同时删除用户主目录<br><code>usermod -l NEWNAME USER</code>更改用户名<br><code>usermod -c BEIZHU USER</code>加备注<br><code>usermod -d /home/yyy UESR</code>改用户主目录<br><code>usermod -g GROUP USER</code>改组</p>
<blockquote>
<p>在<code>/etc/</code>下创建<code>nologin</code>文件其他用户均不能登录</p>
</blockquote>
<h2 id="进阶操作"><a href="#进阶操作" class="headerlink" title="进阶操作"></a>进阶操作</h2><h3 id="组"><a href="#组" class="headerlink" title="组"></a>组</h3><blockquote>
<p>主要组和附属组</p>
</blockquote>
<p><code>gpasswd -a USER GROUP,GROUP2</code>添加附属组<br><code>newgrp GROUP</code>切换用户组,此时可能需要组密码<br><code>gpasswd -d USER GROUP</code>删除附属组<br><code>useradd -g 主要组 -G 附属组，附属组 USER</code>新建时指定用户组<br><code>gpasswd GROUP</code>修改组密码</p>
<h3 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h3><p><code>passwd -l USER</code>锁定账户<br><code>passwd -u USER</code>解锁账户<br><code>passwd -d USER</code>清除密码</p>
<h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><p><code>su USER</code> 切换账户</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Linux的用户及用户组&quot;&gt;&lt;a href=&quot;#Linux的用户及用户组&quot; class=&quot;headerlink&quot; title=&quot;Linux的用户及用户组&quot;&gt;&lt;/a&gt;Linux的用户及用户组&lt;/h1&gt;&lt;h2 id=&quot;配置文件&quot;&gt;&lt;a href=&quot;#配置文件&quot; cla
    
    </summary>
    
      <category term="Linux" scheme="http://ranxb.cn/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://ranxb.cn/tags/Linux/"/>
    
      <category term="用户" scheme="http://ranxb.cn/tags/%E7%94%A8%E6%88%B7/"/>
    
  </entry>
  
  <entry>
    <title>数据结构知识框架</title>
    <link href="http://ranxb.cn/2018/01/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6/"/>
    <id>http://ranxb.cn/2018/01/11/数据结构知识框架/</id>
    <published>2018-01-11T01:16:54.000Z</published>
    <updated>2018-01-11T16:03:53.277Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构知识框架"><a href="#数据结构知识框架" class="headerlink" title="数据结构知识框架"></a>数据结构知识框架</h1><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><p>第一方面：基本概念<br>1、数据结构研究方面（研究内容）<br>主要体现三个方面：</p>
<ul>
<li>数据的逻辑关系</li>
<li>储存关系</li>
<li>运算关系</li>
<li>还讨论算法的效率问题，分类问题等。 </li>
</ul>
<p>2、数据结构的逻辑结构<br><strong>逻辑关系</strong>：自然状态下数据元素之间的一种联系（关联方式或邻接关系，从逻辑上观察数据，与计算机无关）。<br><strong>逻辑结构</strong>：对数据元素之间关系的描述B=(k，r)其中，k：数据元素的有穷集合（有限元素构成），r：k上关系的有穷集合，其中每个关系r都是从k到k的关系。<br><strong>逻辑结构的分类</strong>：线性结构和非线性结构（树形结构、图形结构（网状结构））。<br><strong>关于集合类型</strong>：元素之间除同属一个集合外别无其他类型<br>3、数据结构的<strong>存储结构</strong><br><strong>存储关系</strong>：逻辑结构在计算机存储器中实现，它依赖于计算机。具体说数据在存储器中的关联方式，也成物理结构，物理关系等。 </p>
<ul>
<li>顺序结构  </li>
<li>链接结构  </li>
<li>索引结构  </li>
<li>散列（hash）结构 </li>
</ul>
<p>4、数据结构评价标准<br>主要标准： </p>
<ul>
<li>作为问题的参数的函数来计算<strong>存储需要量</strong>  </li>
<li>作为问题的参数的函数来计算<strong>时间效率</strong>  </li>
<li>还需要考虑其他因素  </li>
</ul>
<h2 id="第二章：算法（只有一个层面）"><a href="#第二章：算法（只有一个层面）" class="headerlink" title="第二章：算法（只有一个层面）"></a>第二章：算法（只有一个层面）</h2><p>1、算法的评价标准<br>好算法要达到以下目标：  </p>
<ul>
<li>正确性（满足具体问题的要求）  </li>
<li>易读性（交流与他人阅读，其次是机器执行）  </li>
<li>高效性（效率与存储量的需求，达到所需的时空性能）  </li>
<li>健壮性（适应环境变化，有非法输入时，能做出相应的处理或反映）  </li>
</ul>
<p>2、算法的描述方法  </p>
<ul>
<li>计算机程序设计语言  </li>
<li>自然语言  </li>
<li>PDL语言（伪码语言、可运行于“抽象计算机”，虚拟机）  </li>
<li>流程图  </li>
</ul>
<h2 id="第三章：线性表（只有第三个要求）"><a href="#第三章：线性表（只有第三个要求）" class="headerlink" title="第三章：线性表（只有第三个要求）"></a>第三章：线性表（只有第三个要求）</h2><p>1、<strong>线性表</strong>：一个线性表是n≥0个数据元素a1，a2，……，an的有限序列，序列中除第一个最后一个以外，每个元素都是有且仅有一个直接前驱和直接后继。<br>2、<strong>链表</strong>：通过指针联系起来的结点的整体（集合）。<br>3、<strong>静态链表</strong>：以整形变量的值作为存储连接指针值（即地址）联系起来的结点的整体。（指针本质整形值）<br>4、<strong>表头结点</strong>：增加一个附加结点，放置于链表的最前面，也称表头结点，且该节点不用存储数据元素。作用和目的（简化算法）。<br>5、<strong>存储密度</strong>：结点数据本身所占的存储量和整个结点结构所占的存储量之比。<br>存储密度 = （结点数据本身所占的存储量）/（结点结构所占的存储总量）  </p>
<pre><code>基于链表的插入删除 
</code></pre><h2 id="第四章：栈和队列（只有第三层）"><a href="#第四章：栈和队列（只有第三层）" class="headerlink" title="第四章：栈和队列（只有第三层）"></a>第四章：栈和队列（只有第三层）</h2><p>1、<strong>栈</strong>：栈在计算机具体应用中，是一个特定的存储区，一端固定，一端浮动。<br>栈是一个下限为常数，上限可变化的（或者反之），也成为堆栈或堆阵。可变化一端为栈顶，不可变化一端为栈底<br>2、<strong>栈与线性表的异同</strong>：栈的插入、删除至能在一端进行，不能在任意点，栈是受限的线性表。<br>3、<strong>队列</strong>：队列是一个上限和下限只能增加和不能减少的向量（或反之），队首：取出元素的一端。队尾：加入元素的一端。<br>4、<strong>队列与线性表的异同</strong>：受限的线性表，删除和插入操作只能在特定位置。<br>5、<strong>假溢出（待定）</strong>：多栈共存时，有点栈已满，有的还没有满。存储区还没有满,但队列或栈却发生了溢出,我们把这种现象称为”假溢出”。  </p>
<blockquote>
<p>第三层次：循环队列的出入队。</p>
</blockquote>
<pre><code>循环队列的出入队 (注意！队首指向队头元素的前一个地址，队尾指向队屁股最后一个元素)
入队： 
PROC REDUI(VAR CQ: ARRAY[M..N]OF DATATYPE;FRONT,REAR,X:INTERG) 
BEGIN 
    REAR&lt;-REAR+1
    IF REAR=N+1
        THEN REAR&lt;-M
    IF REAR=FRONT
        THEN PRINT&quot;CQ FULL&quot;&quot;
        ELSE CQ[REAR]&lt;-X
END
出队：
PROC CHUDUI(VAR CQ:ARRAY[M...N]OF DATATYPE;FRONT,REAR,X:INTEGER)
BEGIN
    IF    FRONT=REAR
        THEN    PRINT&quot;CQ EMPTY&quot;
        ELSE    IF    FRONT = N
                    THEN FRONT = M
                    ELSE FRONT &lt;- FRONT+1
                X &lt;- CQ[FRONT]
END
</code></pre><h2 id="第五章：串（只有第一层面）"><a href="#第五章：串（只有第一层面）" class="headerlink" title="第五章：串（只有第一层面）"></a>第五章：串（只有第一层面）</h2><p>1、<strong>串</strong>：一个由零个或多个字符组成的有穷序列称为串，简记A=a1a2……an。<br>2、<strong>串的模式匹配</strong>：假设有两个串P和S：<br>P=p1p2……pm    S=s1s2……sn 其中（0＜m＜n）通常m&lt;&lt;n<br>在S中找出一个与P相同的子串，即串的定位。<br>通常把S称为目标，把P称为模式，把从目标S中查找模式P的过程称为串的模式匹配。  </p>
<h2 id="第六章：数组和广义表（二）"><a href="#第六章：数组和广义表（二）" class="headerlink" title="第六章：数组和广义表（二）"></a>第六章：数组和广义表（二）</h2><p>1、<strong>数组</strong>：一位数组是个向量，他的每个元素是该结构中不可分割的最小单位；n(n&gt;1)维数组是个向量，他的每个元素是n-1维数组，且具有相同的下限和上限。<br>2、<strong>稀疏数组</strong>：在一个数组中和某一元素比较而言，不相同的元素很少时，我们称此数组为稀疏数组。<br>3、<strong>稀疏矩阵</strong>：是稀疏数组的典例。与稀疏矩阵的差别：元素分布是否有规律。<br>4、<strong>广义表</strong>：广义表是零个或多个原子（他是所要描述的某种数据类型的对象，是一个确定的概念）或子表所构成的有限序列，简称表。</p>
<blockquote>
<p>第二层次<br>稀疏矩阵的两个存储方法：三元组（顺序存储）、十字链表</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="a.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>  
<p>三元组的缺陷</p>
<ul>
<li>不利于矩阵元素的变化：非零到零的删除、零到非零的添加</li>
</ul>
<h2 id="第七章：树形结构（二、三）"><a href="#第七章：树形结构（二、三）" class="headerlink" title="第七章：树形结构（二、三）"></a>第七章：树形结构（二、三）</h2><p>1、<strong>树</strong>：是满足以下性质的有限个结点组成的非空集合  </p>
<ul>
<li>T中有且只有一个称为根的结点。  </li>
<li>除根节点以外，其余节点分为m(m&gt;0)个不相交的集合T1，T2……Tm，其中每个Ti都是数，而却都称为T的子树。  </li>
</ul>
<p>2、<strong>二叉树</strong>：二叉树T是满足如下性质的结点的有限集合： </p>
<ul>
<li>T是空集。 </li>
<li>或者它包含一个根节点且其余结点分为两个不相交的集合，并分别被称为左子树和右子树，且左右子树都为二叉树。  </li>
</ul>
<p>3、<strong>遍历</strong>：对于给定数据结构，系统的访问该结构中的每个结点，且每个结点仅被访问一次的操作过程成为遍历。（会改字）<br>4、<strong>二叉树的遍历规则</strong>：  </p>
<ul>
<li>层次遍历：从上到下从左到右，布拉布拉布拉～</li>
<li>深度策略：先根遍历、中根遍历、后根遍历。 </li>
</ul>
<p>5、<strong>二叉排序树</strong>：二叉排序树或空二叉树，或者是满足以下要求的二叉树。</p>
<ul>
<li>若是它的左子树非空，或者左子树上所有结点的值均小于等于根节点的值。  </li>
<li>若它右子树非空，则右子树上所有结点的值均大于等于根节点的值。  </li>
<li>且左右子树都为二叉排序树。  </li>
</ul>
<p>6、<strong>线索</strong>：将二叉树的空指针利用起来，用于表示某线性关系下前驱或后即的，这种指针称为线索。<br>7、<strong>线索树</strong>：带线索的二叉树简称为线索树。  </p>
<p>8、<strong>霍夫曼树（最优二叉树）</strong>：按霍夫曼算法构造具有最小加权路径长度的二叉树。<br>9、<strong>线索化</strong>：给二叉树加线索的过程。  </p>
<blockquote>
<p>第二层次：  </p>
<ul>
<li>树、森林、二叉树相互转换  </li>
<li>二叉树的前中后遍历的方法  </li>
<li>二叉树加线索  </li>
<li>霍夫曼树的构造和编码  </li>
<li>二叉排序树的构造  </li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">二叉树的先序遍历</div><div class="line">PROC XIANXUBIANLI (VAR T:BINARY TREE)</div><div class="line">BEGIN</div><div class="line">	IF T!=NULL</div><div class="line">		THEN	[PRINT&quot;T-&gt;DATA&quot;</div><div class="line">				CALL XIANXUBIANLI(T-&gt;LSON)</div><div class="line">				CALL XIANXUBIANLI(T-&gt;RSON)]</div><div class="line">END</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">二叉树的中序遍历</div><div class="line">PROC XIANXUBIANLI (VAR T:BINARY TREE)</div><div class="line">BEGIN</div><div class="line">	IF T!=NULL</div><div class="line">		THEN	[CALL XIANXUBIANLI(T-&gt;LSON)</div><div class="line">				PRINT&quot;T-&gt;DATA&quot;</div><div class="line">				CALL XIANXUBIANLI(T-&gt;RSON)]</div><div class="line">				</div><div class="line">END</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">二叉树的后序遍历</div><div class="line">PROC XIANXUBIANLI (VAR T:BINARY TREE)</div><div class="line">BEGIN</div><div class="line">	IF T!=NULL</div><div class="line">		THEN	[CALL XIANXUBIANLI(T-&gt;LSON)</div><div class="line">				CALL XIANXUBIANLI(T-&gt;RSON)</div><div class="line">				PRINT&quot;T-&gt;DATA&quot;]</div><div class="line">END</div></pre></td></tr></table></figure>
<p><strong>树到二叉树的转换：</strong>  </p>
<ul>
<li>加线：加横线</li>
<li>抹线：抹掉可以抹掉的所有右孩子之间的线<br><img src="b.png" alt=""></li>
</ul>
<p><strong>二叉树转到树：</strong>  </p>
<ul>
<li>加线：1.是父节点的左孩子。2.把父节点和他的右孩子和右孩子的右孩子和。。。连起来。</li>
<li>抹线：抹去所有节点和右孩子之间的线<br><img src="c.png" alt="">    </li>
</ul>
<p><strong>森林转化为二叉树</strong></p>
<ul>
<li>把每个树转化为二叉树</li>
<li>二叉树的连接：依据森林次序，后一棵二叉树是前一棵二叉树根节点的右子树<br><img src="d.png" alt=""></li>
</ul>
<p><strong>二叉树转换成森林</strong></p>
<ul>
<li>抹线：把节点的右子树都拿出来</li>
<li>还原：把每个二叉树变成树<br><img src="e.png" alt=""></li>
</ul>
<p><strong>线索化</strong></p>
<ul>
<li>左孩子指向直接前驱</li>
<li>右孩子指向直接后驱</li>
<li>标志位0表示指向孩子，1表示指向线索</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="f.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p><strong>构造二叉树</strong></p>
<ol>
<li>节点是否为空，为空则插入</li>
<li>若小于，执行递归插入左孩子节点，到1.</li>
<li>若大于，执行递归插入右孩子节点，到1.</li>
</ol>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="g.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p><strong>霍夫曼树（最优二叉树）</strong>  </p>
<ul>
<li>给定一组权值集合{w1, w2, …, wn}.</li>
<li>将F={T1, T2, …, Tn}按根结点的值由小到大进行排序。</li>
<li>取出T1和T2组成一棵二叉树T；再将T插入到F中，并使F依据根结点的值有序。</li>
<li>反复执行③直到F={T}为止。</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="h.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p><strong>霍夫曼树的编码</strong></p>
<ul>
<li>给定字符集</li>
<li>写出每个字符出现的次数组成的集合。</li>
<li>对此集合进行霍夫曼排序</li>
<li>左支为0右支为1写出每个字符的编码</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="i.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<blockquote>
<p>第三个层次：遍历方法，两个运用一个处理 </p>
</blockquote>
<p>交换左右子树</p>
<pre><code>PROC EXCHANGE(VAR T:BINARYTREE)
BEGIN 
    IF T!=NULL
            THEN    [SWOP(T-&gt;LSON,T-&gt;RSON)
                    CALL EXCHANGE(T-&gt;LSON)
                    CALL EXCHANGE(T-&gt;RSON)]
END
</code></pre><p>求二叉树的高度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">PROC HIGHT(VAR T:BINARYTREE,H)</div><div class="line">BEGIN </div><div class="line">	IF T=NULL</div><div class="line">			THEN	H&lt;-0</div><div class="line">			ELSE	[CALL HIGHT(T-&gt;LSON,H1)</div><div class="line">					CALL HIGHT(T-&gt;RSON,H2)</div><div class="line">					H&lt;-MAX(H1,H2)+1]</div><div class="line">END</div><div class="line">```	 </div><div class="line">叶子结点的个数</div><div class="line"></div><div class="line">```PDL</div><div class="line">PROC COUNTLEAF(VAR T:BINARYTREE;COUNT:INTGER)</div><div class="line">BIGIN</div><div class="line">	CASE	</div><div class="line">			T=NULL:	COUNT&lt;-0</div><div class="line">			T-&gt;LSON=NULL AND T-&gt;RSON=NULL:  COUNT&lt;-1</div><div class="line">			ELSE	[CALL COUNTLEAF(T-&gt;LSON,C1)</div><div class="line">					CALL COUNTLEAF(T-&gt;RSON,C2)</div><div class="line">					COUNT&lt;-C1+C2]</div><div class="line">	END CASE</div><div class="line">END</div></pre></td></tr></table></figure>
<h2 id="第八章：图结构（二）"><a href="#第八章：图结构（二）" class="headerlink" title="第八章：图结构（二）"></a>第八章：图结构（二）</h2><p>1、<strong>图</strong>：由n(n≥1)个结点v1，v2，……，vn构成的数据G称为图。若结点集V=｛v1、v2……vn｝上定义的称为后继的关系E是非自反的，可表示为G=（V，E），其中V为顶点集，E为边集。<br>2、<strong>图的遍历</strong>：给出图G和其中的任意一个定点v0，从v0出发系统的访问G中所有的定点，且每个顶点（反）被访问一次，这一过程称为图的遍历。<br>3、<strong>图的遍历规律</strong>：广度优先遍历，深度优先遍历。<br>4、<strong>最小生成树</strong>：一个有 n 个结点的连通图的生成树是原图的极小连通子图，且包含原图中的所有 n 个结点，并且有保持图连通的最少的边和权重。<br>5、<strong>AOV网</strong>：若有向图G中，顶点表示活动或任务，有向边表示活动或任务之间的优先关系，则此有向图称为顶点表示活动网络（AOV网）。<br>6、<strong>AOE网</strong>：若在带权的有有向图中的顶点表示事件，有向边表示活动，权表示活动持续的时间，则此有向图称为边表示活动的网络(AOE网)。<br>7、<strong>拓扑排序</strong>：对于有向图G=(V,E)，V中的顶点的线性序列(Vi1,Vi2,……,Vin)，称作一个拓扑序列，若此结点序列满足如下条件；在G中从顶点u到顶点v有一条路径，则在序列中u必在v之前。寻找拓扑序列的有效手段就是进行拓扑排序。<br>8、<strong>关键路径</strong>：任务计划作业图上的需要时间最长的路径（可有多条），它决定完成总任务的时间。  </p>
<blockquote>
<p>第二个层次</p>
<ul>
<li>图的邻接表和邻接矩阵的存储方法  </li>
<li>图的深度和广度遍历的方法  </li>
<li>Prim和Kruskal算法  </li>
</ul>
</blockquote>
<p><strong>邻接表和邻接矩阵的表示</strong><br>有向图中邻接表的表示：<br><img src="j.png" alt=""><br>网的邻接矩阵：<br><img src="k.png" alt=""><br><strong>深度优先搜索</strong><br><img src="l.png" alt=""><br><strong>广度优先搜索</strong><br><img src="m.png" alt="">  </p>
<p><strong>prim算法构造最小生成树</strong><br>每一步都找已连通的树中权最小的边用来构造<br><img src="n.png" alt=""></p>
<p><strong>Kruskal算法构造最小生成树</strong><br>按照权值递增的顺序逐个考虑E中的每条边：<br><img src="o.png" alt=""></p>
<h2 id="第九章：排序（二、三）"><a href="#第九章：排序（二、三）" class="headerlink" title="第九章：排序（二、三）"></a>第九章：排序（二、三）</h2><p>1、<strong>排序</strong>：设含有n个记录的集合为R=｛r1，r2，……，rn｝，其对应的关键字集合为k=｛k1，k2，……，kn｝，给定关系α，按照关系α针对关键字集合k对R进行运算，是的R有如下序列：<br>（rα1，rα2，……，rαn）<br>我们将这个操作过程称为排序。<br>2、<strong>排序分类</strong>：分为外部排序和内部排序。<br>内部排序包括  </p>
<ul>
<li>插入排序  </li>
<li>交换排序  </li>
<li>选择排序  </li>
<li>合并排序  </li>
<li>枚举排序  </li>
<li>分配排序  </li>
</ul>
<p>3、<strong>排序稳定性</strong>：在排序关系下，假设排序前ri在rj之前，排序之后领先关系不变，则称此排序过程方法是稳定的，否则是不稳定的。<br>4、<strong>堆</strong>：设L是长度n的表，其数据元素满足：<br>L(i)≤L(2i)且L(i)≤L(2i+1), 1≤i≤[n/2] 或反之。<br>则称L是一个堆。  </p>
<blockquote>
<p>第二个层次  </p>
<ul>
<li>直接插入  </li>
<li>快速排序  </li>
<li>二路归并  </li>
<li>基数  </li>
<li>堆的构造  </li>
</ul>
</blockquote>
<p><strong>直接插入</strong><br>从一个零集合开始，将 r 按照排序关系插入到一个已经有序的文件适当位置。<br><img src="p.png" alt=""></p>
<p><strong>快速排序</strong><br>基本方法：</p>
<pre><code>PROC QuickSort(VAR R:ARRAY[1..n] OF datatype;l,p:integer);
BEGIN 
        IF l≥p THEN exit ;
     i←l;  j←p; x←R[i];
   REPEAT  
       WHILE (x.key≤R[j].key)AND(i＜j) DO j←j-1;  
       IF  i＜j  
           THEN 【 R[i]←R[j]; i←i+1;
                 WHILE (R[i].key＜x.key)AND(i＜j) DO i←i+1;  
                 IF  i＜j  THEN【 R[j]←R[i];    j←j-1; 】
                】
   UNTIL    i=j;  
   R[i]←x; i←i+1; j←j-1; 
   IF  l＜j THEN CALL QuickSort(R, l , j); 
   IF  i＜p THEN CALL QuickSort(R, i , p);
END; 
</code></pre><p><strong>二路插入</strong><br>两个两个合并，然后四个四个合并，然后大的合并<br><strong>堆的构造</strong><br>1.先插入，然后往上爬。<br><img src="q.png" alt=""><br>2.先排列，然后从第一半个节点开始往上爬。<br><img src="y.png" alt=""><br><strong>基数排序</strong><br>看最低位，一次装进是个桶里，然后拿出来。<br>再装第二位，最后装第三位。<br><img src="r.png" alt=""></p>
<blockquote>
<p>第三个层次：二分插入排序</p>
</blockquote>
<p>与直接插入排序的区别：在插入第i个时搜索采用二分策略。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">PROC DUOSORT(VAR R:ARRAY[1..N])</div><div class="line">BIGIN</div><div class="line">	FOR I&lt;-2 TODO N DO[</div><div class="line">		X&lt;-R[I],L &lt;- 1,H &lt;- I</div><div class="line">		WHILE L&lt;=H DO[</div><div class="line">			M&lt;-(L+H)DIV2</div><div class="line">			IF	X&lt;A[M]</div><div class="line">				THEN H&lt;-(M-1)</div><div class="line">				ELSE L&lt;-(L+1)</div><div class="line">		]</div><div class="line">		FOR J&lt;-(I-1) TODO L DO R[J+1] &lt;- R[J]</div><div class="line">		R[L] &lt;- X </div><div class="line">	]</div><div class="line">END</div></pre></td></tr></table></figure>
<h2 id="第十章：数据检索（二、三）"><a href="#第十章：数据检索（二、三）" class="headerlink" title="第十章：数据检索（二、三）"></a>第十章：数据检索（二、三）</h2><p>1、<strong>检索</strong>：在给定数据结构中查找满足某种条件的数据元素（或节点，记录）的过程。<br>2、<strong>检索分类</strong>：  </p>
<ul>
<li>基于关键字的检索；  </li>
<li>基于属性的检索；  </li>
</ul>
<p>3、<strong>平均检索长度</strong>：衡量检索算法的主要标准是检索过程中对关键字（或属性）要执行的平均运算次数。<br>4、<strong>AVI树</strong>：  </p>
<ul>
<li>一颗空二叉树是AVL树；  </li>
<li>若T是一颗非空二叉树，其访问任何结点的左右子树的相差高度不超过1，则T是AVL树。  </li>
</ul>
<p>5、<strong>碰撞</strong>：依据散列函数H计算出地址，若发现此地址已经被别的结点占用，即有两个不同的关键字映射到了同一地址空间的现象。<br>6、<strong>散列表</strong>：是一种存储方法也是一种常见的检索方法，是按关键字编址的一种技术。用散列法组织存储的表。<br>7、<strong>同义词</strong>：发生碰撞的两个关键字；<br>8、<strong>堆集现象</strong>：在散列表中插入一个新结点y时，当然它不是先前已经插入的某个节点x的同义词，但可能会出现H（y），已经被x的同义词占用的情况，这是只能将y也链接在x的同义链中，也就是说出现了y与x的同义链结成一个的情况，把连个同义词子表结合在一起的现象称为堆集现象。  </p>
<blockquote>
<p>第二层次：AVL的构造  </p>
</blockquote>
<ul>
<li>正常插入</li>
<li>当不满足平衡二叉树时，调整</li>
<li>调整要求中序顺序不变</li>
<li>RL或LR调整要把整个x都要挪上去</li>
</ul>
<p>举例：<br><img src="z.png" alt=""></p>
<blockquote>
<p>第三层次：二分检索  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">PROC DUOSEARCH(VAR R:ARRAY[1...MAX]OF DATATYPE;N:INTEGER;K:KTYPE)</div><div class="line">BEGIN</div><div class="line">	L &lt;- 1,H &lt;- N</div><div class="line">	WHILE L &lt;= H DO[</div><div class="line">		MIDDLE &lt;- (L+H) DIV 2</div><div class="line">		CASE	</div><div class="line">			K == R[MIDDLE]:WRITE&quot;SUEECE&quot;,EXIT;</div><div class="line">			K &lt; R[MIDDLE]: H = MIDDLE-1</div><div class="line">			K &gt; R[MIDDLE]: L = MIDDLE+1</div><div class="line">		ENDCASE</div><div class="line">	]</div><div class="line">	WRITE&quot;UNSUCCSE&quot;</div><div class="line">END</div></pre></td></tr></table></figure>
<h2 id="十二章，文件"><a href="#十二章，文件" class="headerlink" title="十二章，文件"></a>十二章，文件</h2><p>1、    <strong>文件</strong>：为了进行存取控制、检索和修改而组织在一起的数据记录集合。<br>2、    <strong>文件逻辑组成分类</strong>：（广义）两种：  </p>
<ul>
<li>字符流文件：有序的字符流序列，文件基本单位为字节或字。  </li>
<li>记录文件：数据记录的集合文件基本单位为记录。</li>
</ul>
<p>3、    <strong>文件物理组成分类</strong>：<br>从存储结构来看，文件的组织仅有三种：（说大的就行了）  </p>
<ul>
<li>顺序机构：按照数据到达的时间先后次序进行组织。按该方式组织的文件称顺序文件。  </li>
<li>计算寻址结构：按照散列方式组织文件。该方式组织的文件称散列文件。  </li>
<li>带索引的结构：组织数据时需要带一个索引表。称为索引文件，主要是利用树形结构组织索引。 </li>
</ul>
<p>4、    <strong>动态存储结构</strong>：是指文件创建初始装入记录时所生成的索引结构，在系统运行过程中索引结构本身能够发生改变。<br>5、    <strong>静态存储结构</strong>：指索引结构在文件创建，初始装入记录生成，一旦生成就固定下来，在系统运行过程中索引结构并不发生变化，只有当文件重组时菜允许改变索引结构。<br>6、    <strong>B+，B-树的本质</strong>：平衡的多分树。<br>7、    <strong>B+，B-树的作用</strong>：组织动态索引结构。<br>8、    <strong>ISAM文件的本质</strong>：索引顺序存取。（静态索引结构）<br>9、    <strong>VSAM文件的本质</strong>：虚拟存储存取。（动态索引结构）<br>10、    <strong>外排基本方法</strong>：归并排序。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数据结构知识框架&quot;&gt;&lt;a href=&quot;#数据结构知识框架&quot; class=&quot;headerlink&quot; title=&quot;数据结构知识框架&quot;&gt;&lt;/a&gt;数据结构知识框架&lt;/h1&gt;&lt;h2 id=&quot;第一章&quot;&gt;&lt;a href=&quot;#第一章&quot; class=&quot;headerlink&quot; ti
    
    </summary>
    
      <category term="笔记" scheme="http://ranxb.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="http://ranxb.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="数据结构" scheme="http://ranxb.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言：基础知识（第五章以前）</title>
    <link href="http://ranxb.cn/2018/01/09/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%9A%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E7%AC%AC%E4%BA%94%E7%AB%A0%E4%BB%A5%E5%89%8D%EF%BC%89/"/>
    <id>http://ranxb.cn/2018/01/09/汇编语言：基础知识（第五章以前）/</id>
    <published>2018-01-09T07:22:19.000Z</published>
    <updated>2018-01-09T15:21:05.093Z</updated>
    
    <content type="html"><![CDATA[<h1 id="汇编语言：基础知识（第五章以前）"><a href="#汇编语言：基础知识（第五章以前）" class="headerlink" title="汇编语言：基础知识（第五章以前）"></a>汇编语言：基础知识（第五章以前）</h1><h2 id="基基础"><a href="#基基础" class="headerlink" title="基基础"></a>基基础</h2><ul>
<li>数据总线：传数据用的，8线一次传1b，8086有16线</li>
<li>地址总线：最高可以寻到的地址，8086是20线，4线一个16进制位。</li>
<li>一个地址是一个内存单元就是1b，2个十六进制位。</li>
<li>要知道给定一个段地址之后的地址寻址范围。</li>
<li>inc</li>
<li>dec</li>
</ul>
<h2 id="寄存器的总结"><a href="#寄存器的总结" class="headerlink" title="寄存器的总结"></a>寄存器的总结</h2><h3 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h3><p>段寄存器就是存放段地址的</p>
<ul>
<li>CS</li>
<li>DS</li>
<li>SS</li>
<li>ES</li>
</ul>
<p><strong>段地址不支持直接将数据送入</strong>  </p>
<ul>
<li>SS：SP永远指向栈顶元素  </li>
</ul>
<p><strong>在自己写程序的过程中要注意的问题！</strong></p>
<ul>
<li>assume写全</li>
<li>最后int 21h</li>
<li>数据不能以字母开头</li>
<li>使用es存放目标空间的段地址</li>
<li>正式的程序开始时写<code>start</code>，最后写<code>end start</code></li>
</ul>
<h2 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h2><h3 id="多种寻址方式"><a href="#多种寻址方式" class="headerlink" title="多种寻址方式"></a>多种寻址方式</h3><ul>
<li>寄存器直接寻址</li>
<li>寄存器相对寻址（寄存器+idata）</li>
<li>基址变址寻址（寄存器+寄存器）</li>
<li>相对基址变址寻址（寄存器+寄存器+idata）</li>
</ul>
<h3 id="转大小写的单循环例子"><a href="#转大小写的单循环例子" class="headerlink" title="转大小写的单循环例子"></a>转大小写的单循环例子</h3><pre><code>assume cs:code,ds:data,ss:strack
strack segment
 dw 8 dup(0)
strack ends
data segment
 db &apos;1. display      &apos;
 db &apos;2. dsjk         &apos;
 db &apos;3. dasdasdasd   &apos;
data ends
code segment
start:
    mov ax,data
    mov ds,ax
    mov ax,strack
    mov ss,ax
    mov sp,10h
    mov di,0
    mov cx,4h
l:
    mov al,[di+3]
    and al,11011111b
    mov [di+3],al
    mov al,[di+10h+3]
    and al,11011111b
    mov [di+10h+3],al
    mov al,[di+32+3]
    and al,11011111b
    mov [di+32+3],al
    inc di
    loop l

mov ax,4c00h
int 21h


code ends
end start
</code></pre><p>结果<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="a.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<h3 id="转大小写的双循环例子"><a href="#转大小写的双循环例子" class="headerlink" title="转大小写的双循环例子"></a>转大小写的双循环例子</h3><blockquote>
<p>注意bx和si的同时使用，di和si不能同时使用</p>
</blockquote>
<pre><code>assume cs:code,ds:data,ss:strack
strack segment
 dw 8 dup(0)
strack ends
data segment
 db &apos;1. display      &apos;
 db &apos;2. dsjk         &apos;
 db &apos;3. dasdasdasd   &apos;
data ends
code segment
start:
mov ax,data
mov ds,ax
mov ax,strack
mov ss,ax
mov sp,10h
mov di,0
mov cx,4
mov si,0
l:
push cx
mov cx,3
l0:
mov al,[si+di+3]
and al,11011111b
mov [di+3],al
inc di
loop l0
mov di,0
add si,16
pop cx
loop l
mov ax,4c00h
int 21h
code ends
end start
</code></pre><p>结果<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="b.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<h2 id="指令的转移"><a href="#指令的转移" class="headerlink" title="指令的转移"></a>指令的转移</h2><h3 id="jmp"><a href="#jmp" class="headerlink" title="jmp"></a>jmp</h3><ul>
<li><code>jmp short 标号</code>  -128~127</li>
<li><code>jmp near ptr 标号</code>        -32768~32767</li>
<li><code>jmp far ptr 标号</code></li>
<li><code>jmp 16位reg</code>  IP = reg</li>
<li><code>jmp word ptr 地址</code>        段内转移：jmp word ptr ds:[0]，设置IP</li>
<li><code>jmp dword ptr 地址</code>    段间转移，先赋值IP</li>
</ul>
<h3 id="jcxz"><a href="#jcxz" class="headerlink" title="jcxz"></a>jcxz</h3><p>当cx为0时跳转，范围-128～127</p>
<h3 id="ret和retf"><a href="#ret和retf" class="headerlink" title="ret和retf"></a>ret和retf</h3><p>都是先对IP进行操作</p>
<pre><code>pop ip
pop cs
</code></pre><h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><ul>
<li>call 标号</li>
<li>call far ptr 标号  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">push cs</div><div class="line">push ip</div></pre></td></tr></table></figure>
<ul>
<li>call word ptr 地址</li>
<li>call dword ptr 地址</li>
</ul>
<h3 id="mul乘法"><a href="#mul乘法" class="headerlink" title="mul乘法"></a>mul乘法</h3><ul>
<li>双8位，一个放al，结果ax</li>
<li>双16位，一个放ax，结果高位dx低位ax</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mov al,1</div><div class="line">mov bl,2</div><div class="line">mul bl</div></pre></td></tr></table></figure>
<p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mov al,1</div><div class="line">mov byte ptr ds:[0],2</div><div class="line">mul byte ptr ds:[0]</div></pre></td></tr></table></figure></p>
<h3 id="div除法"><a href="#div除法" class="headerlink" title="div除法"></a>div除法</h3><blockquote>
<p>低位是商高位是余数</p>
</blockquote>
<ul>
<li>16位除以8位，前面的数放在ax里</li>
<li>32位除以16位，高位dx，低位ax</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">div byte ptr ds:[0];默认被除数是ax</div></pre></td></tr></table></figure>
<p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mov bx,10</div><div class="line">div bx；默认被除数高位是dx，低位时ax</div></pre></td></tr></table></figure></p>
<h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p>流程：</p>
<ul>
<li>取得中断码</li>
<li>pushf</li>
<li>设置标志寄存器</li>
<li>CS和IP入栈</li>
<li>设置IP，设置CS</li>
</ul>
<h3 id="中断向量表"><a href="#中断向量表" class="headerlink" title="中断向量表"></a>中断向量表</h3><p>四个字节一个中断地址<br>前两个是IP<br>后两个是CS</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><blockquote>
<p>这里进行模拟loop的安装，位置7ch。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;汇编语言：基础知识（第五章以前）&quot;&gt;&lt;a href=&quot;#汇编语言：基础知识（第五章以前）&quot; class=&quot;headerlink&quot; title=&quot;汇编语言：基础知识（第五章以前）&quot;&gt;&lt;/a&gt;汇编语言：基础知识（第五章以前）&lt;/h1&gt;&lt;h2 id=&quot;基基础&quot;&gt;&lt;a h
    
    </summary>
    
      <category term="汇编语言" scheme="http://ranxb.cn/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="笔记" scheme="http://ranxb.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="汇编语言" scheme="http://ranxb.cn/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>数字电路进阶（第六章以后）</title>
    <link href="http://ranxb.cn/2018/01/08/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E8%BF%9B%E9%98%B6%EF%BC%88%E7%AC%AC%E5%85%AD%E7%AB%A0%E4%BB%A5%E5%90%8E%EF%BC%89/"/>
    <id>http://ranxb.cn/2018/01/08/数字电路进阶（第六章以后）/</id>
    <published>2018-01-08T13:46:16.000Z</published>
    <updated>2018-01-09T12:03:26.885Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数字电路进阶（第六章以后）"><a href="#数字电路进阶（第六章以后）" class="headerlink" title="数字电路进阶（第六章以后）"></a>数字电路进阶（第六章以后）</h1><h2 id="时序逻辑电路的应用"><a href="#时序逻辑电路的应用" class="headerlink" title="时序逻辑电路的应用"></a>时序逻辑电路的应用</h2><blockquote>
<p>比如寄存器、锁存器、移位寄存器、计数器。。。</p>
</blockquote>
<p>寄存器什么都没有。<br>重点就是74ls290，看第六章的具体内容。  </p>
<ul>
<li><a href="http://ranxb.cn/2018/01/06/数字电路第六章：同步时序逻辑电路——下/#异步集成计数器74LS290">74LS290</a></li>
<li>环形计数器是将移位型寄存器最后一级反馈到第一级的输入端，特点是构成寄存器的模数和所用触发器的个数相同，只能利用四个状态，比较浪费。利用的是74LS194  </li>
<li>扭环形计数器是将最后一级的反变量反馈到第一级，不能自启动需要置零可以利用所有状态。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数字电路进阶（第六章以后）&quot;&gt;&lt;a href=&quot;#数字电路进阶（第六章以后）&quot; class=&quot;headerlink&quot; title=&quot;数字电路进阶（第六章以后）&quot;&gt;&lt;/a&gt;数字电路进阶（第六章以后）&lt;/h1&gt;&lt;h2 id=&quot;时序逻辑电路的应用&quot;&gt;&lt;a href=&quot;#
    
    </summary>
    
      <category term="数字电路" scheme="http://ranxb.cn/categories/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"/>
    
    
      <category term="数字电路" scheme="http://ranxb.cn/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"/>
    
      <category term="笔记" scheme="http://ranxb.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>数字电路：基础知识</title>
    <link href="http://ranxb.cn/2018/01/08/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%EF%BC%9A%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://ranxb.cn/2018/01/08/数字电路：基础知识/</id>
    <published>2018-01-08T10:08:34.000Z</published>
    <updated>2018-01-09T12:04:02.295Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数字电路：基础知识"><a href="#数字电路：基础知识" class="headerlink" title="数字电路：基础知识"></a>数字电路：基础知识</h1><blockquote>
<p>你可以理解为第五章之前的内容</p>
</blockquote>
<h2 id="各个码"><a href="#各个码" class="headerlink" title="各个码"></a>各个码</h2><h3 id="反码、补码"><a href="#反码、补码" class="headerlink" title="反码、补码"></a>反码、补码</h3><ul>
<li>反码：大于零的不变，小于零的除符号位全取反</li>
<li>补码：大于零的和原码一样，小于零的在最低位加1</li>
<li>运算：补码和补码都可以进行直接运算，两个直接相加，最高位溢出的话直接丢掉。反码运算的话需要把溢出位加到最后一位上。</li>
</ul>
<h3 id="十进制的补数"><a href="#十进制的补数" class="headerlink" title="十进制的补数"></a>十进制的补数</h3><ul>
<li>对十的补数：符号位是0(+)和9(-),两种方法,一是加后符号位后每个数值对十取反，就是用9减，然后最低位加一；二是几位就用10的几次方减原来那个数。<br><code>[5493] = 05493  [-3250] = 96750  [-0.3267] = 9.6733</code></li>
<li>对9的补数：类似，符号位是0和8，数字位用9减。末尾不加一<br><code>[8954] = 08954   [-3250] = 95639 [-25.639] = 974.360</code>  </li>
<li>运算：对十的补码运算溢出要丢掉，对九的补码运算溢出要加到最低位</li>
</ul>
<h3 id="码制和字符代码"><a href="#码制和字符代码" class="headerlink" title="码制和字符代码"></a>码制和字符代码</h3><ul>
<li>恒权代码：8421bcd、5421bcd、2421bcd、5211bcd</li>
<li>循环码：只有一位和周边俩不同的码</li>
<li>余三码：在8421的基础上加三个开始往后数</li>
<li>余三循环码：在循环码的基础上加三开始往后数</li>
<li>奇偶校验码：1的个数为奇偶数，在汇编中PF中当1的个数为偶数的时候标志为1</li>
<li>ASCII码：<strong>小写字母在大写字母后面</strong>，<strong>大于61H的是小写</strong>，将’a’的ASCII码<strong>减20H就可以变成大写</strong>字母’A’，将’A’的ASCII码<strong>加20H就可以变成小写</strong>字母’a’，ASCII码的<strong>二进制形式第六位为1时是小写字母</strong>，0时大写字母</li>
</ul>
<h2 id="逻辑函数"><a href="#逻辑函数" class="headerlink" title="逻辑函数"></a>逻辑函数</h2><ul>
<li>各个门的符号，与门（中间一个&amp;），或门（中间一个&gt;=1），非门（中间一个1后面加圈圈），异或（环和，中间=1），同或（环积，异或后面加圈圈）</li>
<li>最大项（各个项加起来）、最小项（各个项乘起来）</li>
<li>代数规律，两积可交换，乘零得零，分配律</li>
<li>卡诺图，2<sup>n</sup>种的可以画圈圈，出来的圈圈是最小项的形式。</li>
<li>三态门：高电平、低电平、高阻态</li>
</ul>
<h2 id="组合逻辑电路"><a href="#组合逻辑电路" class="headerlink" title="组合逻辑电路"></a>组合逻辑电路</h2><ul>
<li>做题方法：写出真值表需求逻辑表达式，用卡诺图化简，化简完成之后电路表达。</li>
<li>竞争与冒险判别方法：各种情况的代入，只留一种变量不变，若出现如f = a + 非a的情况，存在竞争，竞争的结果是冒险。卡诺图法，有相切的部分有竞争</li>
<li>消除竞争的方法：添加冗余项，把相切的地方添加至电路。滤波法选通法（这俩没用）</li>
</ul>
<h2 id="优先编码器-74148"><a href="#优先编码器-74148" class="headerlink" title="优先编码器 74148"></a>优先编码器 74148</h2><p>允许同时输入两个以上编码信号，在同时存在两个或两个以上输入信号时，优先编码器只按优先级高的输入信号编码，优先级低的则不起作用。</p>
<blockquote>
<p>74148是一个8线-3线优先编码器，8线指的输入、3线是输出。特点是端口都是非。</p>
</blockquote>
<ul>
<li>非I<sub>0</sub>~非I<sub>7</sub>是输入信号。  </li>
<li>非I<sub>e</sub>是输入端，若为1则禁止编码。输出均为1，若为0则正常工作  </li>
<li>非O<sub>e</sub>使能输出端，低电频工作表示“电路工作，但无编码输入”  </li>
<li>非G<sub>e</sub>为片优先编码输出端，低电频工作表示“电路工作，且有编码输入”  </li>
</ul>
<p>IOG均为扩展时所用。   </p>
<ul>
<li>由于输出带非门，所以输出的是二进制反码</li>
<li>由于输入带非门，所以输入0为有效</li>
</ul>
<p>扩展时例图为<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="a.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<h3 id="译码器-74138"><a href="#译码器-74138" class="headerlink" title="译码器 74138"></a>译码器 74138</h3><p>和74148差不离，输出是反码，输入是原码，3-8输出译码器。  S1是原码，S23是反码</p>
<ul>
<li>S1要输入高电频，S23口要输入低电频才可以正常工作，否则都为1。正常工作示意图：<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="b.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
可以把它当成最小项，做一些需要最小项的题  </li>
<li>两个的扩展，可以把低位的s2或3接到高位的s1上，这样就可以控制一个工作一个不工作，其他的都接地，如图<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="c.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
</li>
</ul>
<h3 id="数据选择器"><a href="#数据选择器" class="headerlink" title="数据选择器"></a>数据选择器</h3><blockquote>
<p>只有非S是反码，是控制端，0正常工作，两个选择端，四个数据输入端。</p>
</blockquote>
<p>直接看题<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="d.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数字电路：基础知识&quot;&gt;&lt;a href=&quot;#数字电路：基础知识&quot; class=&quot;headerlink&quot; title=&quot;数字电路：基础知识&quot;&gt;&lt;/a&gt;数字电路：基础知识&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;你可以理解为第五章之前的内容&lt;/p&gt;
&lt;/blockquo
    
    </summary>
    
      <category term="数字电路" scheme="http://ranxb.cn/categories/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"/>
    
    
      <category term="数字电路" scheme="http://ranxb.cn/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"/>
    
      <category term="笔记" scheme="http://ranxb.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>数字电路第六章：同步时序逻辑电路——下</title>
    <link href="http://ranxb.cn/2018/01/06/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E5%90%8C%E6%AD%A5%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E2%80%94%E2%80%94%E4%B8%8B/"/>
    <id>http://ranxb.cn/2018/01/06/数字电路第六章：同步时序逻辑电路——下/</id>
    <published>2018-01-06T08:29:26.000Z</published>
    <updated>2018-01-06T13:47:29.410Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数字电路第六章：同步时序逻辑电路——下"><a href="#数字电路第六章：同步时序逻辑电路——下" class="headerlink" title="数字电路第六章：同步时序逻辑电路——下"></a>数字电路第六章：同步时序逻辑电路——下</h1><h2 id="状态编码"><a href="#状态编码" class="headerlink" title="状态编码"></a>状态编码</h2><blockquote>
<p>在求得最简状态码之后，需要对状态表中用字母或数字表示的状态用一组二进制代码来代替，称之为状态编码（也叫状态赋值或状态分配）</p>
</blockquote>
<h3 id="状态编码的任务"><a href="#状态编码的任务" class="headerlink" title="状态编码的任务"></a>状态编码的任务</h3><ol>
<li>确定状态编码的长度，即二进制代码的位数或者是触发器的个数。  </li>
<li>确定二进制编码的分配方案。  </li>
</ol>
<h3 id="状态编码的长度确定"><a href="#状态编码的长度确定" class="headerlink" title="状态编码的长度确定"></a>状态编码的长度确定</h3><p>每个触发器可以代表一位二进制数，n个触发器可以代表n位二进制数，组成2<sup>n</sup>个二进制代码。</p>
<p>所需状态数M和触发器个数n之间应满足以下关系:  2<sup>n-1</sup> &lt; M ≤ 2<sup>n</sup>  </p>
<h3 id="确定二进制编码分配方案"><a href="#确定二进制编码分配方案" class="headerlink" title="确定二进制编码分配方案"></a>确定二进制编码分配方案</h3><p>因为编码和状态配合的方式很多，徐阿哟选择最佳的编码方式。<br>若当N=4, n=2时，就有24种状态分配方案。随着状 态数目的增加，状态分配方案的总数将急剧增加。<strong>状态编码解决的主要问题是确定一组使次态函数(或驱动方程)和输出函数尽可能简单、可靠的 状态编码,称之为最佳编码。</strong></p>
<h3 id="分配的基本原则"><a href="#分配的基本原则" class="headerlink" title="分配的基本原则"></a>分配的基本原则</h3><ul>
<li>在状态表中同一输入下的相同次态所对应的现态，尽可能分配相邻编码。通常称为“<strong>次态相同，现态编码相邻</strong>”。</li>
<li>在状态表中，同一现态，相邻输入下的不同次态，应尽可能分配相邻编码。通常称为“<strong>同一现态，次态编码相邻</strong>”。</li>
<li>在状态表中某些输出完全相同的现态。那么尽可能给现态分配相邻的编码，通常称“<strong>输出相同，现态编码相邻</strong>”。</li>
<li>在状态表中，<strong>出现次数最多的状态通常给予逻辑0的编码</strong>。  </li>
</ul>
<p><strong>注意</strong>：一般情况下，应优先考虑原则(1)，因为原则 (1)最重要！例：<br><img src="a.png" alt=""><br>结果如下：<br><img src="b.png" alt="">  </p>
<h2 id="同步时序逻辑电路设计举例"><a href="#同步时序逻辑电路设计举例" class="headerlink" title="同步时序逻辑电路设计举例"></a>同步时序逻辑电路设计举例</h2><h3 id="例题一"><a href="#例题一" class="headerlink" title="例题一"></a>例题一</h3><p>例题：试设计一个序列数据检测器，该电路用来检测输入的串行二进制序列，当输入连续出现110时，检测器输出为1，其他情况下输出为0。</p>
<ol>
<li>进行逻辑抽象画出状态转换图和状态转换表<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="c.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>  
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="d.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>  </li>
<li>进行状态化简，因为全部确定，建立最简等效类<br><img src="e.png" alt=""></li>
<li>状态编码，状态可用两个二进制编码表示，S0出现的最多设为00，S1=01，S2=11<br><img src="f.png" alt=""></li>
<li>根据状态表求出状态方程，驱动方程和输出方程，画出Z的卡诺图，Q2n+1和Q1n+1的卡诺图<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="g.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>  
并根据卡诺图的化简结果写出输出方程，状态方程，并带入触发器的特征方程写出驱动方程。<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="h.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>  </li>
<li>经过对比特征方程的标准形式，写出j和k，并画出逻辑电路图。<br><img src="i.png" alt=""></li>
<li>判断自启动，当电路处于无关状态时，是否可以通过时钟脉冲的作用下进入有效状态。</li>
</ol>
<h3 id="例题二"><a href="#例题二" class="headerlink" title="例题二"></a>例题二</h3><p>例题：试设计一个同步七进制计数器，要求按二进制加计数规律变化。</p>
<p>确定状态转换情况，注意看题是七进制，因此111位无效情况。<br><img src="j.png" alt=""><br>确定编码状态<br><img src="k.png" alt=""><br>因为是Moore型电路，跟输入无关，所以卡诺图这么画<br><img src="l.png" alt=""><br>通过卡诺图写出状态方程，经验来看Moore型电路都用D触发器<br><img src="m.png" alt=""><br>写出驱动方程，画出电路图<br><img src="n.png" alt=""><br>最后检查一下自启动<br><img src="o.png" alt="">  </p>
<h2 id="常用集成时序逻辑电路及应用"><a href="#常用集成时序逻辑电路及应用" class="headerlink" title="常用集成时序逻辑电路及应用"></a>常用集成时序逻辑电路及应用</h2><blockquote>
<p>寄存器好像不考，直接计数器了。</p>
</blockquote>
<h3 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h3><p>一种对输入脉冲信号进行计数的时序逻辑部件。<br>可以分为：  </p>
<ul>
<li>二进制计数器和非二进制计数器</li>
<li>加计数器、减计数器和可逆计数器</li>
<li>同步计数器和异步计数器</li>
</ul>
<h4 id="集成计数器"><a href="#集成计数器" class="headerlink" title="集成计数器"></a>集成计数器</h4><h5 id="同步集成计数器74LS191"><a href="#同步集成计数器74LS191" class="headerlink" title="同步集成计数器74LS191"></a>同步集成计数器74LS191</h5><p><strong>74LS191</strong><br><img src="p.png" alt=""><br>功能及其真值表<br><img src="q.png" alt=""></p>
<h5 id="异步集成计数器74LS290"><a href="#异步集成计数器74LS290" class="headerlink" title="异步集成计数器74LS290"></a>异步集成计数器74LS290</h5><p><strong>74LS290重点！</strong><br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="r.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>中规模集成电路74LS290是典型的异步BCD码十进制计数器。<br>逻辑电路如下<br><img src="s.png" alt=""><br><strong>功能分析</strong> </p>
<ul>
<li>若在CPa端输入时钟脉冲，则Qa输出信号是CPa的脉冲二分频  </li>
<li>FB,FC,FD三个触发器构成的逻辑电路是一个异步五进制计数器，其CPB为计数脉冲输入端，QD为输出端。即QD的输出信号是CPB脉冲的五分频。  </li>
<li>若将CPB与QA相连，同时以CPA为输入计数脉冲端。QD的输出为十进制计数器(或十分频器)。<br>因此，又将这个电路称为二、五、十进制异步计数器。<br><strong>真值表</strong><br><img src="t.png" alt=""><br><strong>真值表的分析</strong>  </li>
<li>直接复位输入端R01和R02：当R01=R02=1，且S91,S92中有“0”时，可使各触发器清为零。  </li>
<li>置“9”输入端S91和S92：其状态QDQCQBQA = 1001,这就是置“9”功能。  </li>
<li>在置“9”输入端S91,S92和复位输入端R01,R02中均有“0”电平时，74LS290可实现计数功能。  </li>
</ul>
<p><strong>任意进制计数器的构造方法</strong><br>例：用74LS290和适当的门电路构成64进制计数器，采用5421BCD码计数。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="u.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<ul>
<li>Cb和Qa接时，Ca输入时钟信号，输出顺序为dcba，计数方式为8421</li>
<li>Ca和Qd接时，Cb接时钟信号，输出顺序为adcb，计数方式为5421</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="v.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h5 id="环形计数器"><a href="#环形计数器" class="headerlink" title="环形计数器"></a>环形计数器</h5><p>环形计数器是将移位寄存器的最后一级输出 反馈到第一级串行输入端SR，特点是构成的 计数器模数M和所用触发器个数n相等。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="w.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数字电路第六章：同步时序逻辑电路——下&quot;&gt;&lt;a href=&quot;#数字电路第六章：同步时序逻辑电路——下&quot; class=&quot;headerlink&quot; title=&quot;数字电路第六章：同步时序逻辑电路——下&quot;&gt;&lt;/a&gt;数字电路第六章：同步时序逻辑电路——下&lt;/h1&gt;&lt;h2 i
    
    </summary>
    
      <category term="数字电路" scheme="http://ranxb.cn/categories/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"/>
    
    
      <category term="数字电路" scheme="http://ranxb.cn/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"/>
    
      <category term="笔记" scheme="http://ranxb.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>数字电路第六章：同步时序逻辑电路——上（状态编码之前）</title>
    <link href="http://ranxb.cn/2018/01/06/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E5%90%8C%E6%AD%A5%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E2%80%94%E2%80%94%E4%B8%8A%EF%BC%88%E7%8A%B6%E6%80%81%E7%BC%96%E7%A0%81%E4%B9%8B%E5%89%8D%EF%BC%89/"/>
    <id>http://ranxb.cn/2018/01/06/数字电路第六章：同步时序逻辑电路——上（状态编码之前）/</id>
    <published>2018-01-05T16:55:39.000Z</published>
    <updated>2018-01-06T08:23:13.442Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数字电路第六章：同步时序逻辑电路——上（状态编码之前）"><a href="#数字电路第六章：同步时序逻辑电路——上（状态编码之前）" class="headerlink" title="数字电路第六章：同步时序逻辑电路——上（状态编码之前）"></a>数字电路第六章：同步时序逻辑电路——上（状态编码之前）</h1><blockquote>
<p>讲同步时序逻辑电路的工作原理、分析方法和设计方法。<br>逻辑电路分为：组合逻辑电路和时序逻辑电路。<br>组合逻辑电路是指典礼在任何时刻所产生的输出仅取决于该时刻电路的输入。<br>时序逻辑电路按其工作方式不同分为：同步时序逻辑电路、异步时序逻辑电路。<br>本章介绍同步时序逻辑电路的分析与设计。    </p>
</blockquote>
<h2 id="同步时序逻辑电路的模型和描述方法"><a href="#同步时序逻辑电路的模型和描述方法" class="headerlink" title="同步时序逻辑电路的模型和描述方法"></a>同步时序逻辑电路的模型和描述方法</h2><h3 id="同步时序逻辑电路的结构模型"><a href="#同步时序逻辑电路的结构模型" class="headerlink" title="同步时序逻辑电路的结构模型"></a>同步时序逻辑电路的结构模型</h3><p>同步时序逻辑电路是一种与时序有关的电路，一般说来，是由组合电路和存储电路两部分组成，并形成反馈电路。<br><img src="a.png" alt=""><br><strong>组合逻辑电路的输出</strong>  </p>
<ol>
<li>向外输出 Z   </li>
<li>内部输出 Q </li>
</ol>
<p><strong>组合逻辑电路的输入</strong>  </p>
<ol>
<li>外部输入：整个时序电路的输入 X  </li>
<li>内部输入：存储电路的内部输出 Y  </li>
</ol>
<p><strong>函数的意义</strong><br>Zi称为输出函数<br>Yj称为驱动方程<br>Mealy型电路：Z的输出既和存储电路的输出有关有和当前状态的输入x有关。<br>Moore型电路：Z的输出只和存储电路的输出有关。<br><strong>采用时钟控制的触发器构成存储电路</strong><br>存储时序电路中的二进制信息被定义为电路的状态，触发器的状态就称为时序电路的状态。<br><strong>向量函数</strong><br><img src="b.png" alt=""><br>时钟信号不能间隔过短，要状态状态稳定后再一个信号再来。  </p>
<h3 id="同步时序逻辑电路的描述方法"><a href="#同步时序逻辑电路的描述方法" class="headerlink" title="同步时序逻辑电路的描述方法"></a>同步时序逻辑电路的描述方法</h3><p>为了形象的表示时序逻辑电路的全过程性，把电路在一系列的时钟信号作用下状态转换的全过程找出来，则电路的逻辑功能就一目了然了。<br>描述时序电路状态的转换全部过程的方法：  </p>
<ol>
<li>状态方程  </li>
<li>状态转换表（状态转换真值表）  </li>
<li>状态转换图（简称状态图）  </li>
<li>时序图（波形图）  </li>
</ol>
<h4 id="状态方程"><a href="#状态方程" class="headerlink" title="状态方程"></a>状态方程</h4><p>输出方程：表示输出与输入和现态的关系<br>驱动方程：表示现态向次态转换所需的条件<br>状态方程：表示在给定的输入下将使现态转向状态  </p>
<h4 id="状态转换表"><a href="#状态转换表" class="headerlink" title="状态转换表"></a>状态转换表</h4><p>由现态Q、次态Qn+1和输出Z组成。<br>例：<br><img src="c.png" alt=""><br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="d.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="e.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<h4 id="状态转换图"><a href="#状态转换图" class="headerlink" title="状态转换图"></a>状态转换图</h4><p>在状态转换图中以圆圈表示电路的各个状态，以箭头表示状态转换的方向。 同时，还在箭头旁注明了状态转换前的输入变量取 值和输出值。通常将输入变量取值写在斜线以上，将输出值写在斜线以下。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="f.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>  </p>
<h4 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h4><p>将状态转换表的内容画成时间波形图。在时钟脉冲序列作用下，电路状态、输出状态随时间变化的波形图叫做时序图。而且便于用实验观察的方法检查时序电路的逻辑功能。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="g.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<h2 id="同步时序逻辑电路的分析方法"><a href="#同步时序逻辑电路的分析方法" class="headerlink" title="同步时序逻辑电路的分析方法"></a>同步时序逻辑电路的分析方法</h2><p>根据给定的逻辑电路图，找出他的状态方程、输出方程、状态图和时序图。用这些方法来描述电路的工作全过程及输入输出关系。</p>
<h3 id="时序逻辑电路的分析步骤"><a href="#时序逻辑电路的分析步骤" class="headerlink" title="时序逻辑电路的分析步骤"></a>时序逻辑电路的分析步骤</h3><p>找出给定时序电路的逻辑功能即找出在输入信号和时钟信号作用下，电路的次态和输出。一般步骤如下：  </p>
<ol>
<li>根据给定的逻辑电路图，写出每个触发器的驱动方程（控制方程）。  </li>
<li>把得到的驱动方程带入相应的触发器的特性方程，得出每个触发器的状态方程，从而写出这些状态方程的方程组。并写出输出方程。  </li>
<li>建立状态转换真值表  </li>
<li>做出状态图和时序波形图。  </li>
<li>总结功能。  </li>
</ol>
<h3 id="同步时序电路分析的例子"><a href="#同步时序电路分析的例子" class="headerlink" title="同步时序电路分析的例子"></a>同步时序电路分析的例子</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="h.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>  
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="i.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="j.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>  
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="k.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<ol>
<li>找每个触发器的输入端，写方程，=1的框框是环和。  </li>
<li>把写好的方程带入触发器的特征方程例，写出次态的状态方程，在找输出端写出输出方程。  </li>
<li>列表，横纵分别有触发器现态和输入值，结果是触发器次态和输出值。  </li>
<li>画圈圈，把触发器的变化过程用圈圈画出来，箭头写上输入值和输出值。  </li>
<li>总结。  </li>
</ol>
<p><strong>注意</strong>，Moore型的因为次态和输入无关，所以只列输出的表的顺序即可，Mealy型的因为和输入有关所以要建和输入有关的表，注意没有排列到的状态要单独加上，类似于：<br><img src="l.png" alt=""><br>整个例如Moore型的例题：<br><img src="m.png" alt=""><br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="n.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<h2 id="同步时序逻辑电路的设计"><a href="#同步时序逻辑电路的设计" class="headerlink" title="同步时序逻辑电路的设计"></a>同步时序逻辑电路的设计</h2><h3 id="设计同步时序逻辑电路的过程"><a href="#设计同步时序逻辑电路的过程" class="headerlink" title="设计同步时序逻辑电路的过程"></a>设计同步时序逻辑电路的过程</h3><ol>
<li>根据实际要求进行逻辑抽象，得出电路的原始状态转换图和转换表。   </li>
<li>状态化简，求最简状态化简表。  </li>
<li>状态编码。第一步. 确定触发器的数目n 第二步. 给每个电路状态分配一组二进制代码，称为状态编码。  </li>
<li>选定触发器类型，求出电路的状态方程。根据状态转换图(或状态转换表)和选定的状态编码、触发器的类型，就可写出电路的状态方程、驱动方程和输出方程。  </li>
<li>根据方程式画出逻辑电路图。  </li>
<li>检查自启动，解决办法：一、通过预置数。二、修改逻辑设计。  </li>
</ol>
<p>整体步骤如图所示：<br><img src="o.png" alt=""></p>
<h3 id="建立原始状态转换图和转换表"><a href="#建立原始状态转换图和转换表" class="headerlink" title="建立原始状态转换图和转换表"></a>建立原始状态转换图和转换表</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="p.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h3 id="完全确定原始状态表化简"><a href="#完全确定原始状态表化简" class="headerlink" title="完全确定原始状态表化简"></a>完全确定原始状态表化简</h3><p>状态表化简的原则（若状态表中的任意两个状态Si和Sj，同时满足下列两个条件，则他们可以合并成一个状态）：  </p>
<ol>
<li>在所有可能的现输入下，两个（或多个）状态相应的现输出分别相同。</li>
<li>在所有可能的现输入下，次态分别为下列情况之一：<br> a. 两个次态完全相同<br> b. 两个次态为状态对循环的一个状态对<br> c. 两个次态为其现态本身或交错<br> d. 两个次态的某一后序状态可以合并  </li>
</ol>
<p>上述的第一个条件是状态合并的必要条件，该条件不满足就无需再考虑第二个条件。  </p>
<p>根据状态表化简的原则，利用下列判别方法造出状态表中全部的出状态并对进行分类合并。 </p>
<ol>
<li>等效状态和等效类<br><strong>等效状态</strong>—满足上述合并条件的两个状态如Si和Sj称为等效状态，或称等效状态对，记为{Si, Sj}。<br><strong>等效状态的传递性</strong>——若状态Si和Sj等效,状态Sj和Sm等效，则状态Si必和Sm等效,称为等效状态的传递性，记为{Si,Sj}{Sj,Sm}→{Si,Sm}   </li>
</ol>
<p><strong>等效类</strong>——彼此等效状态的集合。<br><strong>最大等效类</strong>——若一个等效类不包含在任何其它等效类之中，则称它为最大等效类。这里说的最大，并不是指包含的状态最多，而是指他的<strong>独立性</strong>！。  </p>
<p>显然，状态表的化简的根本任务在于从原始状态表中找出最大等效类，并用一个状态代替。例如：<br><img src="q.png" alt="">  </p>
<ol>
<li>用隐含表法化简<br>隐含表是一个斜边为阶梯型的直角三角形网络。及横向和纵向格数相同，格数为原始状态表的状态数减一。<br>然后顺序比较，往表格里填东西。依次比较，若两个状态不是等效对就画X，如果两个状态是等效对则画√，若不确定的则写出下一组状态对，如表：<br><img src="r.png" alt=""><br>例如CF对完全相同则画✅，又例如AD输出Z都不一样则画叉。还有比如AB两个，输出一样，但是X=0时的次态不同，则无法确定则将CF写入，X=1时因为是两个交换对所以是满足的条件，不用将其写入。最后列出下表：<br><img src="s.png" alt=""><br>根据等效关系的传递性，对等效状态对 {A,B}、{A,E}、{B,E}构成等效类{A,B,E}。 等效状态对{C,F}也是等效类。由于等效类 {A,B,E}和{C,F}互不包含在对方的等效类中， 所以，等效类{A,B,E}和{C,F}都是最大等效类。而状态G和D不和任何其它状态等效，因此,它们本身也是一个最大等效类,分别记作{G}和{D}。因此最大等效集合<code>{A,B,E}，{C,F}，{D}，{G}</code>  </li>
</ol>
<p>建立最简状态表。最大等效类集合必须覆盖原始状态表的全部状态。原始状态表中每一个状态只能属于一个最大等效类。这样，每个最大等效类可用一个状态代替。即:<code>a={ABE} b={CF} c={D} d={G}</code>由此可得最简状态表：<br><img src="t.png" alt=""></p>
<h3 id="不完全确定状态表的化简"><a href="#不完全确定状态表的化简" class="headerlink" title="不完全确定状态表的化简"></a>不完全确定状态表的化简</h3><p>这种电路的 状态表包含着不确定的次态或输出，所以，是一种不完全确定电路。并不是任何输出序列都是有效的。不完全确定状态表的化简是基于相容状态的，再利用任意项可使状态表 化的更简。<br><strong>相容状态</strong>——再不完全确定表中，假设S1和S2为初始状态，如果对于所有的有效输入序列从状态S1和S2除法他们相应的输出序列（除不确定的那些之外）是完全相同的，那么状态S1和S2是相容的，或者说S1和S2是相容对，记作（S1，S2）<br><strong>相容状态的条件</strong>——在所有可能输入条件下，两个状态对应的输出相同，或者其中一个（或两个）输出为任意值；并且它们的次态相同、交错、循环、相容，或者其中一个（或两个）为任意状态，那么这两个状态是相容的。<br><strong>相容类</strong>——由彼此相容的状态构成的集合，处于同一相容类 中的所有状态之间都是两两相容的。<br><strong>非传递性</strong>——状态等效具有传递性，而<strong>状态相容不具有传递性</strong>。 因此，若要求(S1, S2，S3)相容，则必须(S1,S2)， (S2,S3)，(S1,S3)都是相容对。也就是说，相容类中所有状态之间都分别是两两相容的。<br><strong>最大相容类</strong>——若一个相容类不是任何其他相容类的子集，则该相容类称为最大相容类。<br>例题：<br><img src="u.png" alt=""><br>表中由于部分状态的次态和输出无法确定，所以是不完全确定状态表。  </p>
<ol>
<li>做隐含表并比较，如图<br><img src="v.png" alt=""><br>2.在相容状态对中找最大相容类<br><img src="w.png" alt="">  </li>
<li>确定原始状态表的最小闭合覆盖集  </li>
<li><strong>选择一个</strong>同时满足<em>覆盖、闭合和最小</em>三个条件的<strong>相容类集合</strong>，将每个相容类用一个新状态来代替，以得到一个新的状态表。  </li>
</ol>
<p><strong>覆盖</strong>——指相容类集合中包含了原始状态表的全部状态。即原始状态表中任何一个状态至少包含在相容类集合中的一个相容类(包括最大相容类)中，而不能遗漏。<br><strong>闭合</strong>——指一个相容类集合中,任一相容类的所有隐含条件都必须属于该集合中某一个相容类(包括最大相容类)。<br><strong>最小</strong>——是指满足覆盖和闭合的相容类数目最少。不完全状态表的简化，就是寻找一个最小闭合覆盖<br>为了反应闭合和覆盖这两个性质，建立闭合覆盖表：<br><img src="x.png" alt=""><br>在表的左边自上而下列出所选相容类，表的中间覆盖部分自左到右列出全部状态，表的右边闭合部分列出各相容类在输入各种取值组合下的次态组合。必须指出，这里所说的相容类包括最大相容类和它们的子类。<br>找到了覆盖闭合最小之后，就可以画出最简状态表：<br><img src="y.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数字电路第六章：同步时序逻辑电路——上（状态编码之前）&quot;&gt;&lt;a href=&quot;#数字电路第六章：同步时序逻辑电路——上（状态编码之前）&quot; class=&quot;headerlink&quot; title=&quot;数字电路第六章：同步时序逻辑电路——上（状态编码之前）&quot;&gt;&lt;/a&gt;数字电路第
    
    </summary>
    
      <category term="数字电路" scheme="http://ranxb.cn/categories/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"/>
    
    
      <category term="数字电路" scheme="http://ranxb.cn/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"/>
    
      <category term="笔记" scheme="http://ranxb.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言第十二。。章：内外中断和int指令</title>
    <link href="http://ranxb.cn/2018/01/05/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AC%AC%E5%8D%81%E4%BA%8C%E3%80%82%E3%80%82%E7%AB%A0%EF%BC%9A%E5%86%85%E5%A4%96%E4%B8%AD%E6%96%AD%E5%92%8Cint%E6%8C%87%E4%BB%A4/"/>
    <id>http://ranxb.cn/2018/01/05/汇编语言第十二。。章：内外中断和int指令/</id>
    <published>2018-01-04T16:33:03.000Z</published>
    <updated>2018-01-05T16:54:54.210Z</updated>
    
    <content type="html"><![CDATA[<h1 id="汇编语言第十二。。章：内外中断和int指令"><a href="#汇编语言第十二。。章：内外中断和int指令" class="headerlink" title="汇编语言第十二。。章：内外中断和int指令"></a>汇编语言第十二。。章：内外中断和int指令</h1><blockquote>
<p>不再过多说中断是什么了，就是可以随时控制CPU停止当前的指令干其他的事的意思，下面内中断程序的步骤：  </p>
<ol>
<li>将程序写入0:200开始的空间内，同时把字符什么的也要定义进去。  </li>
<li>设置中断向量表，前面是ip，后面是cs。注意高低位。  </li>
</ol>
</blockquote>
<h2 id="单步中断的操作"><a href="#单步中断的操作" class="headerlink" title="单步中断的操作"></a>单步中断的操作</h2><ol>
<li>取得中断类型码</li>
<li>标志寄存器入栈</li>
<li>标志寄存器TF和IF置零，防止在中断程序中在中断。  </li>
<li>CS内容入栈</li>
<li>IP入栈</li>
<li>根据中断类型码从中断向量表中设置中断程序的CS和IP。</li>
</ol>
<h2 id="中断处理程序的编写方法"><a href="#中断处理程序的编写方法" class="headerlink" title="中断处理程序的编写方法"></a>中断处理程序的编写方法</h2><ol>
<li>保存用到的寄存器</li>
<li>处理中断</li>
<li>恢复寄存器</li>
<li>iret</li>
</ol>
<p>iret用来返回程序：操作为：  </p>
<pre><code>pop ip
pop cs
popf
</code></pre><p>目的是回到执行中断处理程序之前的执行点继续执行程序。</p>
<h2 id="编写0号中断程序"><a href="#编写0号中断程序" class="headerlink" title="编写0号中断程序"></a>编写0号中断程序</h2><pre><code>assume cs:code ss:satck ds:data
code segment
start:    mov ax,cs
            mov ds,ax
            mov si,offset do0    ;ds:si指向do0中断程序部分
            mov ax,0
            mov es,ax
            mov di,200h
            mov cx offset do0end - do0
            cld
            rep movsb
            mov ax,0            ;安装中断程序
            mov es,ax
            mov word ptr es:[0],200h
            mov word ptr es:[0+2],0

            mov ax,4c00h
            int 21h

do0:        jmp short do0start
            db &quot;overflow!&quot;

do0start:
            mov ax,cs
            mov ds,ax
            mov si,202h            ;ds:si指向字符串
            mov ax,0b800h
            mov es,ax
            mov di,12*160+36*2    ;es:di指向显存空间
            mov cx,9
        s:    mov al,[si]
            mov es:[di],al
            inc si
            add di,2
            loop s

            mov ax,4c00h
            int 21h
</code></pre><h2 id="中断的特殊情况"><a href="#中断的特殊情况" class="headerlink" title="中断的特殊情况"></a>中断的特殊情况</h2><p>设置栈的操作不会响应中断，因为中断会进行栈操作，需要设置正确的栈顶，所以设置sp的指令应当紧接着设置ss的指令</p>
<h2 id="int指令"><a href="#int指令" class="headerlink" title="int指令"></a>int指令</h2><p>格式：int n，n为中断类型码<br>int指令的最终功能和call类似，都是调用一段程序。<br>中断处理程序简称为中断例程  </p>
<h2 id="编写供应用程序调用的中断例程"><a href="#编写供应用程序调用的中断例程" class="headerlink" title="编写供应用程序调用的中断例程"></a>编写供应用程序调用的中断例程</h2><p>明天再写详细的</p>
<h2 id="BIOS和DOS多提供的中断例程的安装过程"><a href="#BIOS和DOS多提供的中断例程的安装过程" class="headerlink" title="BIOS和DOS多提供的中断例程的安装过程"></a>BIOS和DOS多提供的中断例程的安装过程</h2><ol>
<li>CPU加电，初始化(CS) = 0FFFFH，(IP) = 0，从FFFF：0开始执行程序。此处有一条跳转指令，跳转后开始执行BIOS中的硬件系统检测和初始化程序  </li>
<li>初始化程序建立BIOS所支持的中断向量表，只需登记中断向量表，中断程序在ROM中，一直在内存中存在  </li>
<li>硬件检测和初始化完成之后，调用int 19h，进入操作系统引导程序。</li>
<li>DOS启动，将所提供的中断例程装入内存，并建立中断向量表。</li>
</ol>
<h2 id="BIOS和DOS的中断例程的应用"><a href="#BIOS和DOS的中断例程的应用" class="headerlink" title="BIOS和DOS的中断例程的应用"></a>BIOS和DOS的中断例程的应用</h2><p>就是应用了，比如BIOS中的彩色显示int 10h和DOS中的输出字符串int 21h。明天再写</p>
<h2 id="汇编语言：完～"><a href="#汇编语言：完～" class="headerlink" title="汇编语言：完～"></a>汇编语言：完～</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;汇编语言第十二。。章：内外中断和int指令&quot;&gt;&lt;a href=&quot;#汇编语言第十二。。章：内外中断和int指令&quot; class=&quot;headerlink&quot; title=&quot;汇编语言第十二。。章：内外中断和int指令&quot;&gt;&lt;/a&gt;汇编语言第十二。。章：内外中断和int指令&lt;/
    
    </summary>
    
      <category term="汇编语言" scheme="http://ranxb.cn/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="笔记" scheme="http://ranxb.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="汇编语言" scheme="http://ranxb.cn/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言第十一章：标志寄存器</title>
    <link href="http://ranxb.cn/2018/01/05/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%EF%BC%9A%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8/"/>
    <id>http://ranxb.cn/2018/01/05/汇编语言第十一章：标志寄存器/</id>
    <published>2018-01-04T16:26:41.000Z</published>
    <updated>2018-01-04T16:28:56.877Z</updated>
    
    <content type="html"><![CDATA[<h1 id="汇编语言第十一章：标志寄存器"><a href="#汇编语言第十一章：标志寄存器" class="headerlink" title="汇编语言第十一章：标志寄存器"></a>汇编语言第十一章：标志寄存器</h1><blockquote>
<p>标志寄存器就是CPU处理数据的时候做标记的<br>这一章学的有ZF，SF，PF，CF，OF标志寄存器，还有adc，sbb，movsb，movsw，cld，std，rep等操作</p>
</blockquote>
<h2 id="第六位：ZF"><a href="#第六位：ZF" class="headerlink" title="第六位：ZF"></a>第六位：ZF</h2><p>zero flag<br>零标志位<br>处理完之后是否为零，0的话ZF则为一</p>
<h2 id="第二位：PF"><a href="#第二位：PF" class="headerlink" title="第二位：PF"></a>第二位：PF</h2><p>Parity flag<br>奇偶校验位<br>换成二进制之后，1的个数是偶数？PF = 1 ：PF = 0  </p>
<h2 id="第七位：SF"><a href="#第七位：SF" class="headerlink" title="第七位：SF"></a>第七位：SF</h2><p>sign flag<br>符号标志位<br>结果是否为负，只看第一位符号位</p>
<h2 id="第零位：CF"><a href="#第零位：CF" class="headerlink" title="第零位：CF"></a>第零位：CF</h2><p>carry flag<br>进位标识符<br>是否有进位或者借位<br><strong>inc和loop不影响CF位</strong></p>
<h2 id="第十一位：OF"><a href="#第十一位：OF" class="headerlink" title="第十一位：OF"></a>第十一位：OF</h2><p>overflow flag<br>溢出标志位</p>
<h2 id="adc指令"><a href="#adc指令" class="headerlink" title="adc指令"></a>adc指令</h2><p>带进位的加法指令add carry<br>adc a,b<br>相当于a = a + b + cf<br>作用：</p>
<pre><code>add ax,bx

相当于

add al,bl
adc ah,bh
</code></pre><h2 id="sbb指令"><a href="#sbb指令" class="headerlink" title="sbb指令"></a>sbb指令</h2><p>带借位的减法指令sub borrow<br>sbb a,b<br>相当于a = a - b - CF</p>
<h2 id="CMP指令"><a href="#CMP指令" class="headerlink" title="CMP指令"></a>CMP指令</h2><p>相当于减法，但不保存结果，只会影响标志寄存器CF和ZF  </p>
<h3 id="检测比较结果的条件转移指令"><a href="#检测比较结果的条件转移指令" class="headerlink" title="检测比较结果的条件转移指令"></a>检测比较结果的条件转移指令</h3><p>和CMP配合使用</p>
<ol>
<li>je    equal</li>
<li>jne    not equal</li>
<li>jb    below</li>
<li>jnb    not below</li>
<li>ja    above</li>
<li>jna    not above</li>
</ol>
<h2 id="第十位：DF标志和串的传送"><a href="#第十位：DF标志和串的传送" class="headerlink" title="第十位：DF标志和串的传送"></a>第十位：DF标志和串的传送</h2><p>DF direcition(down?) flag<br>格式：movsb  （mov string byte？）<br>功能：复制一段数据？差不多，主要就是执行以下操作  </p>
<ol>
<li>((es)*16+di) = ((ds)*16+si)  </li>
<li>若df = 0:   si++; di++  </li>
<li>若df = 1:   si–; di–</li>
</ol>
<p>上面的是传一个内存单元，也可以传一个字<br>格式：movsw  （mov string word？）  </p>
<ol>
<li>mov word ptr es:[di],ds:[si](并不支持这样的指令，只是描述)  </li>
<li>若df = 0:   si+=2; di+=2  </li>
<li>若df = 1:   si-=2; di-=2</li>
</ol>
<p>可以配合rep使用，rep就是重复cx次当前指令，例如</p>
<pre><code>rep mov sb

相当于

s:
    movsb
    loop s
</code></pre><p>这样就可以实现cx个字符的传送  </p>
<h3 id="设置DF的指令"><a href="#设置DF的指令" class="headerlink" title="设置DF的指令"></a>设置DF的指令</h3><ol>
<li>cld：将DF设置为零（clear df）</li>
<li>std：将DF设置为一 (set df)</li>
</ol>
<h2 id="pushf和popf"><a href="#pushf和popf" class="headerlink" title="pushf和popf"></a>pushf和popf</h2><p>标志寄存器的出入栈</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;汇编语言第十一章：标志寄存器&quot;&gt;&lt;a href=&quot;#汇编语言第十一章：标志寄存器&quot; class=&quot;headerlink&quot; title=&quot;汇编语言第十一章：标志寄存器&quot;&gt;&lt;/a&gt;汇编语言第十一章：标志寄存器&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;标志寄存器就是CP
    
    </summary>
    
      <category term="汇编语言" scheme="http://ranxb.cn/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="笔记" scheme="http://ranxb.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="汇编语言" scheme="http://ranxb.cn/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言第十章：CALL和RET指令</title>
    <link href="http://ranxb.cn/2018/01/04/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AC%AC%E5%8D%81%E7%AB%A0%EF%BC%9ACALL%E5%92%8CRET%E6%8C%87%E4%BB%A4/"/>
    <id>http://ranxb.cn/2018/01/04/汇编语言第十章：CALL和RET指令/</id>
    <published>2018-01-04T15:33:06.000Z</published>
    <updated>2018-01-04T16:27:28.652Z</updated>
    
    <content type="html"><![CDATA[<h1 id="汇编语言第十章：CALL和RET指令"><a href="#汇编语言第十章：CALL和RET指令" class="headerlink" title="汇编语言第十章：CALL和RET指令"></a>汇编语言第十章：CALL和RET指令</h1><blockquote>
<p>都是修改ip的，重点不多，会用就行，随便写写。</p>
</blockquote>
<h2 id="ret和retf"><a href="#ret和retf" class="headerlink" title="ret和retf"></a>ret和retf</h2><p><strong>ret进行近转移，只修改IP</strong><br><strong>retf进行远转移，修改IP和CS</strong>  </p>
<h3 id="ret指令的操作"><a href="#ret指令的操作" class="headerlink" title="ret指令的操作"></a>ret指令的操作</h3><p><strong>出栈操作</strong>  </p>
<ol>
<li>(IP) = ((ss)*16+sp)  </li>
<li>(sp) = (sp)+2<br>相当于pop IP</li>
</ol>
<h3 id="retf指令的操作"><a href="#retf指令的操作" class="headerlink" title="retf指令的操作"></a>retf指令的操作</h3><p><strong>先出ip，再出cs</strong>  </p>
<ol>
<li>(IP) = ((ss)*16+sp)  </li>
<li>(sp) = (sp)+2  </li>
<li>(CS) = ((ss)*16+sp)  </li>
<li>(sp) = (sp)+2<br>相当于pop ip；pop cs</li>
</ol>
<h2 id="CALL指令"><a href="#CALL指令" class="headerlink" title="CALL指令"></a>CALL指令</h2><blockquote>
<p>两步操作  </p>
<ol>
<li>IP或CS和IP压入栈  </li>
<li>转移</li>
</ol>
</blockquote>
<p>(CALL的转移位移是16位的，也就是短转移，不支持近转移)</p>
<h3 id="根据位移进行转移的CALL指令"><a href="#根据位移进行转移的CALL指令" class="headerlink" title="根据位移进行转移的CALL指令"></a>根据位移进行转移的CALL指令</h3><p><strong>先压栈，在转移</strong>  </p>
<ol>
<li>(sp) = (sp)-2  </li>
<li>((ss)*16+sp) = ip  </li>
<li>ip转移  </li>
</ol>
<p>格式：CALL 标号  </p>
<h3 id="根据目的地址转移的CALL指令"><a href="#根据目的地址转移的CALL指令" class="headerlink" title="根据目的地址转移的CALL指令"></a>根据目的地址转移的CALL指令</h3><p>格式： </p>
<pre><code>call far prt 标号
</code></pre><p>实现的是段间转移<br>执行此命令时进行如下操作：  </p>
<ol>
<li>push CS</li>
<li>push IP</li>
<li>CS：IP转移</li>
</ol>
<h3 id="地址在寄存器中的CALL指令"><a href="#地址在寄存器中的CALL指令" class="headerlink" title="地址在寄存器中的CALL指令"></a>地址在寄存器中的CALL指令</h3><p>格式： call 16位的reg<br>例如： call ax<br>相当于：<br>push ip<br>jmp ax</p>
<h3 id="转移地址在内存中的CALL指令"><a href="#转移地址在内存中的CALL指令" class="headerlink" title="转移地址在内存中的CALL指令"></a>转移地址在内存中的CALL指令</h3><h4 id="CALL-WORD-PRT-地址"><a href="#CALL-WORD-PRT-地址" class="headerlink" title="CALL WORD PRT 地址"></a>CALL WORD PRT 地址</h4><p>两个字节16位，只转移IP</p>
<h4 id="CALL-DWOERD-PRT-地址"><a href="#CALL-DWOERD-PRT-地址" class="headerlink" title="CALL DWOERD PRT 地址"></a>CALL DWOERD PRT 地址</h4><p>四个字节32位，转移CS和IP</p>
<h2 id="RET和CALL的配合使用"><a href="#RET和CALL的配合使用" class="headerlink" title="RET和CALL的配合使用"></a>RET和CALL的配合使用</h2><p>当正常函数用，没什么区别<br>要先push 前面用到的寄存器的值<br>前面CALL，后面RET</p>
<h2 id="MUL指令"><a href="#MUL指令" class="headerlink" title="MUL指令"></a>MUL指令</h2><p>乘法指令，和除法指令类似，只是要不都是8位的，要不都是16位的。  </p>
<h3 id="8位的"><a href="#8位的" class="headerlink" title="8位的"></a>8位的</h3><p>AL放一个，然后MUL一个8位的内存单元，结果放在AX里面<br>如100*10:  </p>
<pre><code>mov al,100
mov bl,10
mul bl
</code></pre><p>最后结果在AX里<br>或者mul一个内存单元，还是例如：</p>
<pre><code>mov al,100
mov ds:[0],10
mul byte ptr ds:[0]
</code></pre><h3 id="16位的"><a href="#16位的" class="headerlink" title="16位的"></a>16位的</h3><p>AX放一个，然后MUL一个16位寄存器或者内存单元，结果高位在DX里，低位在AX里。<br>例如1000*10：</p>
<pre><code>mov ax,1000
mov bx,10
mul bx
</code></pre><p>结果换成16进制，高位在DX里，低位在AX里。</p>
<p><strong>除法在第八章</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;汇编语言第十章：CALL和RET指令&quot;&gt;&lt;a href=&quot;#汇编语言第十章：CALL和RET指令&quot; class=&quot;headerlink&quot; title=&quot;汇编语言第十章：CALL和RET指令&quot;&gt;&lt;/a&gt;汇编语言第十章：CALL和RET指令&lt;/h1&gt;&lt;blockquo
    
    </summary>
    
      <category term="汇编语言" scheme="http://ranxb.cn/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="笔记" scheme="http://ranxb.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="汇编语言" scheme="http://ranxb.cn/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>数字电路第五章：集成双稳态触发器</title>
    <link href="http://ranxb.cn/2018/01/04/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9A%E9%9B%86%E6%88%90%E5%8F%8C%E7%A8%B3%E6%80%81%E8%A7%A6%E5%8F%91%E5%99%A8/"/>
    <id>http://ranxb.cn/2018/01/04/数字电路第五章：集成双稳态触发器/</id>
    <published>2018-01-04T11:31:33.000Z</published>
    <updated>2018-01-04T14:53:13.378Z</updated>
    
    <content type="html"><![CDATA[<h1 id="集成双稳态触发器"><a href="#集成双稳态触发器" class="headerlink" title="集成双稳态触发器"></a>集成双稳态触发器</h1><blockquote>
<p>主要内容有  </p>
<ol>
<li>触发器的特点及分类  </li>
<li>基本的RS触发器  </li>
<li>事中控制的RS触发器，D触发器，JK触发器，T触发器的电路结构、逻辑功能及其描述方法。  </li>
<li>触发器的性能参数。  </li>
</ol>
</blockquote>
<h2 id="触发器的基本特点及分类"><a href="#触发器的基本特点及分类" class="headerlink" title="触发器的基本特点及分类"></a>触发器的基本特点及分类</h2><h3 id="输入量和输出量的设置"><a href="#输入量和输出量的设置" class="headerlink" title="输入量和输出量的设置"></a>输入量和输出量的设置</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="a.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>  
<p>s0和R0代表初始状态预置输入量，X1和X2是正常工作的时候的输入量，Q为输出量，要求有两个相反的所以叫Q和非Q。<br>钟控式的再加一个CP为时钟控制输入量。  </p>
<h3 id="触发器输出与约束方程的一般表达式"><a href="#触发器输出与约束方程的一般表达式" class="headerlink" title="触发器输出与约束方程的一般表达式"></a>触发器输出与约束方程的一般表达式</h3><p><strong>设触发器输出次态的取值记作Qn+1，现态取值记Qn</strong><br>触发器正常时要求R0 = S0 = 1！。  </p>
<h3 id="触发器的分类"><a href="#触发器的分类" class="headerlink" title="触发器的分类"></a>触发器的分类</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="b.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h2 id="基本RS双稳态触发器及其分析"><a href="#基本RS双稳态触发器及其分析" class="headerlink" title="基本RS双稳态触发器及其分析"></a>基本RS双稳态触发器及其分析</h2><blockquote>
<p>本RS触发器是各种触发器电路中结构形式最简单的一种。同时，它又是复杂电路结构触发器的一个基本组成都分。</p>
</blockquote>
<h3 id="RS型（set-reset）的电路结构和基本原理"><a href="#RS型（set-reset）的电路结构和基本原理" class="headerlink" title="RS型（set reset）的电路结构和基本原理"></a>RS型（set reset）的电路结构和基本原理</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="c.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>习惯上将电路画成图5-4(b)的对称形式。<br>Q和Q称为输出端，并且定义Q=1、Q=0为触发器的1状态， Q=0、Q=1为触发器的0状态。<br><strong>S为置位端或置1输入端，R成为复位端或置0输入端。</strong><br>(1)当S=1，R=0时，Q=1,非Q=0。<br>(2)当S=0，R=1时，Q=0,非Q=1。<br>(3)当S=R=0时，电路维持原来状态不变。<br>(4)当S=R=1时，Q = 非Q= 0，既不是定义的1状态， 也不是定义的0状态。<br>真值表如下<br><img src="d.png" alt=""><br>输入信号在S或R为1的全部作用时间里， 都能直接改变输出端Q和Q的状态，这就是基本RS触发器的工作特点。<br>这个缘故，<strong>也把S(非S)叫做直接置位端; 把R(非R)叫做直接复位端</strong></p>
<h2 id="时钟RS触发器及其分析"><a href="#时钟RS触发器及其分析" class="headerlink" title="时钟RS触发器及其分析"></a>时钟RS触发器及其分析</h2><p>触发器翻转的状态仍由输入控制端的电平情况决定，但翻转的时刻应由统一的脉冲信号来进行控制，这类控制信号称为<strong>时钟脉冲</strong>，CP (Clock Pulse)表示。<br>这类触发器成为<strong>同步触发器</strong></p>
<h3 id="时钟RS触发器结构与工作特性"><a href="#时钟RS触发器结构与工作特性" class="headerlink" title="时钟RS触发器结构与工作特性"></a>时钟RS触发器结构与工作特性</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="e.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>真值表如下（即为只有CP为一时即触发）<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="f.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>一般在使用同步触发器时，有时还需要在cp信号来之前将触发器预置成指定状态，所以可能会出现专门的异步置位输入端S和异步复位输入端R，使触发器置于指定状态。</p>
<h4 id="空翻现象"><a href="#空翻现象" class="headerlink" title="空翻现象"></a>空翻现象</h4><p>如果CP=1的期间内输入信号多次发生变化，则触发器的状态也会发生多次翻转，这就降低了电路的抗干扰能力，也叫“空翻”现象。</p>
<h3 id="主从触发器"><a href="#主从触发器" class="headerlink" title="主从触发器"></a>主从触发器</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="g.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p><strong>主从RS触发器动作特点</strong>：<br>主从RS触发器的动作分两步完成。<br>先在CP=1期间，主触发器接收输入驱动RS信号进行主触发器的状态修改，但从触发器不动作。<br>第二步，在CP=0时刻，从触发器按照此时主触发器的状态进行动作。</p>
<p>主从RS触发器解决了空翻问题，但在CP=1期间，RS仍存在约束条件。<br><strong>RS = 0 (约束条件）</strong><br>特征表如下：<br><img src="h.png" alt=""></p>
<h2 id="时钟D触发器及其分析"><a href="#时钟D触发器及其分析" class="headerlink" title="时钟D触发器及其分析"></a>时钟D触发器及其分析</h2><h3 id="电路结构与工作原理"><a href="#电路结构与工作原理" class="headerlink" title="电路结构与工作原理"></a>电路结构与工作原理</h3><p>为了适用于单端输入信号的场合，在有些集成电路中也把同步RS触发器作成下图的结构形式 通常把这种电路叫D型触发器(或D型锁存器)。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="i.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<h3 id="逻辑功能及其描述方法"><a href="#逻辑功能及其描述方法" class="headerlink" title="逻辑功能及其描述方法"></a>逻辑功能及其描述方法</h3><h4 id="功能真值表和激励表"><a href="#功能真值表和激励表" class="headerlink" title="功能真值表和激励表"></a>功能真值表和激励表</h4><p>RS触发器演变而来，它克服了RS触发器在 S=R=1时，次态不定的功能不完善缺点。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="j.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<h4 id="D触发器的空翻"><a href="#D触发器的空翻" class="headerlink" title="D触发器的空翻"></a>D触发器的空翻</h4><p>D触发器依然存在“空翻”现象，实际广泛使用的集成D触 发器采用了维持阻塞结构，称为<strong>维持阻塞D触发器。</strong><br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="k.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<p><strong>维持阻塞D触发器状态变化产升在时钟脉冲的上升沿，其次态决定于该时刻前瞬间输入信号D。</strong></p>
<h2 id="时钟JK触发器及其分析"><a href="#时钟JK触发器及其分析" class="headerlink" title="时钟JK触发器及其分析"></a>时钟JK触发器及其分析</h2><p>为了消除时钟控制RS 触发器输入信号的约束条件，又使触发器有两个输入端，可在时钟控制RS触发器中增加两条交叉反馈线，并将输入端S改为J，R改为K。<br><img src="l.png" alt=""></p>
<h3 id="逻辑功能及其描述方法-1"><a href="#逻辑功能及其描述方法-1" class="headerlink" title="逻辑功能及其描述方法"></a>逻辑功能及其描述方法</h3><p>功能真值表和激励表<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="m.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>特征方程：<br>  Qn+1 = J 非Q + 非k Q</p>
<h3 id="主从集成JK触发器"><a href="#主从集成JK触发器" class="headerlink" title="主从集成JK触发器"></a>主从集成JK触发器</h3><p>和RS触发差不多</p>
<h2 id="时钟T触发器及其分析"><a href="#时钟T触发器及其分析" class="headerlink" title="时钟T触发器及其分析"></a>时钟T触发器及其分析</h2><p>T触发器可看成是JK触发器在J=K条件下的特例<br>T触发器的逻辑功能可概括为：T=0时触发器保持原状太不变；T=1时触发器翻转。  </p>
<p><img src="n.png" alt=""></p>
<h2 id="特征方程总结"><a href="#特征方程总结" class="headerlink" title="特征方程总结"></a>特征方程总结</h2><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="o.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;集成双稳态触发器&quot;&gt;&lt;a href=&quot;#集成双稳态触发器&quot; class=&quot;headerlink&quot; title=&quot;集成双稳态触发器&quot;&gt;&lt;/a&gt;集成双稳态触发器&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;主要内容有  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;触发器的特点及分类  &lt;
    
    </summary>
    
      <category term="数字电路" scheme="http://ranxb.cn/categories/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"/>
    
    
      <category term="数字电路" scheme="http://ranxb.cn/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"/>
    
      <category term="笔记" scheme="http://ranxb.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>数字电路电路板汇总</title>
    <link href="http://ranxb.cn/2018/01/04/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E7%94%B5%E8%B7%AF%E6%9D%BF%E6%B1%87%E6%80%BB/"/>
    <id>http://ranxb.cn/2018/01/04/数字电路电路板汇总/</id>
    <published>2018-01-04T03:22:16.000Z</published>
    <updated>2018-01-06T09:16:16.377Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数字电路电路板汇总"><a href="#数字电路电路板汇总" class="headerlink" title="数字电路电路板汇总"></a>数字电路电路板汇总</h1><h2 id="变量译码器74138"><a href="#变量译码器74138" class="headerlink" title="变量译码器74138"></a>变量译码器74138</h2><p>三输入、八输出。<br>s1为一，s2和s3为零即可正常工作。<br>根据二进制输入输出十进制的特定端口。<br>两个同时使用的时候，低位s1接1，s2接高位s1作为输入的第四端口。如图<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="a.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<h2 id="7448显示译码器"><a href="#7448显示译码器" class="headerlink" title="7448显示译码器"></a>7448显示译码器</h2><h2 id="TS547显示器"><a href="#TS547显示器" class="headerlink" title="TS547显示器"></a>TS547显示器</h2><h2 id="数据选择器74LS153"><a href="#数据选择器74LS153" class="headerlink" title="数据选择器74LS153"></a>数据选择器74LS153</h2><p>针脚如图所示<br><img src="b.png" alt=""><br>真值表如图所示<br><img src="c.png" alt=""><br>做题时会给多个输入端，此时想A0A1当成两个输入端，再从D端口中根据选择器的输出表达式连接相应第三段口即可，例如：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="d.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="e.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="f.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>  </p>
<h2 id="多位数值比较器7485"><a href="#多位数值比较器7485" class="headerlink" title="多位数值比较器7485"></a>多位数值比较器7485</h2><p>下图为数值比较器7485的单位针脚图<br><img src="g.png" alt=""><br>下图为用多个数值比较器7485的多位数值比较器的基本原理<br><img src="h.png" alt="">  </p>
<h2 id="奇偶校验器74LS280"><a href="#奇偶校验器74LS280" class="headerlink" title="奇偶校验器74LS280"></a>奇偶校验器74LS280</h2><p>四位二进制奇偶校验的真值表<br><img src="i.png" alt=""><br>奇偶校验位逻辑表达式<br><img src="j.png" alt=""></p>
<p>74LS280奇偶校验/发生器<br><img src="k.png" alt="">  </p>
<p>实际应用如下    </p>
<p><img src="l.png" alt="">  </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数字电路电路板汇总&quot;&gt;&lt;a href=&quot;#数字电路电路板汇总&quot; class=&quot;headerlink&quot; title=&quot;数字电路电路板汇总&quot;&gt;&lt;/a&gt;数字电路电路板汇总&lt;/h1&gt;&lt;h2 id=&quot;变量译码器74138&quot;&gt;&lt;a href=&quot;#变量译码器74138&quot; cla
    
    </summary>
    
      <category term="数字电路" scheme="http://ranxb.cn/categories/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"/>
    
    
      <category term="数字电路" scheme="http://ranxb.cn/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"/>
    
      <category term="笔记" scheme="http://ranxb.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>汇编第九章：转移指令的原理</title>
    <link href="http://ranxb.cn/2017/12/30/%E6%B1%87%E7%BC%96%E7%AC%AC%E4%B9%9D%E7%AB%A0%EF%BC%9A%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <id>http://ranxb.cn/2017/12/30/汇编第九章：转移指令的原理/</id>
    <published>2017-12-30T09:41:24.000Z</published>
    <updated>2017-12-30T13:30:04.582Z</updated>
    
    <content type="html"><![CDATA[<h1 id="汇编第九章：转移指令的原理"><a href="#汇编第九章：转移指令的原理" class="headerlink" title="汇编第九章：转移指令的原理"></a>汇编第九章：转移指令的原理</h1><blockquote>
<p>概括地讲，转移指令就是可以控制CPU执行内存中某处代码的指令。<br>表现为可以修改IP或者同时修改CS和IP的指令。</p>
</blockquote>
<p>以下讨论8086<br><strong><em>转移行为的分类</em></strong><br><strong>第一类：只修改IP的转移行为叫做段内转移</strong>  </p>
<blockquote>
<p>根据转一指令对IP的修改范围不同，段内转移可分为。  </p>
</blockquote>
<ol>
<li>短转移：IP的修改范围为-128 ～ 127.</li>
<li>近转移：IP的修改范围为-32768 ～ 32767.</li>
</ol>
<p><strong>第二类：同时修改CS和IP的转移行为叫段间转移</strong>   </p>
<p><strong><em>转一指令的分类</em></strong> </p>
<ol>
<li>无条件转移指令，例如jmp  </li>
<li>条件转移指令  </li>
<li>循环指令，例如loop  </li>
<li>过程  </li>
<li>中断  </li>
</ol>
<p>本章主要通过深入学习无条件转移指令jmp来理解CPU执行转移指令的基本原理  </p>
<h2 id="offset"><a href="#offset" class="headerlink" title="offset"></a>offset</h2><p><strong>功能是取得标号地址的偏移地址</strong></p>
<pre><code>code segment
start:
    mov ax,offset start        ;相当于mov ax,0
s:
    mov ax,offset s            ;相当于mov ax,3                                    
</code></pre><h2 id="jmp"><a href="#jmp" class="headerlink" title="jmp"></a>jmp</h2><p>jmp为无条件跳转指令，可以只修改IP，也可以同时修改CS和IP。<br>jmp指令要给出两种信息：  </p>
<ol>
<li>转移的目的地址  </li>
<li>转移的距离（段间转移、段内转移、段内近转移）</li>
</ol>
<h3 id="依据位移进行转移的jmp指令"><a href="#依据位移进行转移的jmp指令" class="headerlink" title="依据位移进行转移的jmp指令"></a>依据位移进行转移的jmp指令</h3><p>NO.1</p>
<pre><code>jmp short 标号（转到标号处执行指令）
</code></pre><p>这种格式实现的事段内短转移，他对IP的修改范围是-128 ～ 127，转移指令结束后，CS:IP应该指向标号指令。  </p>
<p>根据机器码可得出<strong>CPU执行jmp指令时机器码中并不需要转移的目的地址</strong>  </p>
<blockquote>
<p>CPU执行指令的过程  </p>
<ol>
<li>从CS:IP执行内存单元读取指令，读取的指令进入指令缓冲器;  </li>
<li>(IP) = (IP) + 读取的长度，从而指向下一个指令;  </li>
<li>执行指令。转到(1)，重复.</li>
</ol>
</blockquote>
<p>由此可得，执行jmp并不需要目的地址，而是需要<strong>位移地址</strong><br>short的位移量存储空间占一个字节，8个二进制位，首位为符号位，用补码表示，因此可表示的位移量为-128 ～ 127。<br>同理，near的位移量储存空间占两个字节，16个二进制位，首位为符号位，用补码表示，因此可表示的位移量为-32768 ～ 32767。</p>
<p>由上引入近转移</p>
<pre><code>jmp near ptr 标号（段内近转移）
</code></pre><h3 id="转移的目的地址在指令中的jmp指令"><a href="#转移的目的地址在指令中的jmp指令" class="headerlink" title="转移的目的地址在指令中的jmp指令"></a>转移的目的地址在指令中的jmp指令</h3><p>前面讲的是段内转移，因此jmp只需要位移地址即可进行对IP的修改。</p>
<pre><code>jmp far ptr 标号
</code></pre><p>以上实现的是段间转移，又称远转移。可以让(CS) = 标号所在的段地址;(IP) = 标号所在的偏移地址。</p>
<h3 id="转移地址在寄存器中的jmp指令"><a href="#转移地址在寄存器中的jmp指令" class="headerlink" title="转移地址在寄存器中的jmp指令"></a>转移地址在寄存器中的jmp指令</h3><pre><code>jmp 16位reg
</code></pre><p>功能：(IP) = (16位reg)<br>用寄存器中的值修改IP。</p>
<h3 id="转移地址在内存中的jmp指令"><a href="#转移地址在内存中的jmp指令" class="headerlink" title="转移地址在内存中的jmp指令"></a>转移地址在内存中的jmp指令</h3><blockquote>
<p>两种格式  </p>
</blockquote>
<p><strong>段内转移</strong></p>
<pre><code>jmp word ptr 内存单元地址 ;(段内转移)
</code></pre><p>从内存单元地址处开始存放着一个字，是转移的目的的偏移地址。<br>例如：</p>
<pre><code>mov ax,0123H
mov ds:[0],ax
jmp word ptr ds:[0]
</code></pre><p>执行后(IP) = 0123H </p>
<p><strong>段间转移</strong></p>
<pre><code>jmp dword ptr 内存单元地址  ;(段间转移)
</code></pre><p>从内存单元地址处开始存放着两个字节，是转移的目的的段地址和偏移地址，<strong>高地址是段地址</strong>，<strong>低地址是偏移地址</strong><br>(CS) = 内存单元地址+2<br>(IP) = 内存单元地址<br>比如一下指令：  </p>
<pre><code>mov ax,0123H
mov ds:[0],ax
mov ax,4567H
mov ds:[2],ax
jmp dword ptr ds:[0]
</code></pre><p>执行完后(CS) = 4567H,(IP) = 0123H。 </p>
<h2 id="jcxz指令"><a href="#jcxz指令" class="headerlink" title="jcxz指令"></a>jcxz指令</h2><p>jcxz是有条件转移指令，<strong>所有的有条件转移指令都是短转移指令</strong>，对应的机器码中包含的是转移位移，不是目的地址。对IP的修改范围都是-128 ~ 127。</p>
<p><strong>jcxz == jmp when cx is zero</strong><br>当cx为零时，执行转移指令，若不为零，则不转移<br>使用格式：</p>
<pre><code>jcxz 标号
</code></pre><h2 id="loop指令"><a href="#loop指令" class="headerlink" title="loop指令"></a>loop指令</h2><p>loop指令位循环指令，所有的循环指令都是短转移。<br><strong>详见第五章</strong></p>
<h2 id="根据位移进行转移的意义"><a href="#根据位移进行转移的意义" class="headerlink" title="根据位移进行转移的意义"></a>根据位移进行转移的意义</h2><pre><code>jmp short x
jmp near ptr x
jcxz x
loop
</code></pre><p>以上都是根据转移的位移量进行转移的，这样有利于程序在内存中的浮动装配，意思就是把这段程序装在内存中的任意一段空间内都可以执行，不会因为转移的地址不同而导致程序不能执行。</p>
<h2 id="编译器对转移位移超界的检测"><a href="#编译器对转移位移超界的检测" class="headerlink" title="编译器对转移位移超界的检测"></a>编译器对转移位移超界的检测</h2><p><strong>jmp超界编译器会报错</strong>，别的没其他知识点</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;汇编第九章：转移指令的原理&quot;&gt;&lt;a href=&quot;#汇编第九章：转移指令的原理&quot; class=&quot;headerlink&quot; title=&quot;汇编第九章：转移指令的原理&quot;&gt;&lt;/a&gt;汇编第九章：转移指令的原理&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;概括地讲，转移指令就是可以
    
    </summary>
    
      <category term="汇编语言" scheme="http://ranxb.cn/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="笔记" scheme="http://ranxb.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="汇编语言" scheme="http://ranxb.cn/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>汇编第八章：数据处理的两个基本问题</title>
    <link href="http://ranxb.cn/2017/12/29/%E6%B1%87%E7%BC%96%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98/"/>
    <id>http://ranxb.cn/2017/12/29/汇编第八章：数据处理的两个基本问题/</id>
    <published>2017-12-28T19:23:25.000Z</published>
    <updated>2017-12-30T09:40:34.461Z</updated>
    
    <content type="html"><![CDATA[<h1 id="汇编第八章：数据处理的两个基本问题"><a href="#汇编第八章：数据处理的两个基本问题" class="headerlink" title="汇编第八章：数据处理的两个基本问题"></a>汇编第八章：数据处理的两个基本问题</h1><blockquote>
<p>章前言说的是对前面所有的内容是有总结性的，这里主要探讨两个问题：  </p>
<ol>
<li>处理的数据在什么地方？  </li>
<li>处理的数据有多长？</li>
</ol>
</blockquote>
<p>定义两个符号<strong>reg</strong>和<strong>sreg</strong><br><strong>reg</strong>代表寄存器，包括：ax,bx,cx,dx,ah,al,bh,bl,ch,cl,dh,dl,sp,bp,si,di<br><strong>sreg</strong>代表段寄存器，包括：ds,ss,cs,es</p>
<h2 id="bx、si、di、bp的使用规则"><a href="#bx、si、di、bp的使用规则" class="headerlink" title="bx、si、di、bp的使用规则"></a>bx、si、di、bp的使用规则</h2><blockquote>
<p>三个规则，一会总结，字比较多，等会打。</p>
</blockquote>
<ol>
<li><p>只有这四个寄存器可以用在[…]中进行寻址  </p>
<pre><code>mov ax,[bx]
mov ax,[bx+si]
</code></pre><p>以下的是错误的</p>
<pre><code>mov ax,[cx]
mov ax,[ax]
</code></pre></li>
<li><p>这四个可以单独出现，但是组合的情况只有四种可以使用：bx和si、bx和di、bp和si、bp和di。  </p>
<pre><code>mov ax,[bx+si]
mov ax,[bx+di]
mov ax,[bp+si]
mov ax,[bp+di+idata]
</code></pre><p>以下的是错误的</p>
<pre><code>mov ax.[bx+dp]
mov ax,[si+di]
</code></pre></li>
<li><p>只要使用[…]中bp寄存器时，若没有显式的给出段寄存器，则默认为段地址在ss中</p>
<pre><code>mov ax,[bp]             ;(ax) = ((ss)*16+(bp))
</code></pre></li>
</ol>
<h2 id="机器指令处理的数据在什么地方"><a href="#机器指令处理的数据在什么地方" class="headerlink" title="机器指令处理的数据在什么地方"></a>机器指令处理的数据在什么地方</h2><p>机器指令都是经过处理过的数据：1、读取。2、存入。3、运行  </p>
<p>所有处理的数据可以在三个地方：CPU内部、内存、端口（后面说先不用管）<br>例如：</p>
<pre><code>mov bx,[0]                ;内存
mov bx,ax                ;CPU内部ax寄存器
mov bx,1                ;CPU内部指令缓冲器
</code></pre><h2 id="汇编语言中数据位置的表达"><a href="#汇编语言中数据位置的表达" class="headerlink" title="汇编语言中数据位置的表达"></a>汇编语言中数据位置的表达</h2><p>汇编语言用3个概念来表达数据的位置：  </p>
<ol>
<li><p>立即数[idata]<br>例如：</p>
<p> mov ax,1<br> add bx,2000H<br> or bx,00010000B<br> mov al,’a’</p>
</li>
</ol>
<p>以上   </p>
<ol>
<li><p>寄存器<br>例如</p>
<p> mov ax,bx<br> push ds<br>以上  </p>
</li>
<li><p>段地址和偏移地址<br>例如</p>
<p> mov ax,[bx]            ;段地址默认在ds中</p>
</li>
</ol>
<h2 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h2><p><strong>五种寻址方式：</strong>  </p>
<ol>
<li>[idata] <strong>直接寻址</strong>  </li>
<li>[bx] <strong>寄存器间接寻址</strong>  </li>
<li>[bx+idata] <strong>寄存器相对寻址</strong>  </li>
<li>[bx+si] <strong>基址变址寻址</strong>  </li>
<li>[bx+si+idata] <strong>相对基址变址寻址</strong></li>
</ol>
<p>总结：<strong>有两个寄存器就是基址变址，只要有idata就是相对（只有idata是直接寻址，只有一个寄存器是寄存器间接寻址）</strong></p>
<h2 id="指令要处理的数据有多长"><a href="#指令要处理的数据有多长" class="headerlink" title="指令要处理的数据有多长"></a>指令要处理的数据有多长</h2><ol>
<li>通过寄存器名可以致命处理的数据长度</li>
<li><p>在没有寄存器的情况下，用操作符“X ptr”指明要操作的长度，X可以是byte或者是word。<br>例如</p>
<pre><code>mov word prt ds:[0],1
inc word prt [bx]

mov byte ptr ds:[0],1
add byte ptr [bx],2
</code></pre><h2 id="寻址的综合应用"><a href="#寻址的综合应用" class="headerlink" title="寻址的综合应用"></a>寻址的综合应用</h2><blockquote>
<p>主要就是类c语言的数组的操作，看看书看就行了。</p>
</blockquote>
</li>
</ol>
<h2 id="div"><a href="#div" class="headerlink" title="div"></a><strong>div</strong></h2><blockquote>
<p>两种div方式！(被除数是除号之前的。)</p>
</blockquote>
<ol>
<li>16位寄存器除以8位寄存器：16位做被除数放在AX里面。商在AL里，余数在AH里</li>
<li>32位寄存器除以16位寄存器：高16位放在DX，低16位放在AX里，共32位做被除数。商在AX里，余数在DX里。  </li>
</ol>
<p><strong>商都放在低位寄存器中，余数放在高位，除数放在一个内存单元或者reg中</strong><br>例如：</p>
<pre><code>16位/8位：
    div byte ptr ds:[0]        
    ;(al) = (ax)/((ds)*16+0)
    ;(ah) = (ax)mod((ds)*16+0)

32位/8位：
    div word ptr ds:[0]        
    ;(ax) = [(dx)*10000H + (ax)] / ((ds)*16+0)
    ;(dx) = [(dx)*10000H + (ax)] mod ((ds)*16+0)
</code></pre><p>实际应用，例如100001/100,100001 = 186A1H</p>
<pre><code>mov dx,1H
mov ax,86A1H
mov bx,100
div bx
;商在AX里，余数在DX里
</code></pre><h2 id="dd"><a href="#dd" class="headerlink" title="dd"></a>dd</h2><blockquote>
<p>dd（define double）,用于定义双精度字节，一个双精度占2个字，4个字节。</p>
</blockquote>
<pre><code>data segment
    db 1
    dw 1
    dd 1
data ends
</code></pre><p>上面这段：  </p>
<pre><code>1. 第一个数据是01H，在data:[0]处  
2. 第二个数据是0001H，在data:[1] - data:[2]处  
3. 第三个数据是00000001H，在data:[3] - data:[6]处  
</code></pre><h2 id="dup"><a href="#dup" class="headerlink" title="dup"></a>dup</h2><p>和dd一样都是一个操作符，它是和db、dw、dd等数据定义伪指令配合使用的，用来进行数据的重复，比如：</p>
<pre><code>db 3 dup (0)
</code></pre><p>定义了3个字节，他们的值都是0，相当于</p>
<pre><code>db 0,0,0
</code></pre><p>又例如：</p>
<pre><code>db 3 dup (0,1,2)
</code></pre><p>定义了9个字节，分别是0,1,2,0,1,2,0,1,2,相当于</p>
<pre><code>db 0,1,2,0,1,2,0,1,2
</code></pre><p><strong>使用规范如下</strong></p>
<pre><code>db 重复次数 dup (内容)        ;(重复的字节型数据)
dw 重复次数 dup (内容)        ;(重复的字型数据)
dd 重复次数 dup (内容)        ;(重复的双精度字型数据)
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;汇编第八章：数据处理的两个基本问题&quot;&gt;&lt;a href=&quot;#汇编第八章：数据处理的两个基本问题&quot; class=&quot;headerlink&quot; title=&quot;汇编第八章：数据处理的两个基本问题&quot;&gt;&lt;/a&gt;汇编第八章：数据处理的两个基本问题&lt;/h1&gt;&lt;blockquote&gt;

    
    </summary>
    
      <category term="汇编语言" scheme="http://ranxb.cn/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="笔记" scheme="http://ranxb.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="汇编语言" scheme="http://ranxb.cn/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>汇编第七章：更灵活的定位内存地址的方式</title>
    <link href="http://ranxb.cn/2017/12/29/%E6%B1%87%E7%BC%96%E7%AC%AC%E4%B8%83%E7%AB%A0%EF%BC%9A%E6%9B%B4%E7%81%B5%E6%B4%BB%E7%9A%84%E5%AE%9A%E4%BD%8D%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E7%9A%84%E6%96%B9%E5%BC%8F/"/>
    <id>http://ranxb.cn/2017/12/29/汇编第七章：更灵活的定位内存地址的方式/</id>
    <published>2017-12-28T18:46:40.000Z</published>
    <updated>2018-01-09T12:05:30.076Z</updated>
    
    <content type="html"><![CDATA[<h1 id="汇编第七章：更灵活的定位内存地址的方式"><a href="#汇编第七章：更灵活的定位内存地址的方式" class="headerlink" title="汇编第七章：更灵活的定位内存地址的方式"></a>汇编第七章：更灵活的定位内存地址的方式</h1><h2 id="and、or指令"><a href="#and、or指令" class="headerlink" title="and、or指令"></a>and、or指令</h2><p><strong>and</strong> 按位与 </p>
<pre><code>mov al,01100011B
and al,00111011B
</code></pre><p>结果为<strong><em>al = 00100011B</em></strong>    </p>
<p><strong>or</strong> 按位和  </p>
<pre><code>mov al,01100011B
or al,00111011B
</code></pre><p>结果为<strong><em>al = 01111011B</em></strong>  </p>
<h2 id="关于ASCII码"><a href="#关于ASCII码" class="headerlink" title="关于ASCII码"></a>关于ASCII码</h2><pre><code>data segment
    db &apos;unIX&apos;
data ends
</code></pre><p>相当于</p>
<pre><code>data segment
    db 75H,6EH,49H,58H
data ends
</code></pre><p>一个字母一个字节  </p>
<ol>
<li><strong>小写字母ASCII码比大写字母大</strong>  </li>
<li><strong>将’a’的ASCII码减20H就可以变成大写字母’A’</strong>  </li>
<li><strong>将’A’的ASCII码加20H就可以变成小写字母’a’</strong>  </li>
<li><strong>当ASCII码大于61H的时候是小写字母</strong>  </li>
<li><strong>ASCII码的二进制形式第六位为1时是小写字母，0时大写字母</strong>  </li>
</ol>
<blockquote>
<p>根据上面第五条可以进行大小写转换！  </p>
</blockquote>
<pre><code>and al,11011111B
</code></pre><p>可以把字母变成大写  </p>
<pre><code>or al,00100000B
</code></pre><p>可以把字母变成小写  </p>
<h2 id="bx-idata"><a href="#bx-idata" class="headerlink" title="[bx+idata]"></a>[bx+idata]</h2><p><strong><em>[bx+idata]表示一个内存单元,他的偏移地址是(bx)+idata(bx的值加上idata)</em></strong>  </p>
<blockquote>
<p>mov ax,[bx+200] == ax = ((dx)*16 + (bx) + 200)  </p>
</blockquote>
<p>该指令也可以写成</p>
<pre><code>mov ax,[200+bx]
mov ax,200[bx]
mov ax,[bx].200
</code></pre><p>因此，[bx+idata]的方式为高级语言实现数组提供了便利机制  </p>
<pre><code>C语言：a[i],b[i]
汇编语言：0[bx],5[bx]([bx+0],[bx+5])
</code></pre><h2 id="SI和DI"><a href="#SI和DI" class="headerlink" title="SI和DI"></a>SI和DI</h2><p><strong>SI和DI是8086中和bx相似的寄存器</strong>，但是不能像bx一样分成两个八位寄存器来使用<br>因此我们可以更灵活的使用：<strong><em>[bx+si]</em></strong>类似的方式表示一个内存一个内存单元<br>例如：</p>
<pre><code>mov ax,[bx+si]
</code></pre><p>意为(ax) = (dx*16) + (bx) + (si)<br>也可以写成</p>
<pre><code>mov ax,[bx][si]
</code></pre><h2 id="不同的寻址方式的灵活应用"><a href="#不同的寻址方式的灵活应用" class="headerlink" title="不同的寻址方式的灵活应用"></a>不同的寻址方式的灵活应用</h2><ol>
<li>[idata]用一个常量来表示地址，可用于直接定位一个内存</li>
<li>[bx]用一个变量来表示一个内存，可用于间接定位一个内存单元</li>
<li>[bx+idata]用一个变量和一个常量来表示内存地址，可在一个起始地址的基础上用变量简介定位一个内存，例如数组。</li>
<li>[bx+si]用两个变量表示一个内存地址</li>
<li>[bx+si+idata]用两个变量和一个常量表示一个内存地址</li>
</ol>
<h2 id="一道大题问题7-9（先复习，回头再写）"><a href="#一道大题问题7-9（先复习，回头再写）" class="headerlink" title="一道大题问题7.9（先复习，回头再写）"></a>一道大题问题7.9（先复习，回头再写）</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;汇编第七章：更灵活的定位内存地址的方式&quot;&gt;&lt;a href=&quot;#汇编第七章：更灵活的定位内存地址的方式&quot; class=&quot;headerlink&quot; title=&quot;汇编第七章：更灵活的定位内存地址的方式&quot;&gt;&lt;/a&gt;汇编第七章：更灵活的定位内存地址的方式&lt;/h1&gt;&lt;h2 i
    
    </summary>
    
      <category term="汇编语言" scheme="http://ranxb.cn/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="笔记" scheme="http://ranxb.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="汇编语言" scheme="http://ranxb.cn/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>现代第二章</title>
    <link href="http://ranxb.cn/2017/12/28/%E7%8E%B0%E4%BB%A3%E7%AC%AC%E4%BA%8C%E7%AB%A0/"/>
    <id>http://ranxb.cn/2017/12/28/现代第二章/</id>
    <published>2017-12-28T12:08:13.000Z</published>
    <updated>2017-12-28T19:34:15.439Z</updated>
    
    <content type="html"><![CDATA[<h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><h2 id="向量引入"><a href="#向量引入" class="headerlink" title="向量引入"></a>向量引入</h2><h3 id="线性相关无关性"><a href="#线性相关无关性" class="headerlink" title="线性相关无关性"></a>线性相关无关性</h3><h3 id="向量的秩"><a href="#向量的秩" class="headerlink" title="向量的秩"></a>向量的秩</h3><h2 id="矩阵的运算"><a href="#矩阵的运算" class="headerlink" title="矩阵的运算"></a>矩阵的运算</h2><pre><code>1）！*不可逆乘*
2）一个行 * 一个列 = 一个数
3）对角全为一的矩阵是单位矩阵计为E
4）单位矩阵相当于乘法中的1
5）任何矩阵与单位矩阵相乘都等于本身
6）若AB == BA ，则称AB是可交换的
7）矩阵的乘法不满足消除律
8）矩阵的转置计为A
9）（AB）t == Bt*At
10) (kA)t == kAt
11）如果At == A，那么这个矩阵式是对称的
12）如果At == -A，那么这个矩阵式是反对称的
13）对角矩阵是只有对角线上的矩阵，A = diag(a,b,c,d...)
14）对角矩阵的数都一样的时候是数量矩阵，全是一的时候单位矩阵。
</code></pre><h3 id="可交换矩阵-逆矩阵"><a href="#可交换矩阵-逆矩阵" class="headerlink" title="可交换矩阵(逆矩阵)"></a>可交换矩阵(逆矩阵)</h3><pre><code>可交换矩阵的充要条件：

(1) 设A , B 至少有一个为零矩阵,则A , B 可交换;
(2) 设A , B 至少有一个为单位矩阵, 则A , B可交换;
(3) 设A , B 至少有一个为数量矩阵, 则A , B可交换;
(4) 设A , B 均为对角矩阵,则A , B 可交换;
(5) 设A , B 均为准对角矩阵（准对角矩阵是分块矩阵概念下的一种矩阵。即除去主对角线上分块矩阵不为零矩阵外，其余分块矩阵均为零矩阵）,且对角线上的子块均可交换，则A , B 可交换;
(6) 设A*是A 的伴随矩阵,则A*与A可交换;
(7) 设A可逆,则A 与其逆矩阵可交换;
注：A的逆矩阵经过数乘变换所得到的矩阵也可以与A进行交换。
(8)（n=0,1...,   ）可与  (m=0,1...,   )交换.这一点由矩阵乘法的结合律证明。
</code></pre><p>求所有可交换矩阵</p>
<pre><code>求A的所有可交换矩阵，所以设AZ == ZA，Z = [a,b;c,d]，求出Z即可～
</code></pre><h2 id="矩阵的初等变化及其标准型"><a href="#矩阵的初等变化及其标准型" class="headerlink" title="矩阵的初等变化及其标准型"></a>矩阵的初等变化及其标准型</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;矩阵&quot;&gt;&lt;a href=&quot;#矩阵&quot; class=&quot;headerlink&quot; title=&quot;矩阵&quot;&gt;&lt;/a&gt;矩阵&lt;/h1&gt;&lt;h2 id=&quot;向量引入&quot;&gt;&lt;a href=&quot;#向量引入&quot; class=&quot;headerlink&quot; title=&quot;向量引入&quot;&gt;&lt;/a&gt;向量引入&lt;/h
    
    </summary>
    
      <category term="线性代数" scheme="http://ranxb.cn/categories/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
    
      <category term="笔记" scheme="http://ranxb.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="线性代数" scheme="http://ranxb.cn/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>汇编第六章：包含多个短的程序</title>
    <link href="http://ranxb.cn/2017/12/28/%E6%B1%87%E7%BC%96%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E5%8C%85%E5%90%AB%E5%A4%9A%E4%B8%AA%E7%9F%AD%E7%9A%84%E7%A8%8B%E5%BA%8F/"/>
    <id>http://ranxb.cn/2017/12/28/汇编第六章：包含多个短的程序/</id>
    <published>2017-12-28T12:07:59.000Z</published>
    <updated>2017-12-28T18:21:14.005Z</updated>
    
    <content type="html"><![CDATA[<h1 id="汇编第六章：包含多个短的程序"><a href="#汇编第六章：包含多个短的程序" class="headerlink" title="汇编第六章：包含多个短的程序"></a>汇编第六章：包含多个短的程序</h1><blockquote>
<p>dw  == define word  </p>
</blockquote>
<p>一个dw：<strong>16位两字节</strong>  </p>
<h2 id="start…end-start"><a href="#start…end-start" class="headerlink" title="start…end start"></a>start…end start</h2><p>如果程序入口不是我们想要执行的指令可以使用start指令指明程序入口所在  </p>
<pre><code>assume cs:code
code segment
        .
        .
        .
        dw 0123h,1456h;数据
        .
        .
        .
start:
        .
        .
        .
        mov ax,0;代码
        .
        .
        .
        mov ax,4c00H
        int 21H
code ends
end start
</code></pre><p><strong>一个段的容量不能大于64kb</strong><br>因此可以考虑使用多个段来存放数据、代码、和栈。<br><strong>stack</strong> == 栈  </p>
<blockquote>
<p>8086不允许将一个数值直接送入段寄存器，例如“mov ds,data”。data也会被编译器处理为表示一个段地址的数值  </p>
</blockquote>
<p>data、satck、code也仅仅是命名而已，就跟标号一样，需要用assume将他们和cpu联系起来<br>因此程序有以下模板  </p>
<pre><code>assume cs:code,ss:stack,ds:data

data segment
    dw ..........
data ends

stack segment
    dw 0,0,0,0,0,0.....
stack ends

code segment

    start:
        mov ax,data                ;数据段空间
        mov ds,ax
        mov bx,0

        mov ax,stack            ;栈空间
        mov ss,ax
        mov sp,0
        .
        .
        .
code ends

start end 
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;汇编第六章：包含多个短的程序&quot;&gt;&lt;a href=&quot;#汇编第六章：包含多个短的程序&quot; class=&quot;headerlink&quot; title=&quot;汇编第六章：包含多个短的程序&quot;&gt;&lt;/a&gt;汇编第六章：包含多个短的程序&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;dw  == de
    
    </summary>
    
      <category term="汇编语言" scheme="http://ranxb.cn/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="笔记" scheme="http://ranxb.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="汇编语言" scheme="http://ranxb.cn/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>汇编第五章 [BX]和loop指令</title>
    <link href="http://ranxb.cn/2017/12/28/%E6%B1%87%E7%BC%96%E7%AC%AC%E4%BA%94%E7%AB%A0-BX-%E5%92%8Cloop%E6%8C%87%E4%BB%A4/"/>
    <id>http://ranxb.cn/2017/12/28/汇编第五章-BX-和loop指令/</id>
    <published>2017-12-28T12:07:35.000Z</published>
    <updated>2017-12-28T19:33:59.114Z</updated>
    
    <content type="html"><![CDATA[<h1 id="汇编第五章-BX-和loop指令"><a href="#汇编第五章-BX-和loop指令" class="headerlink" title="汇编第五章 [BX]和loop指令"></a>汇编第五章 [BX]和loop指令</h1><p><strong>[bx]</strong>表示偏移地址<br><strong>ss:ip</strong>   表示栈段<br><strong>push ax</strong>的具体流程  </p>
<pre><code>push ax:
sp = sp - 2;
(ss:sp) = ax;
</code></pre><p><strong>pop ax</strong>的具体操作  </p>
<pre><code>pop ax:
ax = (ss:sp);
sp+=2;  
</code></pre><p><strong>inc ax</strong>  ax的内容加1  </p>
<p><strong>mov ax,2000H</strong>   其中ah = 20 al = 00  </p>
<pre><code>当
BE   21000H
00   21001H
.
.
.

mov ax,2100H;
mox dx,ax;
mov bx,0;
mov ax,[bx]

此时 ax = 00BE
</code></pre><p>！！意为先存低位，在存高位。  </p>
<h2 id="LOOP指令"><a href="#LOOP指令" class="headerlink" title="LOOP指令"></a>LOOP指令</h2><p><strong>LOOP执行顺序</strong></p>
<pre><code>LOOP执行顺序：
1.CX--;
2.CX==0?顺序执行:循环
</code></pre><p><strong>CX设置循环次数</strong></p>
<pre><code>  例如：
  mov cx,11
L:add ax,1
  LOOP L
</code></pre><p><strong>将ffff传入ax中的时候要前面加零</strong></p>
<pre><code>mov ax,0ffffH
mov dx,ax
.
.
.
</code></pre><p><strong>汇编语言程序中，数据不能以字母开头</strong></p>
<h2 id="DEBUG和汇编编译器MASM对指令的不同处理"><a href="#DEBUG和汇编编译器MASM对指令的不同处理" class="headerlink" title="DEBUG和汇编编译器MASM对指令的不同处理"></a>DEBUG和汇编编译器MASM对指令的不同处理</h2><p><strong>DEBUG中：</strong><br><em>mov al,[0]</em> ;含义：(al) = ((dx)<em>16+0)<br><strong>源程序中:</strong>     
</em>mov al,[0]* ;含义：(al) = 0  </p>
<blockquote>
<p>在源程序中，如果用指令访问一个内存单元，则在指令中必须用“[…]”来表示内存单元<br>，如果在“[]”里直接用一个常量idata直接给出内存单元的偏移地址，就要在”[]”的前面<br>显示的给出段地址所在的段寄存器。  </p>
</blockquote>
<p>例如：</p>
<pre><code>mov ax,dx:[0]
</code></pre><h2 id="段前缀"><a href="#段前缀" class="headerlink" title="段前缀"></a>段前缀</h2><p>以上这样的表示方法dx叫做<strong>段前缀</strong><br>类似的比如  </p>
<pre><code>mov ax,ds:[0]
mov ax,cx:[0]
mov ax,ss:[0]
mov ax,es:[0]
</code></pre><p>等等ds:、cx:、ss:、es:、都叫做段前缀  </p>
<h2 id="一段安全的空间"><a href="#一段安全的空间" class="headerlink" title="一段安全的空间"></a>一段安全的空间</h2><p>直接向内存中写入数据时，要用：<br><strong>0:200 ～ 0:2ff</strong>  </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;汇编第五章-BX-和loop指令&quot;&gt;&lt;a href=&quot;#汇编第五章-BX-和loop指令&quot; class=&quot;headerlink&quot; title=&quot;汇编第五章 [BX]和loop指令&quot;&gt;&lt;/a&gt;汇编第五章 [BX]和loop指令&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;[bx]
    
    </summary>
    
      <category term="汇编语言" scheme="http://ranxb.cn/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="笔记" scheme="http://ranxb.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="汇编语言" scheme="http://ranxb.cn/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
</feed>
