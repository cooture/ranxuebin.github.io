{"meta":{"title":"Ran Xuebin's Blog","subtitle":"永远相信美好的事情即将发生","description":"冉学斌的博客","author":"冉学斌","url":"http://ranxb.cn"},"pages":[{"title":"categories","date":"2017-09-01T00:43:18.000Z","updated":"2017-09-01T00:43:39.000Z","comments":false,"path":"categories/index.html","permalink":"http://ranxb.cn/categories/index.html","excerpt":"","text":""},{"title":"tages","date":"2017-09-03T14:54:32.000Z","updated":"2017-09-03T15:07:24.000Z","comments":false,"path":"tages/index.html","permalink":"http://ranxb.cn/tages/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-09-03T14:54:32.000Z","updated":"2017-09-03T14:54:55.000Z","comments":false,"path":"tags/index.html","permalink":"http://ranxb.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"毛概下重点整理","slug":"毛概下重点整理","date":"2019-06-21T16:16:11.000Z","updated":"2019-06-21T16:16:11.211Z","comments":true,"path":"2019/06/22/毛概下重点整理/","link":"","permalink":"http://ranxb.cn/2019/06/22/毛概下重点整理/","excerpt":"","text":"毛概下重点整理 从台湾回来要补修政治课。。。。。。。大部分都是女朋友教我的，我做一下整理。 如何理解我国社会主义矛盾发生的变化 3次矛盾的变化 是⼈⺠民对于建⽴先进的⼯业国的要求同落后的农业国的现实之间的⽭盾，是⼈⺠民对于经济⽂化迅速发展的需要同当前经济⽂化不能满⾜⼈⺠民需要的状况之间 的⽭盾。 ⼈⺠民⽇益增⻓长的物质⽂化需要同落后的社会⽣产之间的⽭盾。 ⼈⺠民⽇益增⻓长的美好⽣活需要和不平衡不充分的发展之间的⽭盾。 如何正确理解坚持党的领导、人民当家作主和依法治国的有机统一走中国特色社会主义政治发展道路，必须坚持党的领导、人民当家作主、依法治国的有机统一。 党的领导是人民当家作主和依法治国的根本保证，人民当家作主是社会主义民主政治的本质特征，依法治国是党领导人民治理国家的基本方式，三者统一于我国社会主义民主政治的伟大实践。 坚持党的领导，就要发挥党总揽全局、协调各方的领导核心作用。改进党的领导方式和执政方式，保证党领导人民有效治理国家 实现人民当家作主，就要扩大人民有序政治参与，保证人民依法实行民主选举、民主协商、民主决策、民主管理、民主监督。巩固基层政权，完善基层民主制度，保障人民知情权、参与权、表达权、监督权 坚持依法治国，就要维护国家法制统一、尊严、权威，加强人权法治保障，保证人民依法享有广泛权利和自由。健全依法决策机制，构建决策科学、执行坚决、监督有力的权利运行机制 如何建设美丽中国 生态文明建设 建设⽣态⽂明是关系⼈⺠民福祉、关乎⺠民族未来的千年⼤计，是实现中华⺠民族伟 ⼤复兴的重要战略任务。 坚持⼈与⾃然和谐共⽣，树⽴和践⾏绿⽔⻘青⼭就是⾦⼭银⼭理念，推动形成绿 ⾊发展⽅式和⽣活⽅式，统筹⼭⽔林⽥湖草系统治理，实⾏最严格⽣态环境保护 制度，开创⽣态⽂明建设和环境保护新局⾯。 决胜全面建成小康社会提出了哪些新的要求全⾯建成⼩康社会，覆盖领域要全⾯，是“五位⼀体”的全⾯ 要实事求是、因地制宜、全⾯建成⼩康社会是针对全国讲的不是每个地区、每个 ⺠民族、每个⼈达到同⼀⽔平。 五位一体： 经济建设 政治建设 文化建设 社会建设 生态文明建设 四个全面 全面建成小康社会 全面深化改革 全面依法治国 全面从严治党 如何理解构建人类命运共同体思想的科学内涵内涵（核⼼）：“建设持久和平、普遍安全、共同繁荣、开放包容、清洁美丽的世界” 政治上，要互相尊重、平等协商 。 安全上，要就坚持以对话解决争端、以协商化解分歧，统筹应对传统和⾮传安 全安全威胁，反对⼀切形式的恐怖主义。 经济上，要同⾈共济，促进贸易和投资⾃由化便利化，推动经济全球化朝着更 加开放、包容、普惠、平衡、共赢的⽅向发展。 ⽂化上，要尊重世界⽂明多样性 E ⽣态上，要坚持环境友好，合作应对⽓候变化，保护好⼈类赖以⽣存的地球家园。 如何理解当时最高政治领导力量 如何理解当时历史和人民的选择 中国共产党是中国⼯⼈阶级的先锋队，同时也是中国⼈⺠民和中华⺠民族 的先锋队。是中国特⾊社会主义事业的领导核⼼。（党的地位重要性） 中国共产党成⽴以后，团结带领中国⼈⺠民，建⽴中华⼈⺠民共和国，完 成社会主义⾰命，确⽴社会主义基本制度，消灭剥削，进⾏改⾰开放新的违⼤⾰ 命，极⼤激发⼴⼤⼈⺠民群众的创造性。近代以来，争取⺠民族独⽴、⼈⺠民解放，实 现国家富强、⼈⺠民幸福，是中国⼈⺠民必须完成的两⼤历史任务。（党的伟绩） 历史表明，历史和⼈⺠民选择中国共产党领导中华⺠民族伟⼤复兴的事业 是正确的，中国共产党领导中国⼈⺠民开辟的中国特⾊社会主义道路是正确的，中 国共产党和中国⼈⺠民扎根中国⼤地、、吸纳⼈类⽂明的优秀成果、独⽴⾃主实现 国家发展的战略是正确的，必须⻓长期坚持、绝不动摇；（历史⻆角度） 其他改革开放四个基于： 是基于对党和国家前途命运的深刻把握是 是基于对社会主义⾰命和建设实践的深刻总结 是基于对时代潮流的深刻洞察 是基于对⼈⺠民群众期盼和需要的深刻体悟 评价：是我们党的⼀次伟⼤觉醒。是中国⼈⺠和中华⺠民族发展史上⼀次伟⼤⾰命。 供给侧改革 推动产业优化升级，加快发展先进制造业为重点全⾯提升实体经济。 深化要素市场化配置改⾰，实现由以价取胜向以质取胜的转变。 注重调动和保护⼈的积极性 优化市场供求结构，坚持去产能、去杠杆 新时代如何坚持⾛中国特⾊社会主义道路 十四个坚持： 坚持党对⼀切⼯作的领导；坚持以⼈⺠民为中⼼； 坚持全⺠民深化改⾰；坚持新发展 理念； 坚持⼈⺠民当家作主；坚持全⾯依法治国； 坚持社会主义核⼼价值体系；坚持在发展中保障和改善⺠民⽣； 坚持⼈与⾃然和谐共⽣；坚持总体国家安全观； 坚持党对⼈⺠民军队的绝对领导；坚持⼀国两制和推荐祖国统⼀； 坚持推动构建⼈类命运共同体；坚持全⾯从严治党；","categories":[{"name":"笔记","slug":"笔记","permalink":"http://ranxb.cn/categories/笔记/"}],"tags":[]},{"title":"记一次微信小程序开发的经历","slug":"记一次微信小程序开发的经历","date":"2019-06-05T02:38:21.000Z","updated":"2019-06-05T02:38:21.734Z","comments":true,"path":"2019/06/05/记一次微信小程序开发的经历/","link":"","permalink":"http://ranxb.cn/2019/06/05/记一次微信小程序开发的经历/","excerpt":"","text":"小程序","categories":[{"name":"随笔","slug":"随笔","permalink":"http://ranxb.cn/categories/随笔/"}],"tags":[]},{"title":"MySQL中文的坑","slug":"MySQL中文的坑","date":"2019-06-04T07:28:46.000Z","updated":"2019-06-04T07:28:46.605Z","comments":true,"path":"2019/06/04/MySQL中文的坑/","link":"","permalink":"http://ranxb.cn/2019/06/04/MySQL中文的坑/","excerpt":"","text":"小程序准备上线了，为了保证稳定性和数据库的安全准备从sqlite迁移到mysql，结果我就日了狗了。。。。。 现象：mysql中文字段报错：比如：Incorrect string value: ‘\\xF0\\x9F\\x98\\x83 &lt;…’ for column ‘summary’ at row 1问题：明显是编码错误，环境是Macos+python3+Django。和明显不是我的编码问题。于是直接进行数据库操作insert into app_lzuuserinfo (anameu) values (&quot;冉&quot;);还是报错，说明是数据库的编码问题解决： 这tm我就要好好说道说道了。第一步百度，答案清一色的是该数据库编码格式为utf8，但是我的数据库就是utf8的。无语，陷入死胡同，于是总觉得是没有生效的问题反复使用和修改set character_set_character=utf8;和mysqld.cnf。最后毫无用处。 第二步，roseahan去Google了一下。。。。于是看到了这篇文章： https://medium.com/@adamhooper/in-mysql-never-use-utf8-use-utf8mb4-11761243e434 mdzz….大概意思如下：mysql的utf8不是我们的UTF-8，他的utf8是3个byte的编码格式，我们的UTF-8是四个字节的编码格式，所以改了utf8也不可能生效，所以我不知道为什么大家清一色的去改utf8…而且文章提出是mysql一直以来的bug没有解决，官方给出的解决方案是使用utf8mb4编码，这里的才是我们使用的UTF-8编码格式，同时emoji也是使用的这种格式。同时这个bug解决不了，官方也一直没有“声张”，所以。。。。。nb。下面给出解决方案，可以的话还是去我刚才的网站看吧。 method： https://mathiasbynens.be/notes/mysql-utf8mb4#utf8-to-utf8mb4require：mysql &gt; 5.5.3 对于已存在的表： 1234567# For each database:ALTER DATABASE database_name CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci;# For each table:ALTER TABLE table_name CONVERT TO CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;# For each column:ALTER TABLE table_name CHANGE column_name column_name VARCHAR(191) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;# (Don’t blindly copy-paste this! The exact statement depends on the column type, maximum length, and other properties. The above line is just an example for a `VARCHAR` column.) Check the maximum length of columns and index keys自行检查最大长度 Modify connection, client, and server character sets老规矩修改cnf12345678910[client]default-character-set = utf8mb4[mysql]default-character-set = utf8mb4[mysqld]character-set-client-handshake = FALSEcharacter-set-server = utf8mb4collation-server = utf8mb4_unicode_ci 都是utf8mb4， 重启。 再去检查一下数据库的编码，就没问题了。 吐槽：baidu is a shit！the same as 闭眼睛转发的人","categories":[],"tags":[]},{"title":"hexo自动发布部署同步脚本","slug":"hexoautodeploy","date":"2019-04-19T18:21:01.000Z","updated":"2019-04-19T18:21:01.972Z","comments":true,"path":"2019/04/20/hexoautodeploy/","link":"","permalink":"http://ranxb.cn/2019/04/20/hexoautodeploy/","excerpt":"","text":"hexo自动发布脚本 自动编译上传GitHub服务器，同时让自己的服务其同步的python脚本 1234567891011121314151617181920212223242526272829303132333435import osimport threadingimport paramikodef execute_cmds(ip, name, pwd, cmd): try: ssh = paramiko.SSHClient() ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy()) ssh.connect(ip, 22, name, pwd, timeout=5) print('连接成功') for m in cmd: print(m) stdin, stdout, stderr = ssh.exec_command(m) out = stdout.readlines() for o in out: print(o) print('运行成功') ssh.close() print('关闭连接') except Exception as error: print(error)if __name__ == '__main__': ip = \"ip\" # TODO: name = \"name\" # TODO: pwd = \"pwd\" # TODO: cmd_local = \"cd ~/Documents/blog;hexo g -d\" cmd_host = [\"cd /data/ranxuebin/;git pull;\"] os.system(cmd_local) a = threading.Thread(target=execute_cmds, args=(ip, name, pwd, cmd_host)) a.start()","categories":[{"name":"hexo","slug":"hexo","permalink":"http://ranxb.cn/categories/hexo/"}],"tags":[]},{"title":"HexoClient可视化","slug":"hexoclienttest","date":"2019-04-19T07:20:41.000Z","updated":"2019-04-19T07:20:48.430Z","comments":true,"path":"2019/04/19/hexoclienttest/","link":"","permalink":"http://ranxb.cn/2019/04/19/hexoclienttest/","excerpt":"","text":"这是一个测试图形化文章的管理工具 本来是想自己写一个hexo可视化后台管理的，结果发现了这个本地管理的一个小工具还不错。发现了一个比较好用的hexo的可视化管理工具——hexoClient现在把它记下来。但是是一个比较不太成熟的项目，比如不支持带密码的ssh-keygen的发布，因此我把密码取消了，可是目前还遇到的问题是不知道为什么提示发布成功但是没有鸡毛反应，不过这样以来的话估计就可以经常更新bolg了","categories":[{"name":"hexo","slug":"hexo","permalink":"http://ranxb.cn/categories/hexo/"}],"tags":[]},{"title":"甘肃政务服务网证件办理自动查询","slug":"甘肃政务服务网证件办理自动查询","date":"2018-07-06T11:07:45.000Z","updated":"2018-07-06T11:23:41.506Z","comments":true,"path":"2018/07/06/甘肃政务服务网证件办理自动查询/","link":"","permalink":"http://ranxb.cn/2018/07/06/甘肃政务服务网证件办理自动查询/","excerpt":"","text":"甘肃政务服务网证件办理自动查询 办理护照和大通证的时候发现有个甘肃政务服务网可以查到办证的进度信息，因为着急要就随时盯着，所以写了个自动查询脚本，进度变化的时候会发邮件给我。 甘肃政务信息网 效果如下： 源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475# -*- coding: UTF-8 -*-import jsonimport timeimport requestsimport smtplibfrom email.mime.text import MIMETextfrom email.header import Headerfrom bs4 import BeautifulSoupdef send_mail(sub, text): # 第三方 SMTP 服务 mail_host = \"smtp.lzu.edu.cn\" # 设置服务器 mail_user = \"***\" # 用户名 mail_pass = \"***\" # 口令 sender = 'ranxb16@lzu.cn' # receivers = ['ranxuebin@ranxb.cn'] # 接收邮件，可设置为你的QQ邮箱或者其他邮箱 receivers = ','.join(['ranxuebin@ranxb.cn']) message = MIMEText(text, 'plain', 'utf-8') message['From'] = Header(\"自动发送\", 'utf-8') message['To'] = Header(\"Rankin\", 'utf-8') subject = sub message['Subject'] = Header(subject, 'utf-8') try: smtpObj = smtplib.SMTP() smtpObj.connect(mail_host, 25) # 25 为 SMTP 端口号 smtpObj.login(mail_user, mail_pass) smtpObj.sendmail(sender, receivers, message.as_string()) print(\"邮件发送成功\") except smtplib.SMTPException: print(\"send mail error!\")message = 'Pass the first stage'loginurl = 'http://crj.gsgaw.gov.cn:7770/crj/crjmsjw/wssb/ajax/bzjdcx'headers = &#123; \"User-Agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_4) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/11.1 Safari/605.1.15\", \"Accept\": \"application/json, text/javascript, */*; q=0.01\", \"Accept-Encoding\": \"gzip, deflate\", \"Host\": 'nj.gsaic.gov.cn', \"Accept-Language\": 'zh-cn', \"Content-Type\": 'application/x-www-form-urlencoded; charset=UTF-8', 'Referer': 'http://crj.gsgaw.gov.cn:7770/crj/crjmsjw/wsyy/ajax/bzjdquery.html', \"Upgrade-Insecure-Requests\": \"1\", \"Origin\": 'http://crj.gsgaw.gov.cn:7770', \"DNT\": '1', \"Connection\": 'keep-alive'&#125;payload = &#123; 'sfzh': '632824199809070519', 'rylb': 'R'&#125;session = requests.Session()message = \"\"while 1: try: content = session.post(loginurl, headers=headers, data=payload) except: print(\"login error!\") tagert = json.loads(content.text) res = tagert['data'][0]['fullbzjd'] print(time.strftime(\"%a %b %d %H:%M:%S %Y\", time.localtime()) + \" \" + res) if message != res: send_mail(\"赴台证\", res) message = res time.sleep(120)","categories":[{"name":"脚本","slug":"脚本","permalink":"http://ranxb.cn/categories/脚本/"}],"tags":[{"name":"脚本","slug":"脚本","permalink":"http://ranxb.cn/tags/脚本/"},{"name":"办证进度","slug":"办证进度","permalink":"http://ranxb.cn/tags/办证进度/"},{"name":"甘肃政务服务网","slug":"甘肃政务服务网","permalink":"http://ranxb.cn/tags/甘肃政务服务网/"}]},{"title":"Mac OS下SD卡烧录镜像","slug":"Mac-OS下SD卡烧录镜像","date":"2018-06-05T03:21:57.000Z","updated":"2018-06-05T03:32:46.207Z","comments":true,"path":"2018/06/05/Mac-OS下SD卡烧录镜像/","link":"","permalink":"http://ranxb.cn/2018/06/05/Mac-OS下SD卡烧录镜像/","excerpt":"","text":"Mac OS下SD卡烧录镜像 经常换镜像，做个笔记。 格式化打开磁盘管理，选择SD卡，全部抹除，格式为FAT，不在多说。 卸载分区 打开命令行diskutil list 查看设备列表 1234567891011121314151617181920212223242526Rankin-Mac:~ Rankin$ diskutil list/dev/disk0 (internal): #: TYPE NAME SIZE IDENTIFIER 0: GUID_partition_scheme 500.3 GB disk0 1: EFI EFI 314.6 MB disk0s1 2: Apple_APFS Container disk1 500.0 GB disk0s2/dev/disk1 (synthesized): #: TYPE NAME SIZE IDENTIFIER 0: APFS Container Scheme - +500.0 GB disk1 Physical Store disk0s2 1: APFS Volume Macintosh HD 215.0 GB disk1s1 2: APFS Volume Preboot 24.2 MB disk1s2 3: APFS Volume Recovery 517.8 MB disk1s3 4: APFS Volume VM 3.2 GB disk1s4/dev/disk2 (external, physical): #: TYPE NAME SIZE IDENTIFIER 0: FDisk_partition_scheme *7.9 GB disk2 1: DOS_FAT_32 UNTITLED 7.9 GB disk2s1/dev/disk3 (disk image): #: TYPE NAME SIZE IDENTIFIER 0: GUID_partition_scheme +314.8 GB disk3 1: EFI EFI 209.7 MB disk3s1 2: Apple_HFS 时间机器备份 314.5 GB disk3s2 这样的就卸载disk2的所有分区，例如disk2s1，有多的都要卸载。 命令：diskutil unmount /dev/disk2s1 烧录前提是准备好你的镜像iso文件。 命令：sudo dd bs=4m if=ubuntu-16.04.4-lxqt-aarch64-raspberrypi3b-raspberrypi3b-plus-20180428-chainsx.img of=/dev/rdisk2 注意，目标磁盘为原始磁盘rdisk*，绝对不要把数字写错。 完成后会提示 123750+0 records in 750+0 records out3145728000 bytes transferred in 279.701624 secs (11246728 bytes/sec) 卸载磁盘 命令：diskutil unmountDisk /dev/disk2 完成","categories":[{"name":"烧录","slug":"烧录","permalink":"http://ranxb.cn/categories/烧录/"}],"tags":[{"name":"烧录","slug":"烧录","permalink":"http://ranxb.cn/tags/烧录/"},{"name":"SD卡","slug":"SD卡","permalink":"http://ranxb.cn/tags/SD卡/"},{"name":"Mac","slug":"Mac","permalink":"http://ranxb.cn/tags/Mac/"}]},{"title":"台湾科技大学自动查询审核结果的脚本","slug":"台湾科技大学自动查询审核结果的脚本","date":"2018-05-07T07:49:45.000Z","updated":"2018-05-07T07:55:00.771Z","comments":true,"path":"2018/05/07/台湾科技大学自动查询审核结果的脚本/","link":"","permalink":"http://ranxb.cn/2018/05/07/台湾科技大学自动查询审核结果的脚本/","excerpt":"","text":"台湾科技大学自动查询审核结果的脚本 要去交流了，天天随时随地看结果太累了，写了个简单的脚本，如果发生变动的话会发邮件给我，代码如下。 Github地址: https://github.com/ranxuebin/NTUST_Exchange-Program-Auto-Chack-Result 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import timeimport requestsimport smtplibfrom email.mime.text import MIMETextfrom email.header import Headerfrom bs4 import BeautifulSoupwhile 1: loginurl = 'http://stu88.ntust.edu.tw/inboundchina/stu/login.do' homeurl = \"http://stu88.ntust.edu.tw/inboundchina/stu/review.result\" headers = &#123; \"User-Agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_4) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/11.1 Safari/605.1.15\", \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\", \"Accept-Encoding\": \"gzip, deflate\", \"Host\": 'stu88.ntust.edu.tw', \"Accept-Language\": 'zh-cn', \"Content-Type\": 'application/x-www-form-urlencoded', 'Referer': 'http://stu88.ntust.edu.tw/inboundchina/stu', \"Upgrade-Insecure-Requests\": \"1\", \"Origin\": 'http://jwk.lzu.edu.cn', \"DNT\": '1', \"Connection\": 'keep-alive' &#125; session = requests.Session() payload = &#123; 'email': 'ranxuebin@ranxb.cn', 'password': '*******', 'captcha': '' &#125; def send_mail(sub, text): # 第三方 SMTP 服务 mail_host = \"smtp.lzu.edu.cn\" # 设置服务器 mail_user = \"*****\" # 用户名 mail_pass = \"*****\" # 口令 sender = 'ranxb16@lzu.cn' # receivers = ['ranxuebin@ranxb.cn'] # 接收邮件，可设置为你的QQ邮箱或者其他邮箱 receivers = ','.join(['ranxuebin@ranxb.cn']) message = MIMEText(text, 'plain', 'utf-8') message['From'] = Header(\"自动发送\", 'utf-8') message['To'] = Header(\"Rankin\", 'utf-8') subject = sub message['Subject'] = Header(subject, 'utf-8') try: smtpObj = smtplib.SMTP() smtpObj.connect(mail_host, 25) # 25 为 SMTP 端口号 smtpObj.login(mail_user, mail_pass) smtpObj.sendmail(sender, receivers, message.as_string()) print(\"邮件发送成功\") except smtplib.SMTPException: print(\"send mail error!\") try: response_login = session.post(loginurl, headers=headers, data=payload) response_home = session.get(homeurl, headers=headers) except: print(\"login error!\") result = BeautifulSoup(response_home.text, \"html.parser\") result = result.find(class_=\"alert alert-info\") print(time.strftime(\"%a %b %d %H:%M:%S %Y\", time.localtime()) + \" \" + result.span.string) if result.span.string != 'Pass the first stage': send_mail(\"台科大信息\", result.span.string) time.sleep(600)","categories":[{"name":"脚本","slug":"脚本","permalink":"http://ranxb.cn/categories/脚本/"}],"tags":[{"name":"脚本","slug":"脚本","permalink":"http://ranxb.cn/tags/脚本/"},{"name":"台科","slug":"台科","permalink":"http://ranxb.cn/tags/台科/"}]},{"title":"无显示器条件下查询树莓派IP的方法","slug":"无显示器条件下查询树莓派IP的方法","date":"2018-02-14T04:18:09.000Z","updated":"2018-02-14T04:19:48.296Z","comments":true,"path":"2018/02/14/无显示器条件下查询树莓派IP的方法/","link":"","permalink":"http://ranxb.cn/2018/02/14/无显示器条件下查询树莓派IP的方法/","excerpt":"","text":"无显示器条件下查询树莓派IP的方法 方法都根据树莓派的网卡物理地址为b8:27:eb:开头 。因此有以下自动化方法 Mac下打开网络实用工具直接查询Netstat下的路由表找到树莓派的物理地址对应的就是树莓派的IP地址。 Shell脚本 整个代码逻辑为依次pingIP地址，之后通过arp映射找到对应的物理地址，取到对应的IP。 代码如下 clear echo &quot;程序运行中...&quot; ipLine=&quot;`ifconfig | grep &quot;inet 192.168&quot; `&quot; preIp=${ipLine:5:11} echo &quot;程序默认将在$preIp 2 - $preIp 255范围内进行扫描&quot; echo &quot;但这将花费较多时间，请问是否进行手动设置？（y/n)&quot; read choice if test $choice = &quot;y&quot; then echo -n &quot;请输入起始位置(2-255):&quot; read i echo -n &quot;请输入结束位置($i-255):&quot; read j echo &quot;下面将对 $i 到 $j 范围进行扫描&quot; else i=2 j=255 echo &quot;下面将直接对2-255整个范围进行扫描&quot; fi while test $i -ne $j do echo &quot;正在检测ip的连接情况，请耐心等待&quot; ip=$preIp$i echo &quot;正在ping端口$ip ...&quot; &quot;`ping -t 1 -q $ip `&quot; let i=i+1 clear done clear echo &quot;所有ip检测完毕，正在计算结果...&quot; result=&quot;`arp -a | grep &quot;b8:27:eb:&quot; ` &quot; resultIp=${result:3:14} resultMac=${result:19:17} clear echo &quot;已经得到结果：&quot; echo &quot;您的树莓派Mac地址为:$resultMac&quot; echo &quot; 当前连接的IP为:$resultIp&quot; echo echo &quot;程序结束&quot;","categories":[{"name":"树莓派","slug":"树莓派","permalink":"http://ranxb.cn/categories/树莓派/"}],"tags":[{"name":"树莓派","slug":"树莓派","permalink":"http://ranxb.cn/tags/树莓派/"},{"name":"Unix","slug":"Unix","permalink":"http://ranxb.cn/tags/Unix/"}]},{"title":"Ubuntu上启动ftp服务","slug":"Ubuntu上启动ftp服务","date":"2018-02-07T13:13:49.000Z","updated":"2018-02-07T13:16:20.832Z","comments":true,"path":"2018/02/07/Ubuntu上启动ftp服务/","link":"","permalink":"http://ranxb.cn/2018/02/07/Ubuntu上启动ftp服务/","excerpt":"","text":"Ubuntu上启动ftp服务安装并启动VSFTPD 安装VSFTPDsudo apt-get install vsftpd -y 启动VSFTPD(会自动启动若未启动)sudo systemctl start vsftpd.service 检测端口，判断是否启动。sudo netstat -nltp | grep 配置用户访问目录 新建主目录 新建用户并设置密码sudo useradd -d /home/uftp -s /bin/bash uftpsudo passwd uftpsudo rm /etc/pam.d/vsftpd(这里删除该配置文件，因为会导致使用用户名登录FTP失败) 限制用户只能通过FTP访问sudo usermod -s /sbin/nologin uftp 修改VSFTPD配置sudo chmod a+w /etc/vsftpd.conf下面修改/etc/vsftpd.conf文件中的配置（添加到最下面） # 限制用户对主目录以外目录访问 chroot_local_user=YES # 指定一个 userlist 存放允许访问 ftp 的用户列表 userlist_deny=NO userlist_enable=YES # 记录允许访问 ftp 用户列表 userlist_file=/etc/vsftpd.user_list # 不配置可能导致莫名的530问题 seccomp_sandbox=NO # 允许文件上传 write_enable=YES # 使用utf8编码 utf8_filesystem=YES 新建文件/etc/vsftpd.user_list用于存放允许访问FTP的用户sudo touch /etc/vsftpd.user_listsudo chmod a+w /etc/vsftpd.user_list并修改，加入刚刚创建的用户 设置访问限权设置主目录访问权限（只读）：sudo chmod a-w /home/uftp设置公共目录，设置可读写：sudo mkdir /home/uftp/public &amp;&amp; sudo chmod 777 -R /home/uftp/public重启VSFTPD服务：sudo systemctl restart vsftpd.service 完","categories":[{"name":"Linux","slug":"Linux","permalink":"http://ranxb.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://ranxb.cn/tags/Linux/"},{"name":"FTP","slug":"FTP","permalink":"http://ranxb.cn/tags/FTP/"}]},{"title":"Linux的用户及用户组","slug":"Linux的用户及用户组","date":"2018-02-07T13:12:41.000Z","updated":"2018-02-07T13:18:16.931Z","comments":true,"path":"2018/02/07/Linux的用户及用户组/","link":"","permalink":"http://ranxb.cn/2018/02/07/Linux的用户及用户组/","excerpt":"","text":"Linux的用户及用户组配置文件 /etc/group 组信息配置文件 /etc/passwd 用户信息配置文件 /etc/shadow 用户密码配置文件 /etc/gshadow 组密码配置文件 基本操作组操作groupadd NEWGROUP添加一个组groupadd -g 888 NEWGROUP添加一个组并指定UIDgrouddel NEWGROUP删除一个组。groupmod -n NEWGROUP OLDGROUP更改组名groupmod -g 888 NEWGROUP更改组UID 用户操作useradd -g GROUP USER添加一个指定用户组的用户useradd -d /home/xxx USER添加一个指定目录的的用户userdel USER删除一个用户userdel -r USER同时删除用户主目录usermod -l NEWNAME USER更改用户名usermod -c BEIZHU USER加备注usermod -d /home/yyy UESR改用户主目录usermod -g GROUP USER改组 在/etc/下创建nologin文件其他用户均不能登录 进阶操作组 主要组和附属组 gpasswd -a USER GROUP,GROUP2添加附属组newgrp GROUP切换用户组,此时可能需要组密码gpasswd -d USER GROUP删除附属组useradd -g 主要组 -G 附属组，附属组 USER新建时指定用户组gpasswd GROUP修改组密码 用户passwd -l USER锁定账户passwd -u USER解锁账户passwd -d USER清除密码 其他命令su USER 切换账户","categories":[{"name":"Linux","slug":"Linux","permalink":"http://ranxb.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://ranxb.cn/tags/Linux/"},{"name":"用户","slug":"用户","permalink":"http://ranxb.cn/tags/用户/"}]},{"title":"数据结构知识框架","slug":"数据结构知识框架","date":"2018-01-11T01:16:54.000Z","updated":"2018-01-11T16:03:53.277Z","comments":true,"path":"2018/01/11/数据结构知识框架/","link":"","permalink":"http://ranxb.cn/2018/01/11/数据结构知识框架/","excerpt":"","text":"数据结构知识框架第一章第一方面：基本概念1、数据结构研究方面（研究内容）主要体现三个方面： 数据的逻辑关系 储存关系 运算关系 还讨论算法的效率问题，分类问题等。 2、数据结构的逻辑结构逻辑关系：自然状态下数据元素之间的一种联系（关联方式或邻接关系，从逻辑上观察数据，与计算机无关）。逻辑结构：对数据元素之间关系的描述B=(k，r)其中，k：数据元素的有穷集合（有限元素构成），r：k上关系的有穷集合，其中每个关系r都是从k到k的关系。逻辑结构的分类：线性结构和非线性结构（树形结构、图形结构（网状结构））。关于集合类型：元素之间除同属一个集合外别无其他类型3、数据结构的存储结构存储关系：逻辑结构在计算机存储器中实现，它依赖于计算机。具体说数据在存储器中的关联方式，也成物理结构，物理关系等。 顺序结构 链接结构 索引结构 散列（hash）结构 4、数据结构评价标准主要标准： 作为问题的参数的函数来计算存储需要量 作为问题的参数的函数来计算时间效率 还需要考虑其他因素 第二章：算法（只有一个层面）1、算法的评价标准好算法要达到以下目标： 正确性（满足具体问题的要求） 易读性（交流与他人阅读，其次是机器执行） 高效性（效率与存储量的需求，达到所需的时空性能） 健壮性（适应环境变化，有非法输入时，能做出相应的处理或反映） 2、算法的描述方法 计算机程序设计语言 自然语言 PDL语言（伪码语言、可运行于“抽象计算机”，虚拟机） 流程图 第三章：线性表（只有第三个要求）1、线性表：一个线性表是n≥0个数据元素a1，a2，……，an的有限序列，序列中除第一个最后一个以外，每个元素都是有且仅有一个直接前驱和直接后继。2、链表：通过指针联系起来的结点的整体（集合）。3、静态链表：以整形变量的值作为存储连接指针值（即地址）联系起来的结点的整体。（指针本质整形值）4、表头结点：增加一个附加结点，放置于链表的最前面，也称表头结点，且该节点不用存储数据元素。作用和目的（简化算法）。5、存储密度：结点数据本身所占的存储量和整个结点结构所占的存储量之比。存储密度 = （结点数据本身所占的存储量）/（结点结构所占的存储总量） 基于链表的插入删除 第四章：栈和队列（只有第三层）1、栈：栈在计算机具体应用中，是一个特定的存储区，一端固定，一端浮动。栈是一个下限为常数，上限可变化的（或者反之），也成为堆栈或堆阵。可变化一端为栈顶，不可变化一端为栈底2、栈与线性表的异同：栈的插入、删除至能在一端进行，不能在任意点，栈是受限的线性表。3、队列：队列是一个上限和下限只能增加和不能减少的向量（或反之），队首：取出元素的一端。队尾：加入元素的一端。4、队列与线性表的异同：受限的线性表，删除和插入操作只能在特定位置。5、假溢出（待定）：多栈共存时，有点栈已满，有的还没有满。存储区还没有满,但队列或栈却发生了溢出,我们把这种现象称为”假溢出”。 第三层次：循环队列的出入队。 循环队列的出入队 (注意！队首指向队头元素的前一个地址，队尾指向队屁股最后一个元素) 入队： PROC REDUI(VAR CQ: ARRAY[M..N]OF DATATYPE;FRONT,REAR,X:INTERG) BEGIN REAR&lt;-REAR+1 IF REAR=N+1 THEN REAR&lt;-M IF REAR=FRONT THEN PRINT&quot;CQ FULL&quot;&quot; ELSE CQ[REAR]&lt;-X END 出队： PROC CHUDUI(VAR CQ:ARRAY[M...N]OF DATATYPE;FRONT,REAR,X:INTEGER) BEGIN IF FRONT=REAR THEN PRINT&quot;CQ EMPTY&quot; ELSE IF FRONT = N THEN FRONT = M ELSE FRONT &lt;- FRONT+1 X &lt;- CQ[FRONT] END 第五章：串（只有第一层面）1、串：一个由零个或多个字符组成的有穷序列称为串，简记A=a1a2……an。2、串的模式匹配：假设有两个串P和S：P=p1p2……pm S=s1s2……sn 其中（0＜m＜n）通常m&lt;&lt;n在S中找出一个与P相同的子串，即串的定位。通常把S称为目标，把P称为模式，把从目标S中查找模式P的过程称为串的模式匹配。 第六章：数组和广义表（二）1、数组：一位数组是个向量，他的每个元素是该结构中不可分割的最小单位；n(n&gt;1)维数组是个向量，他的每个元素是n-1维数组，且具有相同的下限和上限。2、稀疏数组：在一个数组中和某一元素比较而言，不相同的元素很少时，我们称此数组为稀疏数组。3、稀疏矩阵：是稀疏数组的典例。与稀疏矩阵的差别：元素分布是否有规律。4、广义表：广义表是零个或多个原子（他是所要描述的某种数据类型的对象，是一个确定的概念）或子表所构成的有限序列，简称表。 第二层次稀疏矩阵的两个存储方法：三元组（顺序存储）、十字链表 三元组的缺陷 不利于矩阵元素的变化：非零到零的删除、零到非零的添加 第七章：树形结构（二、三）1、树：是满足以下性质的有限个结点组成的非空集合 T中有且只有一个称为根的结点。 除根节点以外，其余节点分为m(m&gt;0)个不相交的集合T1，T2……Tm，其中每个Ti都是数，而却都称为T的子树。 2、二叉树：二叉树T是满足如下性质的结点的有限集合： T是空集。 或者它包含一个根节点且其余结点分为两个不相交的集合，并分别被称为左子树和右子树，且左右子树都为二叉树。 3、遍历：对于给定数据结构，系统的访问该结构中的每个结点，且每个结点仅被访问一次的操作过程成为遍历。（会改字）4、二叉树的遍历规则： 层次遍历：从上到下从左到右，布拉布拉布拉～ 深度策略：先根遍历、中根遍历、后根遍历。 5、二叉排序树：二叉排序树或空二叉树，或者是满足以下要求的二叉树。 若是它的左子树非空，或者左子树上所有结点的值均小于等于根节点的值。 若它右子树非空，则右子树上所有结点的值均大于等于根节点的值。 且左右子树都为二叉排序树。 6、线索：将二叉树的空指针利用起来，用于表示某线性关系下前驱或后即的，这种指针称为线索。7、线索树：带线索的二叉树简称为线索树。 8、霍夫曼树（最优二叉树）：按霍夫曼算法构造具有最小加权路径长度的二叉树。9、线索化：给二叉树加线索的过程。 第二层次： 树、森林、二叉树相互转换 二叉树的前中后遍历的方法 二叉树加线索 霍夫曼树的构造和编码 二叉排序树的构造 12345678二叉树的先序遍历PROC XIANXUBIANLI (VAR T:BINARY TREE)BEGIN IF T!=NULL THEN [PRINT&quot;T-&gt;DATA&quot; CALL XIANXUBIANLI(T-&gt;LSON) CALL XIANXUBIANLI(T-&gt;RSON)]END 123456789二叉树的中序遍历PROC XIANXUBIANLI (VAR T:BINARY TREE)BEGIN IF T!=NULL THEN [CALL XIANXUBIANLI(T-&gt;LSON) PRINT&quot;T-&gt;DATA&quot; CALL XIANXUBIANLI(T-&gt;RSON)] END 12345678二叉树的后序遍历PROC XIANXUBIANLI (VAR T:BINARY TREE)BEGIN IF T!=NULL THEN [CALL XIANXUBIANLI(T-&gt;LSON) CALL XIANXUBIANLI(T-&gt;RSON) PRINT&quot;T-&gt;DATA&quot;]END 树到二叉树的转换： 加线：加横线 抹线：抹掉可以抹掉的所有右孩子之间的线 二叉树转到树： 加线：1.是父节点的左孩子。2.把父节点和他的右孩子和右孩子的右孩子和。。。连起来。 抹线：抹去所有节点和右孩子之间的线 森林转化为二叉树 把每个树转化为二叉树 二叉树的连接：依据森林次序，后一棵二叉树是前一棵二叉树根节点的右子树 二叉树转换成森林 抹线：把节点的右子树都拿出来 还原：把每个二叉树变成树 线索化 左孩子指向直接前驱 右孩子指向直接后驱 标志位0表示指向孩子，1表示指向线索 构造二叉树 节点是否为空，为空则插入 若小于，执行递归插入左孩子节点，到1. 若大于，执行递归插入右孩子节点，到1. 霍夫曼树（最优二叉树） 给定一组权值集合{w1, w2, …, wn}. 将F={T1, T2, …, Tn}按根结点的值由小到大进行排序。 取出T1和T2组成一棵二叉树T；再将T插入到F中，并使F依据根结点的值有序。 反复执行③直到F={T}为止。 霍夫曼树的编码 给定字符集 写出每个字符出现的次数组成的集合。 对此集合进行霍夫曼排序 左支为0右支为1写出每个字符的编码 第三个层次：遍历方法，两个运用一个处理 交换左右子树 PROC EXCHANGE(VAR T:BINARYTREE) BEGIN IF T!=NULL THEN [SWOP(T-&gt;LSON,T-&gt;RSON) CALL EXCHANGE(T-&gt;LSON) CALL EXCHANGE(T-&gt;RSON)] END 求二叉树的高度 12345678910111213141516171819202122PROC HIGHT(VAR T:BINARYTREE,H)BEGIN IF T=NULL THEN H&lt;-0 ELSE [CALL HIGHT(T-&gt;LSON,H1) CALL HIGHT(T-&gt;RSON,H2) H&lt;-MAX(H1,H2)+1]END``` 叶子结点的个数```PDLPROC COUNTLEAF(VAR T:BINARYTREE;COUNT:INTGER)BIGIN CASE T=NULL: COUNT&lt;-0 T-&gt;LSON=NULL AND T-&gt;RSON=NULL: COUNT&lt;-1 ELSE [CALL COUNTLEAF(T-&gt;LSON,C1) CALL COUNTLEAF(T-&gt;RSON,C2) COUNT&lt;-C1+C2] END CASEEND 第八章：图结构（二）1、图：由n(n≥1)个结点v1，v2，……，vn构成的数据G称为图。若结点集V=｛v1、v2……vn｝上定义的称为后继的关系E是非自反的，可表示为G=（V，E），其中V为顶点集，E为边集。2、图的遍历：给出图G和其中的任意一个定点v0，从v0出发系统的访问G中所有的定点，且每个顶点（反）被访问一次，这一过程称为图的遍历。3、图的遍历规律：广度优先遍历，深度优先遍历。4、最小生成树：一个有 n 个结点的连通图的生成树是原图的极小连通子图，且包含原图中的所有 n 个结点，并且有保持图连通的最少的边和权重。5、AOV网：若有向图G中，顶点表示活动或任务，有向边表示活动或任务之间的优先关系，则此有向图称为顶点表示活动网络（AOV网）。6、AOE网：若在带权的有有向图中的顶点表示事件，有向边表示活动，权表示活动持续的时间，则此有向图称为边表示活动的网络(AOE网)。7、拓扑排序：对于有向图G=(V,E)，V中的顶点的线性序列(Vi1,Vi2,……,Vin)，称作一个拓扑序列，若此结点序列满足如下条件；在G中从顶点u到顶点v有一条路径，则在序列中u必在v之前。寻找拓扑序列的有效手段就是进行拓扑排序。8、关键路径：任务计划作业图上的需要时间最长的路径（可有多条），它决定完成总任务的时间。 第二个层次 图的邻接表和邻接矩阵的存储方法 图的深度和广度遍历的方法 Prim和Kruskal算法 邻接表和邻接矩阵的表示有向图中邻接表的表示：网的邻接矩阵：深度优先搜索广度优先搜索 prim算法构造最小生成树每一步都找已连通的树中权最小的边用来构造 Kruskal算法构造最小生成树按照权值递增的顺序逐个考虑E中的每条边： 第九章：排序（二、三）1、排序：设含有n个记录的集合为R=｛r1，r2，……，rn｝，其对应的关键字集合为k=｛k1，k2，……，kn｝，给定关系α，按照关系α针对关键字集合k对R进行运算，是的R有如下序列：（rα1，rα2，……，rαn）我们将这个操作过程称为排序。2、排序分类：分为外部排序和内部排序。内部排序包括 插入排序 交换排序 选择排序 合并排序 枚举排序 分配排序 3、排序稳定性：在排序关系下，假设排序前ri在rj之前，排序之后领先关系不变，则称此排序过程方法是稳定的，否则是不稳定的。4、堆：设L是长度n的表，其数据元素满足：L(i)≤L(2i)且L(i)≤L(2i+1), 1≤i≤[n/2] 或反之。则称L是一个堆。 第二个层次 直接插入 快速排序 二路归并 基数 堆的构造 直接插入从一个零集合开始，将 r 按照排序关系插入到一个已经有序的文件适当位置。 快速排序基本方法： PROC QuickSort(VAR R:ARRAY[1..n] OF datatype;l,p:integer); BEGIN IF l≥p THEN exit ; i←l; j←p; x←R[i]; REPEAT WHILE (x.key≤R[j].key)AND(i＜j) DO j←j-1; IF i＜j THEN 【 R[i]←R[j]; i←i+1; WHILE (R[i].key＜x.key)AND(i＜j) DO i←i+1; IF i＜j THEN【 R[j]←R[i]; j←j-1; 】 】 UNTIL i=j; R[i]←x; i←i+1; j←j-1; IF l＜j THEN CALL QuickSort(R, l , j); IF i＜p THEN CALL QuickSort(R, i , p); END; 二路插入两个两个合并，然后四个四个合并，然后大的合并堆的构造1.先插入，然后往上爬。2.先排列，然后从第一半个节点开始往上爬。基数排序看最低位，一次装进是个桶里，然后拿出来。再装第二位，最后装第三位。 第三个层次：二分插入排序 与直接插入排序的区别：在插入第i个时搜索采用二分策略。 1234567891011121314PROC DUOSORT(VAR R:ARRAY[1..N])BIGIN FOR I&lt;-2 TODO N DO[ X&lt;-R[I],L &lt;- 1,H &lt;- I WHILE L&lt;=H DO[ M&lt;-(L+H)DIV2 IF X&lt;A[M] THEN H&lt;-(M-1) ELSE L&lt;-(L+1) ] FOR J&lt;-(I-1) TODO L DO R[J+1] &lt;- R[J] R[L] &lt;- X ]END 第十章：数据检索（二、三）1、检索：在给定数据结构中查找满足某种条件的数据元素（或节点，记录）的过程。2、检索分类： 基于关键字的检索； 基于属性的检索； 3、平均检索长度：衡量检索算法的主要标准是检索过程中对关键字（或属性）要执行的平均运算次数。4、AVI树： 一颗空二叉树是AVL树； 若T是一颗非空二叉树，其访问任何结点的左右子树的相差高度不超过1，则T是AVL树。 5、碰撞：依据散列函数H计算出地址，若发现此地址已经被别的结点占用，即有两个不同的关键字映射到了同一地址空间的现象。6、散列表：是一种存储方法也是一种常见的检索方法，是按关键字编址的一种技术。用散列法组织存储的表。7、同义词：发生碰撞的两个关键字；8、堆集现象：在散列表中插入一个新结点y时，当然它不是先前已经插入的某个节点x的同义词，但可能会出现H（y），已经被x的同义词占用的情况，这是只能将y也链接在x的同义链中，也就是说出现了y与x的同义链结成一个的情况，把连个同义词子表结合在一起的现象称为堆集现象。 第二层次：AVL的构造 正常插入 当不满足平衡二叉树时，调整 调整要求中序顺序不变 RL或LR调整要把整个x都要挪上去 举例： 第三层次：二分检索 12345678910111213PROC DUOSEARCH(VAR R:ARRAY[1...MAX]OF DATATYPE;N:INTEGER;K:KTYPE)BEGIN L &lt;- 1,H &lt;- N WHILE L &lt;= H DO[ MIDDLE &lt;- (L+H) DIV 2 CASE K == R[MIDDLE]:WRITE&quot;SUEECE&quot;,EXIT; K &lt; R[MIDDLE]: H = MIDDLE-1 K &gt; R[MIDDLE]: L = MIDDLE+1 ENDCASE ] WRITE&quot;UNSUCCSE&quot;END 十二章，文件1、 文件：为了进行存取控制、检索和修改而组织在一起的数据记录集合。2、 文件逻辑组成分类：（广义）两种： 字符流文件：有序的字符流序列，文件基本单位为字节或字。 记录文件：数据记录的集合文件基本单位为记录。 3、 文件物理组成分类：从存储结构来看，文件的组织仅有三种：（说大的就行了） 顺序机构：按照数据到达的时间先后次序进行组织。按该方式组织的文件称顺序文件。 计算寻址结构：按照散列方式组织文件。该方式组织的文件称散列文件。 带索引的结构：组织数据时需要带一个索引表。称为索引文件，主要是利用树形结构组织索引。 4、 动态存储结构：是指文件创建初始装入记录时所生成的索引结构，在系统运行过程中索引结构本身能够发生改变。5、 静态存储结构：指索引结构在文件创建，初始装入记录生成，一旦生成就固定下来，在系统运行过程中索引结构并不发生变化，只有当文件重组时菜允许改变索引结构。6、 B+，B-树的本质：平衡的多分树。7、 B+，B-树的作用：组织动态索引结构。8、 ISAM文件的本质：索引顺序存取。（静态索引结构）9、 VSAM文件的本质：虚拟存储存取。（动态索引结构）10、 外排基本方法：归并排序。","categories":[{"name":"笔记","slug":"笔记","permalink":"http://ranxb.cn/categories/笔记/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://ranxb.cn/tags/笔记/"},{"name":"数据结构","slug":"数据结构","permalink":"http://ranxb.cn/tags/数据结构/"}]},{"title":"汇编语言：基础知识（第五章以前）","slug":"汇编语言：基础知识（第五章以前）","date":"2018-01-09T07:22:19.000Z","updated":"2018-01-09T15:21:05.093Z","comments":true,"path":"2018/01/09/汇编语言：基础知识（第五章以前）/","link":"","permalink":"http://ranxb.cn/2018/01/09/汇编语言：基础知识（第五章以前）/","excerpt":"","text":"汇编语言：基础知识（第五章以前）基基础 数据总线：传数据用的，8线一次传1b，8086有16线 地址总线：最高可以寻到的地址，8086是20线，4线一个16进制位。 一个地址是一个内存单元就是1b，2个十六进制位。 要知道给定一个段地址之后的地址寻址范围。 inc dec 寄存器的总结段寄存器段寄存器就是存放段地址的 CS DS SS ES 段地址不支持直接将数据送入 SS：SP永远指向栈顶元素 在自己写程序的过程中要注意的问题！ assume写全 最后int 21h 数据不能以字母开头 使用es存放目标空间的段地址 正式的程序开始时写start，最后写end start 寻址方式多种寻址方式 寄存器直接寻址 寄存器相对寻址（寄存器+idata） 基址变址寻址（寄存器+寄存器） 相对基址变址寻址（寄存器+寄存器+idata） 转大小写的单循环例子assume cs:code,ds:data,ss:strack strack segment dw 8 dup(0) strack ends data segment db &apos;1. display &apos; db &apos;2. dsjk &apos; db &apos;3. dasdasdasd &apos; data ends code segment start: mov ax,data mov ds,ax mov ax,strack mov ss,ax mov sp,10h mov di,0 mov cx,4h l: mov al,[di+3] and al,11011111b mov [di+3],al mov al,[di+10h+3] and al,11011111b mov [di+10h+3],al mov al,[di+32+3] and al,11011111b mov [di+32+3],al inc di loop l mov ax,4c00h int 21h code ends end start 结果 转大小写的双循环例子 注意bx和si的同时使用，di和si不能同时使用 assume cs:code,ds:data,ss:strack strack segment dw 8 dup(0) strack ends data segment db &apos;1. display &apos; db &apos;2. dsjk &apos; db &apos;3. dasdasdasd &apos; data ends code segment start: mov ax,data mov ds,ax mov ax,strack mov ss,ax mov sp,10h mov di,0 mov cx,4 mov si,0 l: push cx mov cx,3 l0: mov al,[si+di+3] and al,11011111b mov [di+3],al inc di loop l0 mov di,0 add si,16 pop cx loop l mov ax,4c00h int 21h code ends end start 结果 指令的转移jmp jmp short 标号 -128~127 jmp near ptr 标号 -32768~32767 jmp far ptr 标号 jmp 16位reg IP = reg jmp word ptr 地址 段内转移：jmp word ptr ds:[0]，设置IP jmp dword ptr 地址 段间转移，先赋值IP jcxz当cx为0时跳转，范围-128～127 ret和retf都是先对IP进行操作 pop ip pop cs call call 标号 call far ptr 标号 12push cspush ip call word ptr 地址 call dword ptr 地址 mul乘法 双8位，一个放al，结果ax 双16位，一个放ax，结果高位dx低位ax 123mov al,1mov bl,2mul bl 或者123mov al,1mov byte ptr ds:[0],2mul byte ptr ds:[0] div除法 低位是商高位是余数 16位除以8位，前面的数放在ax里 32位除以16位，高位dx，低位ax 1div byte ptr ds:[0];默认被除数是ax 或者12mov bx,10div bx；默认被除数高位是dx，低位时ax 中断流程： 取得中断码 pushf 设置标志寄存器 CS和IP入栈 设置IP，设置CS 中断向量表四个字节一个中断地址前两个是IP后两个是CS 安装 这里进行模拟loop的安装，位置7ch。","categories":[{"name":"汇编语言","slug":"汇编语言","permalink":"http://ranxb.cn/categories/汇编语言/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://ranxb.cn/tags/笔记/"},{"name":"汇编语言","slug":"汇编语言","permalink":"http://ranxb.cn/tags/汇编语言/"}]},{"title":"数字电路进阶（第六章以后）","slug":"数字电路进阶（第六章以后）","date":"2018-01-08T13:46:16.000Z","updated":"2018-01-09T12:03:26.885Z","comments":true,"path":"2018/01/08/数字电路进阶（第六章以后）/","link":"","permalink":"http://ranxb.cn/2018/01/08/数字电路进阶（第六章以后）/","excerpt":"","text":"数字电路进阶（第六章以后）时序逻辑电路的应用 比如寄存器、锁存器、移位寄存器、计数器。。。 寄存器什么都没有。重点就是74ls290，看第六章的具体内容。 74LS290 环形计数器是将移位型寄存器最后一级反馈到第一级的输入端，特点是构成寄存器的模数和所用触发器的个数相同，只能利用四个状态，比较浪费。利用的是74LS194 扭环形计数器是将最后一级的反变量反馈到第一级，不能自启动需要置零可以利用所有状态。","categories":[{"name":"数字电路","slug":"数字电路","permalink":"http://ranxb.cn/categories/数字电路/"}],"tags":[{"name":"数字电路","slug":"数字电路","permalink":"http://ranxb.cn/tags/数字电路/"},{"name":"笔记","slug":"笔记","permalink":"http://ranxb.cn/tags/笔记/"}]},{"title":"数字电路：基础知识","slug":"数字电路：基础知识","date":"2018-01-08T10:08:34.000Z","updated":"2018-01-09T12:04:02.295Z","comments":true,"path":"2018/01/08/数字电路：基础知识/","link":"","permalink":"http://ranxb.cn/2018/01/08/数字电路：基础知识/","excerpt":"","text":"数字电路：基础知识 你可以理解为第五章之前的内容 各个码反码、补码 反码：大于零的不变，小于零的除符号位全取反 补码：大于零的和原码一样，小于零的在最低位加1 运算：补码和补码都可以进行直接运算，两个直接相加，最高位溢出的话直接丢掉。反码运算的话需要把溢出位加到最后一位上。 十进制的补数 对十的补数：符号位是0(+)和9(-),两种方法,一是加后符号位后每个数值对十取反，就是用9减，然后最低位加一；二是几位就用10的几次方减原来那个数。[5493] = 05493 [-3250] = 96750 [-0.3267] = 9.6733 对9的补数：类似，符号位是0和8，数字位用9减。末尾不加一[8954] = 08954 [-3250] = 95639 [-25.639] = 974.360 运算：对十的补码运算溢出要丢掉，对九的补码运算溢出要加到最低位 码制和字符代码 恒权代码：8421bcd、5421bcd、2421bcd、5211bcd 循环码：只有一位和周边俩不同的码 余三码：在8421的基础上加三个开始往后数 余三循环码：在循环码的基础上加三开始往后数 奇偶校验码：1的个数为奇偶数，在汇编中PF中当1的个数为偶数的时候标志为1 ASCII码：小写字母在大写字母后面，大于61H的是小写，将’a’的ASCII码减20H就可以变成大写字母’A’，将’A’的ASCII码加20H就可以变成小写字母’a’，ASCII码的二进制形式第六位为1时是小写字母，0时大写字母 逻辑函数 各个门的符号，与门（中间一个&amp;），或门（中间一个&gt;=1），非门（中间一个1后面加圈圈），异或（环和，中间=1），同或（环积，异或后面加圈圈） 最大项（各个项加起来）、最小项（各个项乘起来） 代数规律，两积可交换，乘零得零，分配律 卡诺图，2n种的可以画圈圈，出来的圈圈是最小项的形式。 三态门：高电平、低电平、高阻态 组合逻辑电路 做题方法：写出真值表需求逻辑表达式，用卡诺图化简，化简完成之后电路表达。 竞争与冒险判别方法：各种情况的代入，只留一种变量不变，若出现如f = a + 非a的情况，存在竞争，竞争的结果是冒险。卡诺图法，有相切的部分有竞争 消除竞争的方法：添加冗余项，把相切的地方添加至电路。滤波法选通法（这俩没用） 优先编码器 74148允许同时输入两个以上编码信号，在同时存在两个或两个以上输入信号时，优先编码器只按优先级高的输入信号编码，优先级低的则不起作用。 74148是一个8线-3线优先编码器，8线指的输入、3线是输出。特点是端口都是非。 非I0~非I7是输入信号。 非Ie是输入端，若为1则禁止编码。输出均为1，若为0则正常工作 非Oe使能输出端，低电频工作表示“电路工作，但无编码输入” 非Ge为片优先编码输出端，低电频工作表示“电路工作，且有编码输入” IOG均为扩展时所用。 由于输出带非门，所以输出的是二进制反码 由于输入带非门，所以输入0为有效 扩展时例图为 译码器 74138和74148差不离，输出是反码，输入是原码，3-8输出译码器。 S1是原码，S23是反码 S1要输入高电频，S23口要输入低电频才可以正常工作，否则都为1。正常工作示意图： 可以把它当成最小项，做一些需要最小项的题 两个的扩展，可以把低位的s2或3接到高位的s1上，这样就可以控制一个工作一个不工作，其他的都接地，如图 数据选择器 只有非S是反码，是控制端，0正常工作，两个选择端，四个数据输入端。 直接看题","categories":[{"name":"数字电路","slug":"数字电路","permalink":"http://ranxb.cn/categories/数字电路/"}],"tags":[{"name":"数字电路","slug":"数字电路","permalink":"http://ranxb.cn/tags/数字电路/"},{"name":"笔记","slug":"笔记","permalink":"http://ranxb.cn/tags/笔记/"}]},{"title":"数字电路第六章：同步时序逻辑电路——下","slug":"数字电路第六章：同步时序逻辑电路——下","date":"2018-01-06T08:29:26.000Z","updated":"2018-01-06T13:47:29.410Z","comments":true,"path":"2018/01/06/数字电路第六章：同步时序逻辑电路——下/","link":"","permalink":"http://ranxb.cn/2018/01/06/数字电路第六章：同步时序逻辑电路——下/","excerpt":"","text":"数字电路第六章：同步时序逻辑电路——下状态编码 在求得最简状态码之后，需要对状态表中用字母或数字表示的状态用一组二进制代码来代替，称之为状态编码（也叫状态赋值或状态分配） 状态编码的任务 确定状态编码的长度，即二进制代码的位数或者是触发器的个数。 确定二进制编码的分配方案。 状态编码的长度确定每个触发器可以代表一位二进制数，n个触发器可以代表n位二进制数，组成2n个二进制代码。 所需状态数M和触发器个数n之间应满足以下关系: 2n-1 &lt; M ≤ 2n 确定二进制编码分配方案因为编码和状态配合的方式很多，徐阿哟选择最佳的编码方式。若当N=4, n=2时，就有24种状态分配方案。随着状 态数目的增加，状态分配方案的总数将急剧增加。状态编码解决的主要问题是确定一组使次态函数(或驱动方程)和输出函数尽可能简单、可靠的 状态编码,称之为最佳编码。 分配的基本原则 在状态表中同一输入下的相同次态所对应的现态，尽可能分配相邻编码。通常称为“次态相同，现态编码相邻”。 在状态表中，同一现态，相邻输入下的不同次态，应尽可能分配相邻编码。通常称为“同一现态，次态编码相邻”。 在状态表中某些输出完全相同的现态。那么尽可能给现态分配相邻的编码，通常称“输出相同，现态编码相邻”。 在状态表中，出现次数最多的状态通常给予逻辑0的编码。 注意：一般情况下，应优先考虑原则(1)，因为原则 (1)最重要！例：结果如下： 同步时序逻辑电路设计举例例题一例题：试设计一个序列数据检测器，该电路用来检测输入的串行二进制序列，当输入连续出现110时，检测器输出为1，其他情况下输出为0。 进行逻辑抽象画出状态转换图和状态转换表 进行状态化简，因为全部确定，建立最简等效类 状态编码，状态可用两个二进制编码表示，S0出现的最多设为00，S1=01，S2=11 根据状态表求出状态方程，驱动方程和输出方程，画出Z的卡诺图，Q2n+1和Q1n+1的卡诺图 并根据卡诺图的化简结果写出输出方程，状态方程，并带入触发器的特征方程写出驱动方程。 经过对比特征方程的标准形式，写出j和k，并画出逻辑电路图。 判断自启动，当电路处于无关状态时，是否可以通过时钟脉冲的作用下进入有效状态。 例题二例题：试设计一个同步七进制计数器，要求按二进制加计数规律变化。 确定状态转换情况，注意看题是七进制，因此111位无效情况。确定编码状态因为是Moore型电路，跟输入无关，所以卡诺图这么画通过卡诺图写出状态方程，经验来看Moore型电路都用D触发器写出驱动方程，画出电路图最后检查一下自启动 常用集成时序逻辑电路及应用 寄存器好像不考，直接计数器了。 计数器一种对输入脉冲信号进行计数的时序逻辑部件。可以分为： 二进制计数器和非二进制计数器 加计数器、减计数器和可逆计数器 同步计数器和异步计数器 集成计数器同步集成计数器74LS19174LS191功能及其真值表 异步集成计数器74LS29074LS290重点！ 中规模集成电路74LS290是典型的异步BCD码十进制计数器。逻辑电路如下功能分析 若在CPa端输入时钟脉冲，则Qa输出信号是CPa的脉冲二分频 FB,FC,FD三个触发器构成的逻辑电路是一个异步五进制计数器，其CPB为计数脉冲输入端，QD为输出端。即QD的输出信号是CPB脉冲的五分频。 若将CPB与QA相连，同时以CPA为输入计数脉冲端。QD的输出为十进制计数器(或十分频器)。因此，又将这个电路称为二、五、十进制异步计数器。真值表真值表的分析 直接复位输入端R01和R02：当R01=R02=1，且S91,S92中有“0”时，可使各触发器清为零。 置“9”输入端S91和S92：其状态QDQCQBQA = 1001,这就是置“9”功能。 在置“9”输入端S91,S92和复位输入端R01,R02中均有“0”电平时，74LS290可实现计数功能。 任意进制计数器的构造方法例：用74LS290和适当的门电路构成64进制计数器，采用5421BCD码计数。 Cb和Qa接时，Ca输入时钟信号，输出顺序为dcba，计数方式为8421 Ca和Qd接时，Cb接时钟信号，输出顺序为adcb，计数方式为5421 环形计数器环形计数器是将移位寄存器的最后一级输出 反馈到第一级串行输入端SR，特点是构成的 计数器模数M和所用触发器个数n相等。","categories":[{"name":"数字电路","slug":"数字电路","permalink":"http://ranxb.cn/categories/数字电路/"}],"tags":[{"name":"数字电路","slug":"数字电路","permalink":"http://ranxb.cn/tags/数字电路/"},{"name":"笔记","slug":"笔记","permalink":"http://ranxb.cn/tags/笔记/"}]},{"title":"数字电路第六章：同步时序逻辑电路——上（状态编码之前）","slug":"数字电路第六章：同步时序逻辑电路——上（状态编码之前）","date":"2018-01-05T16:55:39.000Z","updated":"2018-01-06T08:23:13.442Z","comments":true,"path":"2018/01/06/数字电路第六章：同步时序逻辑电路——上（状态编码之前）/","link":"","permalink":"http://ranxb.cn/2018/01/06/数字电路第六章：同步时序逻辑电路——上（状态编码之前）/","excerpt":"","text":"数字电路第六章：同步时序逻辑电路——上（状态编码之前） 讲同步时序逻辑电路的工作原理、分析方法和设计方法。逻辑电路分为：组合逻辑电路和时序逻辑电路。组合逻辑电路是指典礼在任何时刻所产生的输出仅取决于该时刻电路的输入。时序逻辑电路按其工作方式不同分为：同步时序逻辑电路、异步时序逻辑电路。本章介绍同步时序逻辑电路的分析与设计。 同步时序逻辑电路的模型和描述方法同步时序逻辑电路的结构模型同步时序逻辑电路是一种与时序有关的电路，一般说来，是由组合电路和存储电路两部分组成，并形成反馈电路。组合逻辑电路的输出 向外输出 Z 内部输出 Q 组合逻辑电路的输入 外部输入：整个时序电路的输入 X 内部输入：存储电路的内部输出 Y 函数的意义Zi称为输出函数Yj称为驱动方程Mealy型电路：Z的输出既和存储电路的输出有关有和当前状态的输入x有关。Moore型电路：Z的输出只和存储电路的输出有关。采用时钟控制的触发器构成存储电路存储时序电路中的二进制信息被定义为电路的状态，触发器的状态就称为时序电路的状态。向量函数时钟信号不能间隔过短，要状态状态稳定后再一个信号再来。 同步时序逻辑电路的描述方法为了形象的表示时序逻辑电路的全过程性，把电路在一系列的时钟信号作用下状态转换的全过程找出来，则电路的逻辑功能就一目了然了。描述时序电路状态的转换全部过程的方法： 状态方程 状态转换表（状态转换真值表） 状态转换图（简称状态图） 时序图（波形图） 状态方程输出方程：表示输出与输入和现态的关系驱动方程：表示现态向次态转换所需的条件状态方程：表示在给定的输入下将使现态转向状态 状态转换表由现态Q、次态Qn+1和输出Z组成。例： 状态转换图在状态转换图中以圆圈表示电路的各个状态，以箭头表示状态转换的方向。 同时，还在箭头旁注明了状态转换前的输入变量取 值和输出值。通常将输入变量取值写在斜线以上，将输出值写在斜线以下。 时序图将状态转换表的内容画成时间波形图。在时钟脉冲序列作用下，电路状态、输出状态随时间变化的波形图叫做时序图。而且便于用实验观察的方法检查时序电路的逻辑功能。 同步时序逻辑电路的分析方法根据给定的逻辑电路图，找出他的状态方程、输出方程、状态图和时序图。用这些方法来描述电路的工作全过程及输入输出关系。 时序逻辑电路的分析步骤找出给定时序电路的逻辑功能即找出在输入信号和时钟信号作用下，电路的次态和输出。一般步骤如下： 根据给定的逻辑电路图，写出每个触发器的驱动方程（控制方程）。 把得到的驱动方程带入相应的触发器的特性方程，得出每个触发器的状态方程，从而写出这些状态方程的方程组。并写出输出方程。 建立状态转换真值表 做出状态图和时序波形图。 总结功能。 同步时序电路分析的例子 找每个触发器的输入端，写方程，=1的框框是环和。 把写好的方程带入触发器的特征方程例，写出次态的状态方程，在找输出端写出输出方程。 列表，横纵分别有触发器现态和输入值，结果是触发器次态和输出值。 画圈圈，把触发器的变化过程用圈圈画出来，箭头写上输入值和输出值。 总结。 注意，Moore型的因为次态和输入无关，所以只列输出的表的顺序即可，Mealy型的因为和输入有关所以要建和输入有关的表，注意没有排列到的状态要单独加上，类似于：整个例如Moore型的例题： 同步时序逻辑电路的设计设计同步时序逻辑电路的过程 根据实际要求进行逻辑抽象，得出电路的原始状态转换图和转换表。 状态化简，求最简状态化简表。 状态编码。第一步. 确定触发器的数目n 第二步. 给每个电路状态分配一组二进制代码，称为状态编码。 选定触发器类型，求出电路的状态方程。根据状态转换图(或状态转换表)和选定的状态编码、触发器的类型，就可写出电路的状态方程、驱动方程和输出方程。 根据方程式画出逻辑电路图。 检查自启动，解决办法：一、通过预置数。二、修改逻辑设计。 整体步骤如图所示： 建立原始状态转换图和转换表 完全确定原始状态表化简状态表化简的原则（若状态表中的任意两个状态Si和Sj，同时满足下列两个条件，则他们可以合并成一个状态）： 在所有可能的现输入下，两个（或多个）状态相应的现输出分别相同。 在所有可能的现输入下，次态分别为下列情况之一： a. 两个次态完全相同 b. 两个次态为状态对循环的一个状态对 c. 两个次态为其现态本身或交错 d. 两个次态的某一后序状态可以合并 上述的第一个条件是状态合并的必要条件，该条件不满足就无需再考虑第二个条件。 根据状态表化简的原则，利用下列判别方法造出状态表中全部的出状态并对进行分类合并。 等效状态和等效类等效状态—满足上述合并条件的两个状态如Si和Sj称为等效状态，或称等效状态对，记为{Si, Sj}。等效状态的传递性——若状态Si和Sj等效,状态Sj和Sm等效，则状态Si必和Sm等效,称为等效状态的传递性，记为{Si,Sj}{Sj,Sm}→{Si,Sm} 等效类——彼此等效状态的集合。最大等效类——若一个等效类不包含在任何其它等效类之中，则称它为最大等效类。这里说的最大，并不是指包含的状态最多，而是指他的独立性！。 显然，状态表的化简的根本任务在于从原始状态表中找出最大等效类，并用一个状态代替。例如： 用隐含表法化简隐含表是一个斜边为阶梯型的直角三角形网络。及横向和纵向格数相同，格数为原始状态表的状态数减一。然后顺序比较，往表格里填东西。依次比较，若两个状态不是等效对就画X，如果两个状态是等效对则画√，若不确定的则写出下一组状态对，如表：例如CF对完全相同则画✅，又例如AD输出Z都不一样则画叉。还有比如AB两个，输出一样，但是X=0时的次态不同，则无法确定则将CF写入，X=1时因为是两个交换对所以是满足的条件，不用将其写入。最后列出下表：根据等效关系的传递性，对等效状态对 {A,B}、{A,E}、{B,E}构成等效类{A,B,E}。 等效状态对{C,F}也是等效类。由于等效类 {A,B,E}和{C,F}互不包含在对方的等效类中， 所以，等效类{A,B,E}和{C,F}都是最大等效类。而状态G和D不和任何其它状态等效，因此,它们本身也是一个最大等效类,分别记作{G}和{D}。因此最大等效集合{A,B,E}，{C,F}，{D}，{G} 建立最简状态表。最大等效类集合必须覆盖原始状态表的全部状态。原始状态表中每一个状态只能属于一个最大等效类。这样，每个最大等效类可用一个状态代替。即:a={ABE} b={CF} c={D} d={G}由此可得最简状态表： 不完全确定状态表的化简这种电路的 状态表包含着不确定的次态或输出，所以，是一种不完全确定电路。并不是任何输出序列都是有效的。不完全确定状态表的化简是基于相容状态的，再利用任意项可使状态表 化的更简。相容状态——再不完全确定表中，假设S1和S2为初始状态，如果对于所有的有效输入序列从状态S1和S2除法他们相应的输出序列（除不确定的那些之外）是完全相同的，那么状态S1和S2是相容的，或者说S1和S2是相容对，记作（S1，S2）相容状态的条件——在所有可能输入条件下，两个状态对应的输出相同，或者其中一个（或两个）输出为任意值；并且它们的次态相同、交错、循环、相容，或者其中一个（或两个）为任意状态，那么这两个状态是相容的。相容类——由彼此相容的状态构成的集合，处于同一相容类 中的所有状态之间都是两两相容的。非传递性——状态等效具有传递性，而状态相容不具有传递性。 因此，若要求(S1, S2，S3)相容，则必须(S1,S2)， (S2,S3)，(S1,S3)都是相容对。也就是说，相容类中所有状态之间都分别是两两相容的。最大相容类——若一个相容类不是任何其他相容类的子集，则该相容类称为最大相容类。例题：表中由于部分状态的次态和输出无法确定，所以是不完全确定状态表。 做隐含表并比较，如图2.在相容状态对中找最大相容类 确定原始状态表的最小闭合覆盖集 选择一个同时满足覆盖、闭合和最小三个条件的相容类集合，将每个相容类用一个新状态来代替，以得到一个新的状态表。 覆盖——指相容类集合中包含了原始状态表的全部状态。即原始状态表中任何一个状态至少包含在相容类集合中的一个相容类(包括最大相容类)中，而不能遗漏。闭合——指一个相容类集合中,任一相容类的所有隐含条件都必须属于该集合中某一个相容类(包括最大相容类)。最小——是指满足覆盖和闭合的相容类数目最少。不完全状态表的简化，就是寻找一个最小闭合覆盖为了反应闭合和覆盖这两个性质，建立闭合覆盖表：在表的左边自上而下列出所选相容类，表的中间覆盖部分自左到右列出全部状态，表的右边闭合部分列出各相容类在输入各种取值组合下的次态组合。必须指出，这里所说的相容类包括最大相容类和它们的子类。找到了覆盖闭合最小之后，就可以画出最简状态表：","categories":[{"name":"数字电路","slug":"数字电路","permalink":"http://ranxb.cn/categories/数字电路/"}],"tags":[{"name":"数字电路","slug":"数字电路","permalink":"http://ranxb.cn/tags/数字电路/"},{"name":"笔记","slug":"笔记","permalink":"http://ranxb.cn/tags/笔记/"}]},{"title":"汇编语言第十二。。章：内外中断和int指令","slug":"汇编语言第十二。。章：内外中断和int指令","date":"2018-01-04T16:33:03.000Z","updated":"2018-01-05T16:54:54.210Z","comments":true,"path":"2018/01/05/汇编语言第十二。。章：内外中断和int指令/","link":"","permalink":"http://ranxb.cn/2018/01/05/汇编语言第十二。。章：内外中断和int指令/","excerpt":"","text":"汇编语言第十二。。章：内外中断和int指令 不再过多说中断是什么了，就是可以随时控制CPU停止当前的指令干其他的事的意思，下面内中断程序的步骤： 将程序写入0:200开始的空间内，同时把字符什么的也要定义进去。 设置中断向量表，前面是ip，后面是cs。注意高低位。 单步中断的操作 取得中断类型码 标志寄存器入栈 标志寄存器TF和IF置零，防止在中断程序中在中断。 CS内容入栈 IP入栈 根据中断类型码从中断向量表中设置中断程序的CS和IP。 中断处理程序的编写方法 保存用到的寄存器 处理中断 恢复寄存器 iret iret用来返回程序：操作为： pop ip pop cs popf 目的是回到执行中断处理程序之前的执行点继续执行程序。 编写0号中断程序assume cs:code ss:satck ds:data code segment start: mov ax,cs mov ds,ax mov si,offset do0 ;ds:si指向do0中断程序部分 mov ax,0 mov es,ax mov di,200h mov cx offset do0end - do0 cld rep movsb mov ax,0 ;安装中断程序 mov es,ax mov word ptr es:[0],200h mov word ptr es:[0+2],0 mov ax,4c00h int 21h do0: jmp short do0start db &quot;overflow!&quot; do0start: mov ax,cs mov ds,ax mov si,202h ;ds:si指向字符串 mov ax,0b800h mov es,ax mov di,12*160+36*2 ;es:di指向显存空间 mov cx,9 s: mov al,[si] mov es:[di],al inc si add di,2 loop s mov ax,4c00h int 21h 中断的特殊情况设置栈的操作不会响应中断，因为中断会进行栈操作，需要设置正确的栈顶，所以设置sp的指令应当紧接着设置ss的指令 int指令格式：int n，n为中断类型码int指令的最终功能和call类似，都是调用一段程序。中断处理程序简称为中断例程 编写供应用程序调用的中断例程明天再写详细的 BIOS和DOS多提供的中断例程的安装过程 CPU加电，初始化(CS) = 0FFFFH，(IP) = 0，从FFFF：0开始执行程序。此处有一条跳转指令，跳转后开始执行BIOS中的硬件系统检测和初始化程序 初始化程序建立BIOS所支持的中断向量表，只需登记中断向量表，中断程序在ROM中，一直在内存中存在 硬件检测和初始化完成之后，调用int 19h，进入操作系统引导程序。 DOS启动，将所提供的中断例程装入内存，并建立中断向量表。 BIOS和DOS的中断例程的应用就是应用了，比如BIOS中的彩色显示int 10h和DOS中的输出字符串int 21h。明天再写 汇编语言：完～","categories":[{"name":"汇编语言","slug":"汇编语言","permalink":"http://ranxb.cn/categories/汇编语言/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://ranxb.cn/tags/笔记/"},{"name":"汇编语言","slug":"汇编语言","permalink":"http://ranxb.cn/tags/汇编语言/"}]},{"title":"汇编语言第十一章：标志寄存器","slug":"汇编语言第十一章：标志寄存器","date":"2018-01-04T16:26:41.000Z","updated":"2018-01-04T16:28:56.877Z","comments":true,"path":"2018/01/05/汇编语言第十一章：标志寄存器/","link":"","permalink":"http://ranxb.cn/2018/01/05/汇编语言第十一章：标志寄存器/","excerpt":"","text":"汇编语言第十一章：标志寄存器 标志寄存器就是CPU处理数据的时候做标记的这一章学的有ZF，SF，PF，CF，OF标志寄存器，还有adc，sbb，movsb，movsw，cld，std，rep等操作 第六位：ZFzero flag零标志位处理完之后是否为零，0的话ZF则为一 第二位：PFParity flag奇偶校验位换成二进制之后，1的个数是偶数？PF = 1 ：PF = 0 第七位：SFsign flag符号标志位结果是否为负，只看第一位符号位 第零位：CFcarry flag进位标识符是否有进位或者借位inc和loop不影响CF位 第十一位：OFoverflow flag溢出标志位 adc指令带进位的加法指令add carryadc a,b相当于a = a + b + cf作用： add ax,bx 相当于 add al,bl adc ah,bh sbb指令带借位的减法指令sub borrowsbb a,b相当于a = a - b - CF CMP指令相当于减法，但不保存结果，只会影响标志寄存器CF和ZF 检测比较结果的条件转移指令和CMP配合使用 je equal jne not equal jb below jnb not below ja above jna not above 第十位：DF标志和串的传送DF direcition(down?) flag格式：movsb （mov string byte？）功能：复制一段数据？差不多，主要就是执行以下操作 ((es)*16+di) = ((ds)*16+si) 若df = 0: si++; di++ 若df = 1: si–; di– 上面的是传一个内存单元，也可以传一个字格式：movsw （mov string word？） mov word ptr es:[di],ds:[si](并不支持这样的指令，只是描述) 若df = 0: si+=2; di+=2 若df = 1: si-=2; di-=2 可以配合rep使用，rep就是重复cx次当前指令，例如 rep mov sb 相当于 s: movsb loop s 这样就可以实现cx个字符的传送 设置DF的指令 cld：将DF设置为零（clear df） std：将DF设置为一 (set df) pushf和popf标志寄存器的出入栈","categories":[{"name":"汇编语言","slug":"汇编语言","permalink":"http://ranxb.cn/categories/汇编语言/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://ranxb.cn/tags/笔记/"},{"name":"汇编语言","slug":"汇编语言","permalink":"http://ranxb.cn/tags/汇编语言/"}]},{"title":"汇编语言第十章：CALL和RET指令","slug":"汇编语言第十章：CALL和RET指令","date":"2018-01-04T15:33:06.000Z","updated":"2018-01-04T16:27:28.652Z","comments":true,"path":"2018/01/04/汇编语言第十章：CALL和RET指令/","link":"","permalink":"http://ranxb.cn/2018/01/04/汇编语言第十章：CALL和RET指令/","excerpt":"","text":"汇编语言第十章：CALL和RET指令 都是修改ip的，重点不多，会用就行，随便写写。 ret和retfret进行近转移，只修改IPretf进行远转移，修改IP和CS ret指令的操作出栈操作 (IP) = ((ss)*16+sp) (sp) = (sp)+2相当于pop IP retf指令的操作先出ip，再出cs (IP) = ((ss)*16+sp) (sp) = (sp)+2 (CS) = ((ss)*16+sp) (sp) = (sp)+2相当于pop ip；pop cs CALL指令 两步操作 IP或CS和IP压入栈 转移 (CALL的转移位移是16位的，也就是短转移，不支持近转移) 根据位移进行转移的CALL指令先压栈，在转移 (sp) = (sp)-2 ((ss)*16+sp) = ip ip转移 格式：CALL 标号 根据目的地址转移的CALL指令格式： call far prt 标号 实现的是段间转移执行此命令时进行如下操作： push CS push IP CS：IP转移 地址在寄存器中的CALL指令格式： call 16位的reg例如： call ax相当于：push ipjmp ax 转移地址在内存中的CALL指令CALL WORD PRT 地址两个字节16位，只转移IP CALL DWOERD PRT 地址四个字节32位，转移CS和IP RET和CALL的配合使用当正常函数用，没什么区别要先push 前面用到的寄存器的值前面CALL，后面RET MUL指令乘法指令，和除法指令类似，只是要不都是8位的，要不都是16位的。 8位的AL放一个，然后MUL一个8位的内存单元，结果放在AX里面如100*10: mov al,100 mov bl,10 mul bl 最后结果在AX里或者mul一个内存单元，还是例如： mov al,100 mov ds:[0],10 mul byte ptr ds:[0] 16位的AX放一个，然后MUL一个16位寄存器或者内存单元，结果高位在DX里，低位在AX里。例如1000*10： mov ax,1000 mov bx,10 mul bx 结果换成16进制，高位在DX里，低位在AX里。 除法在第八章","categories":[{"name":"汇编语言","slug":"汇编语言","permalink":"http://ranxb.cn/categories/汇编语言/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://ranxb.cn/tags/笔记/"},{"name":"汇编语言","slug":"汇编语言","permalink":"http://ranxb.cn/tags/汇编语言/"}]},{"title":"数字电路第五章：集成双稳态触发器","slug":"数字电路第五章：集成双稳态触发器","date":"2018-01-04T11:31:33.000Z","updated":"2018-01-04T14:53:13.378Z","comments":true,"path":"2018/01/04/数字电路第五章：集成双稳态触发器/","link":"","permalink":"http://ranxb.cn/2018/01/04/数字电路第五章：集成双稳态触发器/","excerpt":"","text":"集成双稳态触发器 主要内容有 触发器的特点及分类 基本的RS触发器 事中控制的RS触发器，D触发器，JK触发器，T触发器的电路结构、逻辑功能及其描述方法。 触发器的性能参数。 触发器的基本特点及分类输入量和输出量的设置 s0和R0代表初始状态预置输入量，X1和X2是正常工作的时候的输入量，Q为输出量，要求有两个相反的所以叫Q和非Q。钟控式的再加一个CP为时钟控制输入量。 触发器输出与约束方程的一般表达式设触发器输出次态的取值记作Qn+1，现态取值记Qn触发器正常时要求R0 = S0 = 1！。 触发器的分类 基本RS双稳态触发器及其分析 本RS触发器是各种触发器电路中结构形式最简单的一种。同时，它又是复杂电路结构触发器的一个基本组成都分。 RS型（set reset）的电路结构和基本原理 习惯上将电路画成图5-4(b)的对称形式。Q和Q称为输出端，并且定义Q=1、Q=0为触发器的1状态， Q=0、Q=1为触发器的0状态。S为置位端或置1输入端，R成为复位端或置0输入端。(1)当S=1，R=0时，Q=1,非Q=0。(2)当S=0，R=1时，Q=0,非Q=1。(3)当S=R=0时，电路维持原来状态不变。(4)当S=R=1时，Q = 非Q= 0，既不是定义的1状态， 也不是定义的0状态。真值表如下输入信号在S或R为1的全部作用时间里， 都能直接改变输出端Q和Q的状态，这就是基本RS触发器的工作特点。这个缘故，也把S(非S)叫做直接置位端; 把R(非R)叫做直接复位端 时钟RS触发器及其分析触发器翻转的状态仍由输入控制端的电平情况决定，但翻转的时刻应由统一的脉冲信号来进行控制，这类控制信号称为时钟脉冲，CP (Clock Pulse)表示。这类触发器成为同步触发器 时钟RS触发器结构与工作特性 真值表如下（即为只有CP为一时即触发） 一般在使用同步触发器时，有时还需要在cp信号来之前将触发器预置成指定状态，所以可能会出现专门的异步置位输入端S和异步复位输入端R，使触发器置于指定状态。 空翻现象如果CP=1的期间内输入信号多次发生变化，则触发器的状态也会发生多次翻转，这就降低了电路的抗干扰能力，也叫“空翻”现象。 主从触发器 主从RS触发器动作特点：主从RS触发器的动作分两步完成。先在CP=1期间，主触发器接收输入驱动RS信号进行主触发器的状态修改，但从触发器不动作。第二步，在CP=0时刻，从触发器按照此时主触发器的状态进行动作。 主从RS触发器解决了空翻问题，但在CP=1期间，RS仍存在约束条件。RS = 0 (约束条件）特征表如下： 时钟D触发器及其分析电路结构与工作原理为了适用于单端输入信号的场合，在有些集成电路中也把同步RS触发器作成下图的结构形式 通常把这种电路叫D型触发器(或D型锁存器)。 逻辑功能及其描述方法功能真值表和激励表RS触发器演变而来，它克服了RS触发器在 S=R=1时，次态不定的功能不完善缺点。 D触发器的空翻D触发器依然存在“空翻”现象，实际广泛使用的集成D触 发器采用了维持阻塞结构，称为维持阻塞D触发器。 维持阻塞D触发器状态变化产升在时钟脉冲的上升沿，其次态决定于该时刻前瞬间输入信号D。 时钟JK触发器及其分析为了消除时钟控制RS 触发器输入信号的约束条件，又使触发器有两个输入端，可在时钟控制RS触发器中增加两条交叉反馈线，并将输入端S改为J，R改为K。 逻辑功能及其描述方法功能真值表和激励表 特征方程： Qn+1 = J 非Q + 非k Q 主从集成JK触发器和RS触发差不多 时钟T触发器及其分析T触发器可看成是JK触发器在J=K条件下的特例T触发器的逻辑功能可概括为：T=0时触发器保持原状太不变；T=1时触发器翻转。 特征方程总结","categories":[{"name":"数字电路","slug":"数字电路","permalink":"http://ranxb.cn/categories/数字电路/"}],"tags":[{"name":"数字电路","slug":"数字电路","permalink":"http://ranxb.cn/tags/数字电路/"},{"name":"笔记","slug":"笔记","permalink":"http://ranxb.cn/tags/笔记/"}]},{"title":"数字电路电路板汇总","slug":"数字电路电路板汇总","date":"2018-01-04T03:22:16.000Z","updated":"2018-01-06T09:16:16.377Z","comments":true,"path":"2018/01/04/数字电路电路板汇总/","link":"","permalink":"http://ranxb.cn/2018/01/04/数字电路电路板汇总/","excerpt":"","text":"数字电路电路板汇总变量译码器74138三输入、八输出。s1为一，s2和s3为零即可正常工作。根据二进制输入输出十进制的特定端口。两个同时使用的时候，低位s1接1，s2接高位s1作为输入的第四端口。如图 7448显示译码器TS547显示器数据选择器74LS153针脚如图所示真值表如图所示做题时会给多个输入端，此时想A0A1当成两个输入端，再从D端口中根据选择器的输出表达式连接相应第三段口即可，例如： 多位数值比较器7485下图为数值比较器7485的单位针脚图下图为用多个数值比较器7485的多位数值比较器的基本原理 奇偶校验器74LS280四位二进制奇偶校验的真值表奇偶校验位逻辑表达式 74LS280奇偶校验/发生器 实际应用如下","categories":[{"name":"数字电路","slug":"数字电路","permalink":"http://ranxb.cn/categories/数字电路/"}],"tags":[{"name":"数字电路","slug":"数字电路","permalink":"http://ranxb.cn/tags/数字电路/"},{"name":"笔记","slug":"笔记","permalink":"http://ranxb.cn/tags/笔记/"}]},{"title":"汇编第九章：转移指令的原理","slug":"汇编第九章：转移指令的原理","date":"2017-12-30T09:41:24.000Z","updated":"2017-12-30T13:30:04.582Z","comments":true,"path":"2017/12/30/汇编第九章：转移指令的原理/","link":"","permalink":"http://ranxb.cn/2017/12/30/汇编第九章：转移指令的原理/","excerpt":"","text":"汇编第九章：转移指令的原理 概括地讲，转移指令就是可以控制CPU执行内存中某处代码的指令。表现为可以修改IP或者同时修改CS和IP的指令。 以下讨论8086转移行为的分类第一类：只修改IP的转移行为叫做段内转移 根据转一指令对IP的修改范围不同，段内转移可分为。 短转移：IP的修改范围为-128 ～ 127. 近转移：IP的修改范围为-32768 ～ 32767. 第二类：同时修改CS和IP的转移行为叫段间转移 转一指令的分类 无条件转移指令，例如jmp 条件转移指令 循环指令，例如loop 过程 中断 本章主要通过深入学习无条件转移指令jmp来理解CPU执行转移指令的基本原理 offset功能是取得标号地址的偏移地址 code segment start: mov ax,offset start ;相当于mov ax,0 s: mov ax,offset s ;相当于mov ax,3 jmpjmp为无条件跳转指令，可以只修改IP，也可以同时修改CS和IP。jmp指令要给出两种信息： 转移的目的地址 转移的距离（段间转移、段内转移、段内近转移） 依据位移进行转移的jmp指令NO.1 jmp short 标号（转到标号处执行指令） 这种格式实现的事段内短转移，他对IP的修改范围是-128 ～ 127，转移指令结束后，CS:IP应该指向标号指令。 根据机器码可得出CPU执行jmp指令时机器码中并不需要转移的目的地址 CPU执行指令的过程 从CS:IP执行内存单元读取指令，读取的指令进入指令缓冲器; (IP) = (IP) + 读取的长度，从而指向下一个指令; 执行指令。转到(1)，重复. 由此可得，执行jmp并不需要目的地址，而是需要位移地址short的位移量存储空间占一个字节，8个二进制位，首位为符号位，用补码表示，因此可表示的位移量为-128 ～ 127。同理，near的位移量储存空间占两个字节，16个二进制位，首位为符号位，用补码表示，因此可表示的位移量为-32768 ～ 32767。 由上引入近转移 jmp near ptr 标号（段内近转移） 转移的目的地址在指令中的jmp指令前面讲的是段内转移，因此jmp只需要位移地址即可进行对IP的修改。 jmp far ptr 标号 以上实现的是段间转移，又称远转移。可以让(CS) = 标号所在的段地址;(IP) = 标号所在的偏移地址。 转移地址在寄存器中的jmp指令jmp 16位reg 功能：(IP) = (16位reg)用寄存器中的值修改IP。 转移地址在内存中的jmp指令 两种格式 段内转移 jmp word ptr 内存单元地址 ;(段内转移) 从内存单元地址处开始存放着一个字，是转移的目的的偏移地址。例如： mov ax,0123H mov ds:[0],ax jmp word ptr ds:[0] 执行后(IP) = 0123H 段间转移 jmp dword ptr 内存单元地址 ;(段间转移) 从内存单元地址处开始存放着两个字节，是转移的目的的段地址和偏移地址，高地址是段地址，低地址是偏移地址(CS) = 内存单元地址+2(IP) = 内存单元地址比如一下指令： mov ax,0123H mov ds:[0],ax mov ax,4567H mov ds:[2],ax jmp dword ptr ds:[0] 执行完后(CS) = 4567H,(IP) = 0123H。 jcxz指令jcxz是有条件转移指令，所有的有条件转移指令都是短转移指令，对应的机器码中包含的是转移位移，不是目的地址。对IP的修改范围都是-128 ~ 127。 jcxz == jmp when cx is zero当cx为零时，执行转移指令，若不为零，则不转移使用格式： jcxz 标号 loop指令loop指令位循环指令，所有的循环指令都是短转移。详见第五章 根据位移进行转移的意义jmp short x jmp near ptr x jcxz x loop 以上都是根据转移的位移量进行转移的，这样有利于程序在内存中的浮动装配，意思就是把这段程序装在内存中的任意一段空间内都可以执行，不会因为转移的地址不同而导致程序不能执行。 编译器对转移位移超界的检测jmp超界编译器会报错，别的没其他知识点","categories":[{"name":"汇编语言","slug":"汇编语言","permalink":"http://ranxb.cn/categories/汇编语言/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://ranxb.cn/tags/笔记/"},{"name":"汇编语言","slug":"汇编语言","permalink":"http://ranxb.cn/tags/汇编语言/"}]},{"title":"汇编第八章：数据处理的两个基本问题","slug":"汇编第八章：数据处理的两个基本问题","date":"2017-12-28T19:23:25.000Z","updated":"2017-12-30T09:40:34.461Z","comments":true,"path":"2017/12/29/汇编第八章：数据处理的两个基本问题/","link":"","permalink":"http://ranxb.cn/2017/12/29/汇编第八章：数据处理的两个基本问题/","excerpt":"","text":"汇编第八章：数据处理的两个基本问题 章前言说的是对前面所有的内容是有总结性的，这里主要探讨两个问题： 处理的数据在什么地方？ 处理的数据有多长？ 定义两个符号reg和sregreg代表寄存器，包括：ax,bx,cx,dx,ah,al,bh,bl,ch,cl,dh,dl,sp,bp,si,disreg代表段寄存器，包括：ds,ss,cs,es bx、si、di、bp的使用规则 三个规则，一会总结，字比较多，等会打。 只有这四个寄存器可以用在[…]中进行寻址 mov ax,[bx] mov ax,[bx+si] 以下的是错误的 mov ax,[cx] mov ax,[ax] 这四个可以单独出现，但是组合的情况只有四种可以使用：bx和si、bx和di、bp和si、bp和di。 mov ax,[bx+si] mov ax,[bx+di] mov ax,[bp+si] mov ax,[bp+di+idata] 以下的是错误的 mov ax.[bx+dp] mov ax,[si+di] 只要使用[…]中bp寄存器时，若没有显式的给出段寄存器，则默认为段地址在ss中 mov ax,[bp] ;(ax) = ((ss)*16+(bp)) 机器指令处理的数据在什么地方机器指令都是经过处理过的数据：1、读取。2、存入。3、运行 所有处理的数据可以在三个地方：CPU内部、内存、端口（后面说先不用管）例如： mov bx,[0] ;内存 mov bx,ax ;CPU内部ax寄存器 mov bx,1 ;CPU内部指令缓冲器 汇编语言中数据位置的表达汇编语言用3个概念来表达数据的位置： 立即数[idata]例如： mov ax,1 add bx,2000H or bx,00010000B mov al,’a’ 以上 寄存器例如 mov ax,bx push ds以上 段地址和偏移地址例如 mov ax,[bx] ;段地址默认在ds中 寻址方式五种寻址方式： [idata] 直接寻址 [bx] 寄存器间接寻址 [bx+idata] 寄存器相对寻址 [bx+si] 基址变址寻址 [bx+si+idata] 相对基址变址寻址 总结：有两个寄存器就是基址变址，只要有idata就是相对（只有idata是直接寻址，只有一个寄存器是寄存器间接寻址） 指令要处理的数据有多长 通过寄存器名可以致命处理的数据长度 在没有寄存器的情况下，用操作符“X ptr”指明要操作的长度，X可以是byte或者是word。例如 mov word prt ds:[0],1 inc word prt [bx] mov byte ptr ds:[0],1 add byte ptr [bx],2 寻址的综合应用 主要就是类c语言的数组的操作，看看书看就行了。 div 两种div方式！(被除数是除号之前的。) 16位寄存器除以8位寄存器：16位做被除数放在AX里面。商在AL里，余数在AH里 32位寄存器除以16位寄存器：高16位放在DX，低16位放在AX里，共32位做被除数。商在AX里，余数在DX里。 商都放在低位寄存器中，余数放在高位，除数放在一个内存单元或者reg中例如： 16位/8位： div byte ptr ds:[0] ;(al) = (ax)/((ds)*16+0) ;(ah) = (ax)mod((ds)*16+0) 32位/8位： div word ptr ds:[0] ;(ax) = [(dx)*10000H + (ax)] / ((ds)*16+0) ;(dx) = [(dx)*10000H + (ax)] mod ((ds)*16+0) 实际应用，例如100001/100,100001 = 186A1H mov dx,1H mov ax,86A1H mov bx,100 div bx ;商在AX里，余数在DX里 dd dd（define double）,用于定义双精度字节，一个双精度占2个字，4个字节。 data segment db 1 dw 1 dd 1 data ends 上面这段： 1. 第一个数据是01H，在data:[0]处 2. 第二个数据是0001H，在data:[1] - data:[2]处 3. 第三个数据是00000001H，在data:[3] - data:[6]处 dup和dd一样都是一个操作符，它是和db、dw、dd等数据定义伪指令配合使用的，用来进行数据的重复，比如： db 3 dup (0) 定义了3个字节，他们的值都是0，相当于 db 0,0,0 又例如： db 3 dup (0,1,2) 定义了9个字节，分别是0,1,2,0,1,2,0,1,2,相当于 db 0,1,2,0,1,2,0,1,2 使用规范如下 db 重复次数 dup (内容) ;(重复的字节型数据) dw 重复次数 dup (内容) ;(重复的字型数据) dd 重复次数 dup (内容) ;(重复的双精度字型数据)","categories":[{"name":"汇编语言","slug":"汇编语言","permalink":"http://ranxb.cn/categories/汇编语言/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://ranxb.cn/tags/笔记/"},{"name":"汇编语言","slug":"汇编语言","permalink":"http://ranxb.cn/tags/汇编语言/"}]},{"title":"汇编第七章：更灵活的定位内存地址的方式","slug":"汇编第七章：更灵活的定位内存地址的方式","date":"2017-12-28T18:46:40.000Z","updated":"2018-01-09T12:05:30.076Z","comments":true,"path":"2017/12/29/汇编第七章：更灵活的定位内存地址的方式/","link":"","permalink":"http://ranxb.cn/2017/12/29/汇编第七章：更灵活的定位内存地址的方式/","excerpt":"","text":"汇编第七章：更灵活的定位内存地址的方式and、or指令and 按位与 mov al,01100011B and al,00111011B 结果为al = 00100011B or 按位和 mov al,01100011B or al,00111011B 结果为al = 01111011B 关于ASCII码data segment db &apos;unIX&apos; data ends 相当于 data segment db 75H,6EH,49H,58H data ends 一个字母一个字节 小写字母ASCII码比大写字母大 将’a’的ASCII码减20H就可以变成大写字母’A’ 将’A’的ASCII码加20H就可以变成小写字母’a’ 当ASCII码大于61H的时候是小写字母 ASCII码的二进制形式第六位为1时是小写字母，0时大写字母 根据上面第五条可以进行大小写转换！ and al,11011111B 可以把字母变成大写 or al,00100000B 可以把字母变成小写 [bx+idata][bx+idata]表示一个内存单元,他的偏移地址是(bx)+idata(bx的值加上idata) mov ax,[bx+200] == ax = ((dx)*16 + (bx) + 200) 该指令也可以写成 mov ax,[200+bx] mov ax,200[bx] mov ax,[bx].200 因此，[bx+idata]的方式为高级语言实现数组提供了便利机制 C语言：a[i],b[i] 汇编语言：0[bx],5[bx]([bx+0],[bx+5]) SI和DISI和DI是8086中和bx相似的寄存器，但是不能像bx一样分成两个八位寄存器来使用因此我们可以更灵活的使用：[bx+si]类似的方式表示一个内存一个内存单元例如： mov ax,[bx+si] 意为(ax) = (dx*16) + (bx) + (si)也可以写成 mov ax,[bx][si] 不同的寻址方式的灵活应用 [idata]用一个常量来表示地址，可用于直接定位一个内存 [bx]用一个变量来表示一个内存，可用于间接定位一个内存单元 [bx+idata]用一个变量和一个常量来表示内存地址，可在一个起始地址的基础上用变量简介定位一个内存，例如数组。 [bx+si]用两个变量表示一个内存地址 [bx+si+idata]用两个变量和一个常量表示一个内存地址 一道大题问题7.9（先复习，回头再写）","categories":[{"name":"汇编语言","slug":"汇编语言","permalink":"http://ranxb.cn/categories/汇编语言/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://ranxb.cn/tags/笔记/"},{"name":"汇编语言","slug":"汇编语言","permalink":"http://ranxb.cn/tags/汇编语言/"}]},{"title":"现代第二章","slug":"现代第二章","date":"2017-12-28T12:08:13.000Z","updated":"2017-12-28T19:34:15.439Z","comments":true,"path":"2017/12/28/现代第二章/","link":"","permalink":"http://ranxb.cn/2017/12/28/现代第二章/","excerpt":"","text":"矩阵向量引入线性相关无关性向量的秩矩阵的运算1）！*不可逆乘* 2）一个行 * 一个列 = 一个数 3）对角全为一的矩阵是单位矩阵计为E 4）单位矩阵相当于乘法中的1 5）任何矩阵与单位矩阵相乘都等于本身 6）若AB == BA ，则称AB是可交换的 7）矩阵的乘法不满足消除律 8）矩阵的转置计为A 9）（AB）t == Bt*At 10) (kA)t == kAt 11）如果At == A，那么这个矩阵式是对称的 12）如果At == -A，那么这个矩阵式是反对称的 13）对角矩阵是只有对角线上的矩阵，A = diag(a,b,c,d...) 14）对角矩阵的数都一样的时候是数量矩阵，全是一的时候单位矩阵。 可交换矩阵(逆矩阵)可交换矩阵的充要条件： (1) 设A , B 至少有一个为零矩阵,则A , B 可交换; (2) 设A , B 至少有一个为单位矩阵, 则A , B可交换; (3) 设A , B 至少有一个为数量矩阵, 则A , B可交换; (4) 设A , B 均为对角矩阵,则A , B 可交换; (5) 设A , B 均为准对角矩阵（准对角矩阵是分块矩阵概念下的一种矩阵。即除去主对角线上分块矩阵不为零矩阵外，其余分块矩阵均为零矩阵）,且对角线上的子块均可交换，则A , B 可交换; (6) 设A*是A 的伴随矩阵,则A*与A可交换; (7) 设A可逆,则A 与其逆矩阵可交换; 注：A的逆矩阵经过数乘变换所得到的矩阵也可以与A进行交换。 (8)（n=0,1..., ）可与 (m=0,1..., )交换.这一点由矩阵乘法的结合律证明。 求所有可交换矩阵 求A的所有可交换矩阵，所以设AZ == ZA，Z = [a,b;c,d]，求出Z即可～ 矩阵的初等变化及其标准型","categories":[{"name":"线性代数","slug":"线性代数","permalink":"http://ranxb.cn/categories/线性代数/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://ranxb.cn/tags/笔记/"},{"name":"线性代数","slug":"线性代数","permalink":"http://ranxb.cn/tags/线性代数/"}]},{"title":"汇编第六章：包含多个短的程序","slug":"汇编第六章：包含多个短的程序","date":"2017-12-28T12:07:59.000Z","updated":"2017-12-28T18:21:14.005Z","comments":true,"path":"2017/12/28/汇编第六章：包含多个短的程序/","link":"","permalink":"http://ranxb.cn/2017/12/28/汇编第六章：包含多个短的程序/","excerpt":"","text":"汇编第六章：包含多个短的程序 dw == define word 一个dw：16位两字节 start…end start如果程序入口不是我们想要执行的指令可以使用start指令指明程序入口所在 assume cs:code code segment . . . dw 0123h,1456h;数据 . . . start: . . . mov ax,0;代码 . . . mov ax,4c00H int 21H code ends end start 一个段的容量不能大于64kb因此可以考虑使用多个段来存放数据、代码、和栈。stack == 栈 8086不允许将一个数值直接送入段寄存器，例如“mov ds,data”。data也会被编译器处理为表示一个段地址的数值 data、satck、code也仅仅是命名而已，就跟标号一样，需要用assume将他们和cpu联系起来因此程序有以下模板 assume cs:code,ss:stack,ds:data data segment dw .......... data ends stack segment dw 0,0,0,0,0,0..... stack ends code segment start: mov ax,data ;数据段空间 mov ds,ax mov bx,0 mov ax,stack ;栈空间 mov ss,ax mov sp,0 . . . code ends start end","categories":[{"name":"汇编语言","slug":"汇编语言","permalink":"http://ranxb.cn/categories/汇编语言/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://ranxb.cn/tags/笔记/"},{"name":"汇编语言","slug":"汇编语言","permalink":"http://ranxb.cn/tags/汇编语言/"}]},{"title":"汇编第五章 [BX]和loop指令","slug":"汇编第五章-BX-和loop指令","date":"2017-12-28T12:07:35.000Z","updated":"2017-12-28T19:33:59.114Z","comments":true,"path":"2017/12/28/汇编第五章-BX-和loop指令/","link":"","permalink":"http://ranxb.cn/2017/12/28/汇编第五章-BX-和loop指令/","excerpt":"","text":"汇编第五章 [BX]和loop指令[bx]表示偏移地址ss:ip 表示栈段push ax的具体流程 push ax: sp = sp - 2; (ss:sp) = ax; pop ax的具体操作 pop ax: ax = (ss:sp); sp+=2; inc ax ax的内容加1 mov ax,2000H 其中ah = 20 al = 00 当 BE 21000H 00 21001H . . . mov ax,2100H; mox dx,ax; mov bx,0; mov ax,[bx] 此时 ax = 00BE ！！意为先存低位，在存高位。 LOOP指令LOOP执行顺序 LOOP执行顺序： 1.CX--; 2.CX==0?顺序执行:循环 CX设置循环次数 例如： mov cx,11 L:add ax,1 LOOP L 将ffff传入ax中的时候要前面加零 mov ax,0ffffH mov dx,ax . . . 汇编语言程序中，数据不能以字母开头 DEBUG和汇编编译器MASM对指令的不同处理DEBUG中：mov al,[0] ;含义：(al) = ((dx)16+0)源程序中: mov al,[0]* ;含义：(al) = 0 在源程序中，如果用指令访问一个内存单元，则在指令中必须用“[…]”来表示内存单元，如果在“[]”里直接用一个常量idata直接给出内存单元的偏移地址，就要在”[]”的前面显示的给出段地址所在的段寄存器。 例如： mov ax,dx:[0] 段前缀以上这样的表示方法dx叫做段前缀类似的比如 mov ax,ds:[0] mov ax,cx:[0] mov ax,ss:[0] mov ax,es:[0] 等等ds:、cx:、ss:、es:、都叫做段前缀 一段安全的空间直接向内存中写入数据时，要用：0:200 ～ 0:2ff","categories":[{"name":"汇编语言","slug":"汇编语言","permalink":"http://ranxb.cn/categories/汇编语言/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://ranxb.cn/tags/笔记/"},{"name":"汇编语言","slug":"汇编语言","permalink":"http://ranxb.cn/tags/汇编语言/"}]},{"title":"汇编语言中寄存器ESP和EBP的理解","slug":"汇编语言中寄存器ESP和EBP的理解","date":"2017-11-04T04:31:45.000Z","updated":"2017-12-28T19:25:54.068Z","comments":true,"path":"2017/11/04/汇编语言中寄存器ESP和EBP的理解/","link":"","permalink":"http://ranxb.cn/2017/11/04/汇编语言中寄存器ESP和EBP的理解/","excerpt":"","text":"汇编语言中寄存器ESP和EBP的理解 学校在做信息活动月，有个活动是对xp系统中的一个应用程序进行反汇编，了解他的运行机制，但是在中间有一部分对寄存器的概念有点生疏，所以在网上看到一个好的材料，所以码一下 一直对寄存器ESP和EBP的概念总是有些混淆，查看定义ESP是栈顶指针，EBP是存取堆栈指针。还是不能很透彻理解。之后借于一段汇编代码，总算是对两者有个比较清晰的理解。下面是按调用约定__stdcall 调用函数test(int p1,int p2)的汇编代码 ;假设执行函数前堆栈指针ESP为NN push p2 ;参数2入栈, ESP -= 4h , ESP = NN - 4h push p1 ;参数1入栈, ESP -= 4h , ESP = NN - 8h call test ;压入返回地址 ESP -= 4h, ESP = NN - 0Ch ;//进入函数内 看完汇编后,再看EBP和ESP的定义,哦,豁然开朗,原来ESP就是一直指向栈顶的指针,而EBP只是存取某时刻的栈顶指针,以方便对栈的操作,如获取函数参数、局部变量等。 { push ebp ;保护先前EBP指针， EBP入栈， ESP-=4h, ESP = NN - 10h mov ebp, esp ;设置EBP指针指向栈顶 NN-10h mov eax, dword ptr [ebp+0ch] ;ebp+0ch为NN-4h,即参数2的位置 mov ebx, dword ptr [ebp+08h] ;ebp+08h为NN-8h,即参数1的位置 sub esp, 8 ;局部变量所占空间ESP-=8, ESP = NN-18h ... add esp, 8 ;释放局部变量, ESP+=8, ESP = NN-10h pop ebp ;出栈,恢复EBP, ESP+=4, ESP = NN-0Ch ret 8 ;ret返回,弹出返回地址,ESP+=4, ESP=NN-08h, 后面加操作数8为平衡堆栈,ESP+=8,ESP=NN, 恢复进入函数前的堆栈. } 转自：通过一段汇编，加深对寄存器ESP和EBP的理解","categories":[{"name":"汇编语言","slug":"汇编语言","permalink":"http://ranxb.cn/categories/汇编语言/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://ranxb.cn/tags/笔记/"},{"name":"汇编语言","slug":"汇编语言","permalink":"http://ranxb.cn/tags/汇编语言/"}]},{"title":"成都的流水账","slug":"成都的流水账","date":"2017-11-03T09:57:01.000Z","updated":"2017-11-03T10:03:42.908Z","comments":true,"path":"2017/11/03/成都的流水账/","link":"","permalink":"http://ranxb.cn/2017/11/03/成都的流水账/","excerpt":"","text":"成都的流水账 我文笔也不好，今天在图书馆心情复杂也不知道干点啥，我就记一记流水账吧。 那我就开始了～等等～脑婆叫我去吃饭！","categories":[],"tags":[]},{"title":"数电笔记：第一章数字逻辑基础","slug":"数电笔记：第一章数字逻辑基础","date":"2017-10-29T15:05:21.000Z","updated":"2017-12-28T12:12:28.786Z","comments":true,"path":"2017/10/29/数电笔记：第一章数字逻辑基础/","link":"","permalink":"http://ranxb.cn/2017/10/29/数电笔记：第一章数字逻辑基础/","excerpt":"","text":"数电笔记2017-10-29第一章 数字逻辑基础 模拟信号电信号 二进制的转换按权展开 整数转换除2取余 纯小数转换乘2取整 十进制转R进制数的转换整数转换除R取余 纯小数转换乘R取整 二、八、十六进制数之间的转换三位二进制为一个八进制四位二进制为一个十六进制 例如：二进制转八进制从小数点向左或向右分别按三位一组转换为八进制，最后不满三位的用零补齐 带符号数的代码表示一个带符号的数由两部分组成：一部分表示数的符号；另一部分表示数的数值。在计算机中习惯用0表示正数、1用来表示负数。 为了在计算机中防止电路过于复杂，使乘法变成加法运算，人们提出了3种机器数的表示形式，称为：原码、补码、反码。 原码 原码又称为“符号–数值表示”特点： 当N为正数时，N的原码与N的区别仅为最高位增加一位用0表示的符号位，对本身数值并无影响。 当N为负数时，N的原码与N的区别是在最高位增加一位用1表示的符号位。 在原码表示中，有两种零，即为正负零。0.000和1.000 反码 反码又被称为“对1的补数”。对于负数，反码的数值是将原码数值按位求反，即原码的某位为1，反码相应为0.对于正数反码与原码相同 补码计算机中的运算码制和字符的代码表示 8421码 余3码 2421码 余3循环码 可靠性编码 格雷码（循环码） 奇偶校验码","categories":[{"name":"数字电路","slug":"数字电路","permalink":"http://ranxb.cn/categories/数字电路/"}],"tags":[{"name":"数字电路","slug":"数字电路","permalink":"http://ranxb.cn/tags/数字电路/"},{"name":"笔记","slug":"笔记","permalink":"http://ranxb.cn/tags/笔记/"}]},{"title":"Fragment的应用","slug":"Fragment的应用","date":"2017-10-25T16:33:22.000Z","updated":"2017-10-25T16:37:44.099Z","comments":true,"path":"2017/10/26/Fragment的应用/","link":"","permalink":"http://ranxb.cn/2017/10/26/Fragment的应用/","excerpt":"","text":"Fragment的应用准备 新建一个类，并继承Fragment（android.support.v4.app) 为这个类创建一个布局文件作为fragment 重写onCreatView()方法要求其返回一个view 静态加载 建一个active以用来展示静态加载demo 注意：新建的xml文件中需要添加xml布局文件的ID xml文件中添加一个fragment，其中添加 android:name=”刚刚建的fragment的包名” 预览种可能无法显示fragment，需要添加 tools:layout=”@layout/fragment_test” 在主active中添加按钮并跳转到xml文件定义的fragment_demo中 startActivity(new Intent(this,DemoFragmentActivity.class)); 动态加载 在刚才的那个xml文件中新建一个framelayout标签（容器布局）以用来存放fragment，并添加ID 添加一个button用来触发动态加载并创建事件addfragment（）； 创建一个fragment管理器 FragmentManager fragmentManager = getSupportFragmentManager(); (如果主类使用继承的是activity的话则获取方法为getFragmentManager();) 创建一个FragmentTransaction开启事务，并用刚才的管理器获取到FragmentTransaction对象 FragmentTransaction transaction = fragmentManager.beginTransaction(); 新建一个刚才的fragment类 通过fragmentTransaction事务添加fragment transaction.add(添加到的容器的ID，添加的fragment对象)； 提交事务方可加载fragment transition.commit(); 动态加载的典型代码 public void addFragment(View view){ FragmentManager fragmentManager = getSupportFragmentManager(); FragmentTransaction transaction = fragmentManager.beginTransaction(); FragmentDemo fragmentDemo = new FragmentDemo(); transaction.add(R.id.framelayout，fragmentDemo)； transition.commit(); }","categories":[{"name":"Android","slug":"Android","permalink":"http://ranxb.cn/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://ranxb.cn/tags/Android/"},{"name":"Fragment","slug":"Fragment","permalink":"http://ranxb.cn/tags/Fragment/"},{"name":"入门","slug":"入门","permalink":"http://ranxb.cn/tags/入门/"}]},{"title":"我勒个去成都！！！————写在前面","slug":"我勒个去成都！！！————写在前面","date":"2017-09-28T16:37:22.000Z","updated":"2017-09-28T16:38:59.000Z","comments":true,"path":"2017/09/29/我勒个去成都！！！————写在前面/","link":"","permalink":"http://ranxb.cn/2017/09/29/我勒个去成都！！！————写在前面/","excerpt":"","text":"我勒个去成都！！！————写在前面提前的准备 一共两个背包一个小提箱；箱子里主要放衣服杂物不常用的东西；背包里面电脑相机卫生纸日常用的还有。。零食？ 身份证 学生证 手机 充电宝 流量 银行卡 各种充电器 电脑可以选择性的带一个🐒 相机（不带脚架） 各种衣服 伞！！！！！！！ 衣物 看天气预报大多是阴天和雨天？？难道是因为比较潮？？ 30号到成都当晚阴天18度，然后1号到4号之间持续有雨有点蛋疼，56两天继续阴天，7号早上多云但是晚上走的时候继续下雨，8号早上到兰州6、7度，有点冷。。。综合来看的话。。。。不需要太薄的衣服。。。日常衬衫+薄外套全部大概准备三套左右差不多～别穿的太少 带上伞！！！交通市区交通出租车成都出租车白天(6-23点)起步价8元(速腾2.0和1.4T为9元),包2 公里,后1.9元/公里，10公里到60公里2.85元/公里。夜间(23-6点)起 步价9元(速腾2.0和1.4T为10元),包2公里,后2.2元/公里，10公里到 60公里3.3元/公里。打车后记径索要计秳収票。由亍公交车票价格不便宜，人多时比较合算。 公交车🚌成都市公交网络四通八达，可以到达任何事被近郊的旅游景区、景点。市内公交车分普通车和高档车两种，市区内的车次基本以两元为主以两元为主。 地铁🚇一共两条线，均为分段收费，起步价两元，全程五元。 火三轮？？我也不知道是干啥的，可以去瞅瞅。起步大概是2～5元。 其他景区交通 成都机场-峨眉山 収车时间:14:00，票价36元成都机场-宜宾 収车时间:14:00，票价95元成都机场-乐山 収车时间:14:00、15:50，票价46元。 新南门车站(成都市旅游集散中心)位于新南路，成都新南门大桥边。可乘6、28、49、55路到达。发往地区:成都周边，以及川内知名的旅游景区。 TIPS:(我在百度攻略上看的） 什邡、绵竹两个地震遗址专线车已开通，票价98元， 费用包括:去去回程车票、餐费、保险、导游、地震遗址安全维护费。 路线为成都—幸汉—什邡—蓥华—绵竹—汉旺—绵竹—德阳—成都。 上午8:00发车， 晚上6时过卲可返回成都。 游览地点汇总宽窄巷子宽巷子的闲生活，窄巷子的慢生活，井巷子的新生活成为了成都的“上海新天地”触摸历史痕迹，体味成都原滋原味的休闲生活方式， 门票/开放时间: 全天开放无门票地址: 青羊区同仁路以东长顺街以西交通: 公交车“长顺上街”站下车地铁2号线“人民公园”站下车。 宽窄巷子旅游最佳时间: 1、清晨: 人很少，拍风景和拍人像都很不错。 2、下午: 特别是出太阳的下午，来宽窄巷子会很 挤，很多人在茶馆喝茶，打牌，掏耳朵。这是宽窄 巷子最成都的一个表现。来一杯盖碗茶，晒一下午 的太阳。这时候，就不那么适合拍照啦~ 3、晚上: 宽窄巷子里有一些酒吧，经常会举办各种各样的party, 价格和品质都不菲。当然，环保一点的办法是， 吃过晚饭之后到宽窄巷子散步，很惬意。很悠闲。 4、如果周末来，在井巷子还能看到创意集市哦~ 武侯祠我也不知道干啥的我就瞎转吧，是个历史遗迹啥的，就不废话了～ 门票:60元，学生半价。开放时间:夏 7:30-21:00冬 8:00-18:30地址:武侯区武侯祠多街231号交通:公交车在“武侯祠”站下车 锦里这名字吉利，可以多转转。400米长的老街上，传统小吃，饮食，客栈遍巷。感觉能玩两三天，我感觉旅店可以定在这附近。 全天开放无门票地址:武侯区武侯祠多街231号交通:同武侯祠 杜甫草堂春熙路文殊院望江楼大熊猫基地稻城都江堰青城山好吃的！！！ 田姗平给的清单全吃一遍！！！","categories":[{"name":"成都游记","slug":"成都游记","permalink":"http://ranxb.cn/categories/成都游记/"}],"tags":[{"name":"游记","slug":"游记","permalink":"http://ranxb.cn/tags/游记/"},{"name":"随笔","slug":"随笔","permalink":"http://ranxb.cn/tags/随笔/"},{"name":"成都","slug":"成都","permalink":"http://ranxb.cn/tags/成都/"}]},{"title":"在Android中Menu的使用","slug":"在Android中Menu的使用","date":"2017-09-27T16:58:26.000Z","updated":"2017-09-27T17:05:24.000Z","comments":true,"path":"2017/09/28/在Android中Menu的使用/","link":"","permalink":"http://ranxb.cn/2017/09/28/在Android中Menu的使用/","excerpt":"","text":"在Android中Menu的使用Menu的分类 选项菜单(Options Menu);当用户触发 menu 项时弹出的菜单 上下文菜单(Context Menu):用户长按那个控件时弹出的类似对话框 弹出菜单，当用户点击某个 View 视图是弹出的菜单 前提准备 java创建了menu对象 使用XML方法定义Menu要在XML文件中正确填写并添加ID 使用XML定义Menu XML文件的基本属性 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:id=&quot;@+id/daxiao&quot; android:title=&quot;设置字体大小&quot; android:orderInCategory=&quot;3&quot;&gt; &lt;/item&gt; &lt;item android:id=&quot;@+id/yanse&quot; android:title=&quot;设置字体颜色&quot; android:orderInCategory=&quot;2&quot; &gt; &lt;/item&gt; &lt;item android:id=&quot;@+id/shuxing&quot; android:title=&quot;设置字体属性&quot; android:orderInCategory=&quot;1&quot;&gt; &lt;/item&gt; &lt;/menu&gt; &lt;!-- android:id=&quot;@+id/lalala_mune&quot; 设置id android:title=&quot;设置字体大小&quot; 设置title android:orderInCategory=&quot;3&quot; 显示顺序 --&gt; Menu 菜单的嵌套使用规则 Item 中可以嵌套 menu，但是不能嵌套 group Menu 中既可以嵌套 group，又可以嵌套 item。 Group 中只能嵌套 item，不能嵌套 menu 选项菜单的添加添加XML文件中的Menu 选项菜单需要重写在在java代码中重写onCreateOptionsMenu(Menu menu)方法 public boolean onCreateOptionsMenu(Menu menu) { /*第一步需要加载菜单选项*/ /*菜单填充器将菜单获取然后添加至active中*/ /*第一种比较麻烦的方法*/ /*MenuInflater inflater = getMenuInflater(); inflater.inflate(R.menu.options_menu,menu);*/ /*第二种方法*/ getMenuInflater().inflate(R.menu.options_menu,menu); return true; } 在Java代码中动态定义Menu 可以在java代码中的onCreateOptionsMenu(Menu menu)方法中使用menu.add()方法动态定义增加Menu /*另外可以通过代码添加menu项*/ //menu.add(group id,itmeid 自己设置);里面填menu的分组 group可以是itme的父标签 menu.add(Menu.NONE,ITMEID,Menu.NONE,&quot;lalala我是后设置的&quot;); 上下文菜单 定义后添加的方法与选项菜单类似当用户长按 Activity 页面时，弹出的菜单我们称为上下文菜单。我们经常在 Windows 中用鼠标右键单击弹出的菜单就是上下文菜单。 覆盖 Activity 的 onCreateContextMenu()方法，调用 Menu 的 add 方法添加菜单项MenuItem 覆盖 onContextItemSelected()方法，响应菜单单击事件 调用 registerForContextMenu()方法，为视图注册上下文菜单 子菜单 定义后添加的方法与选项菜单类似子菜单就是将相同功能的分组进行多级显示的一种菜单，比如，Windows 的“文件”菜单中就有“新建”，“打开”，“关闭”等子菜单。创建子菜单的方法 覆盖 Activity 的 onCreateOptionsMenu()方法，调用 Menu 的 addSubMenu()方法 添加子菜单项 调用 SubMenu 的 add()饭饭，添加子菜单项 覆盖 onCreateItemSelected()方法，响应菜单单击事件 添加单击事件选项菜单 以下为对于使用XML文件加载的选项菜单为例选项菜单需要重写onOptionsItemSelected(MenuItem item)方法使其触发 /** * !!只针对选项菜单!! * 当选项菜单被选中时调用的方法 * @param item 表示菜单项对象 * @return false表示不进行处理 */ @Override public boolean onOptionsItemSelected(MenuItem item) { //对于使用XML文件加载的菜单 int itemid = item.getItemId();//获取触发的item的id float a; switch (itemid) { case R.id.daxiao: a = ceshi.getTextSize(); Toast.makeText(MainActivity.this,&quot;&quot;+a,Toast.LENGTH_SHORT).show(); if (a==100) ceshi.setTextSize(TypedValue.COMPLEX_UNIT_PX,50); else ceshi.setTextSize(TypedValue.COMPLEX_UNIT_PX,100); break; case R.id.yanse: //随机生成颜色 int red = (int) (Math.random()*256); int green = (int) (Math.random()*256); int blue = (int) (Math.random()*256); ceshi.setTextColor(Color.rgb(red,green,blue)); break; } return super.onOptionsItemSelected(item); } 上下文菜单上下文菜单:上下文菜单是和某一种控件绑定使用的，也就是说每个控件只有注册了上下文菜单，并且长 按时弹出的菜单就是上下文菜单，上下文菜单加载菜单是通过重写 onCreateContextMenu()来完成的，上下文菜单的 点击事件是通过抽重写 onContextItemSelected()方法来实现的 PopMenu是通过创建 popMenu 的对象，再通过菜单加载器将其加载进来的， popMenu 的点击事件是通过 popMenu.setOnMenuItemClickListener()方法实现的。","categories":[{"name":"Android","slug":"Android","permalink":"http://ranxb.cn/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://ranxb.cn/tags/Android/"},{"name":"入门","slug":"入门","permalink":"http://ranxb.cn/tags/入门/"}]},{"title":"Linux的常用命令（持续更新）","slug":"Linux的常用命令（持续更新）","date":"2017-09-08T03:16:06.000Z","updated":"2017-09-08T03:30:38.000Z","comments":true,"path":"2017/09/08/Linux的常用命令（持续更新）/","link":"","permalink":"http://ranxb.cn/2017/09/08/Linux的常用命令（持续更新）/","excerpt":"","text":"Linux的常用命令行基本入门操作cd --更换当前目录或文件夹 rm --删除文件（删除目录加 -r 控制符） mkdir --创建文件夹 rmdir --删除文件夹（只能是空的） pwd --显示当前目录 cp --复制文件 ls --显示当前目录下的文件 mvdir --移动文件夹（可用作重命名操作） 网络操作","categories":[{"name":"Linux","slug":"Linux","permalink":"http://ranxb.cn/categories/Linux/"}],"tags":[{"name":"入门","slug":"入门","permalink":"http://ranxb.cn/tags/入门/"},{"name":"Linux","slug":"Linux","permalink":"http://ranxb.cn/tags/Linux/"}]},{"title":"近期的一些更新计划","slug":"近期的一些更新计划","date":"2017-09-05T01:17:45.000Z","updated":"2017-09-08T03:31:04.000Z","comments":true,"path":"2017/09/05/近期的一些更新计划/","link":"","permalink":"http://ranxb.cn/2017/09/05/近期的一些更新计划/","excerpt":"","text":"近期的一些更新计划 刚接触Blog没多久所以想写的东西有点多，但是这玩意吧~他得用MarkDown语法写，挺别扭的，我还得学一学，所以先列一下自己最近想要写的一些东西（可能刚开始都是比较基础的，但是还是主要做给自己看，相当于笔记的东西吧，但是因为在公网上，还是认认真真写比较好）。 MarkDown的一些基本语法Linux的一些命令操作（持续更新）常用的默认网络端口号Linux布置http环境个人Blog——Hexo在GitHub上的配置","categories":[{"name":"随笔","slug":"随笔","permalink":"http://ranxb.cn/categories/随笔/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://ranxb.cn/tags/随笔/"}]},{"title":"第一篇文章","slug":"第一篇文章","date":"2017-09-03T14:42:24.000Z","updated":"2017-09-08T03:34:51.000Z","comments":true,"path":"2017/09/03/第一篇文章/","link":"","permalink":"http://ranxb.cn/2017/09/03/第一篇文章/","excerpt":"","text":"这是第一篇文章～ 我就试试看能不能成功。 我的第一篇文章","categories":[{"name":"hexo","slug":"hexo","permalink":"http://ranxb.cn/categories/hexo/"}],"tags":[{"name":"入门","slug":"入门","permalink":"http://ranxb.cn/tags/入门/"},{"name":"hexo","slug":"hexo","permalink":"http://ranxb.cn/tags/hexo/"},{"name":"新手","slug":"新手","permalink":"http://ranxb.cn/tags/新手/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-08-31T16:00:39.000Z","updated":"2017-09-08T03:32:46.000Z","comments":true,"path":"2017/09/01/hello-world/","link":"","permalink":"http://ranxb.cn/2017/09/01/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://ranxb.cn/tags/hexo/"}]}]}