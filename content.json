{"meta":{"title":"Ran Xuebin's Blog","subtitle":"永远相信美好的事情即将发生","description":"冉学斌的博客","author":"冉学斌","url":"http://ranxb.cn"},"pages":[{"title":"categories","date":"2017-09-01T00:43:18.000Z","updated":"2017-09-01T00:43:39.000Z","comments":false,"path":"categories/index.html","permalink":"http://ranxb.cn/categories/index.html","excerpt":"","text":""},{"title":"tages","date":"2017-09-03T14:54:32.000Z","updated":"2017-09-03T15:07:24.000Z","comments":false,"path":"tages/index.html","permalink":"http://ranxb.cn/tages/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-09-03T14:54:32.000Z","updated":"2017-09-03T14:54:55.000Z","comments":false,"path":"tags/index.html","permalink":"http://ranxb.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"汇编语言第十二。。章：内外中断和int指令","slug":"汇编语言第十二。。章：内外中断和int指令","date":"2018-01-04T16:33:03.000Z","updated":"2018-01-04T17:09:50.068Z","comments":true,"path":"2018/01/05/汇编语言第十二。。章：内外中断和int指令/","link":"","permalink":"http://ranxb.cn/2018/01/05/汇编语言第十二。。章：内外中断和int指令/","excerpt":"","text":"汇编语言第十二。。章：内外中断和int指令 不再过多说中断是什么了，就是可以随时控制CPU停止当前的指令干其他的事的意思，下面内中断程序的步骤： 将程序写入0:200开始的空间内，同时把字符什么的也要定义进去。 设置中断向量表，前面是ip，后面是cs。注意高低位。 单步中断的操作 取得中断类型码 标志寄存器入栈 标志寄存器TF和IF置零，防止在中断程序中在中断。 CS内容入栈 IP入栈 根据中断类型码从中断向量表中设置中断程序的CS和IP。 中断处理程序的编写方法 保存用到的寄存器 处理中断 恢复寄存器 iret iret用来返回程序：操作为： pop ip pop cs popf 目的是回到执行中断处理程序之前的执行点继续执行程序。 编写0号中断程序明天写，自己写程序费劲 中断的特殊情况设置栈的操作不会响应中断，因为中断会进行栈操作，需要设置正确的栈顶，所以设置sp的指令应当紧接着设置ss的指令 int指令格式：int n，n为中断类型码int指令的最终功能和call类似，都是调用一段程序。中断处理程序简称为中断例程 编写供应用程序调用的中断例程明天再写详细的 BIOS和DOS多提供的中断例程的安装过程 CPU加电，初始化(CS) = 0FFFFH，(IP) = 0，从FFFF：0开始执行程序。此处有一条跳转指令，跳转后开始执行BIOS中的硬件系统检测和初始化程序 初始化程序建立BIOS所支持的中断向量表，只需登记中断向量表，中断程序在ROM中，一直在内存中存在 硬件检测和初始化完成之后，调用int 19h，进入操作系统引导程序。 DOS启动，将所提供的中断例程装入内存，并建立中断向量表。 BIOS和DOS的中断例程的应用就是应用了，比如BIOS中的彩色显示int 10h和DOS中的输出字符串int 21h。明天再写 汇编语言：完～","categories":[{"name":"汇编语言","slug":"汇编语言","permalink":"http://ranxb.cn/categories/汇编语言/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://ranxb.cn/tags/笔记/"},{"name":"汇编语言","slug":"汇编语言","permalink":"http://ranxb.cn/tags/汇编语言/"}]},{"title":"汇编语言第十一章：标志寄存器","slug":"汇编语言第十一章：标志寄存器","date":"2018-01-04T16:26:41.000Z","updated":"2018-01-04T16:28:56.877Z","comments":true,"path":"2018/01/05/汇编语言第十一章：标志寄存器/","link":"","permalink":"http://ranxb.cn/2018/01/05/汇编语言第十一章：标志寄存器/","excerpt":"","text":"汇编语言第十一章：标志寄存器 标志寄存器就是CPU处理数据的时候做标记的这一章学的有ZF，SF，PF，CF，OF标志寄存器，还有adc，sbb，movsb，movsw，cld，std，rep等操作 第六位：ZFzero flag零标志位处理完之后是否为零，0的话ZF则为一 第二位：PFParity flag奇偶校验位换成二进制之后，1的个数是偶数？PF = 1 ：PF = 0 第七位：SFsign flag符号标志位结果是否为负，只看第一位符号位 第零位：CFcarry flag进位标识符是否有进位或者借位inc和loop不影响CF位 第十一位：OFoverflow flag溢出标志位 adc指令带进位的加法指令add carryadc a,b相当于a = a + b + cf作用： add ax,bx 相当于 add al,bl adc ah,bh sbb指令带借位的减法指令sub borrowsbb a,b相当于a = a - b - CF CMP指令相当于减法，但不保存结果，只会影响标志寄存器CF和ZF 检测比较结果的条件转移指令和CMP配合使用 je equal jne not equal jb below jnb not below ja above jna not above 第十位：DF标志和串的传送DF direcition(down?) flag格式：movsb （mov string byte？）功能：复制一段数据？差不多，主要就是执行以下操作 ((es)*16+di) = ((ds)*16+si) 若df = 0: si++; di++ 若df = 1: si–; di– 上面的是传一个内存单元，也可以传一个字格式：movsw （mov string word？） mov word ptr es:[di],ds:[si](并不支持这样的指令，只是描述) 若df = 0: si+=2; di+=2 若df = 1: si-=2; di-=2 可以配合rep使用，rep就是重复cx次当前指令，例如 rep mov sb 相当于 s: movsb loop s 这样就可以实现cx个字符的传送 设置DF的指令 cld：将DF设置为零（clear df） std：将DF设置为一 (set df) pushf和popf标志寄存器的出入栈","categories":[{"name":"汇编语言","slug":"汇编语言","permalink":"http://ranxb.cn/categories/汇编语言/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://ranxb.cn/tags/笔记/"},{"name":"汇编语言","slug":"汇编语言","permalink":"http://ranxb.cn/tags/汇编语言/"}]},{"title":"汇编语言第十章：CALL和RET指令","slug":"汇编语言第十章：CALL和RET指令","date":"2018-01-04T15:33:06.000Z","updated":"2018-01-04T16:27:28.652Z","comments":true,"path":"2018/01/04/汇编语言第十章：CALL和RET指令/","link":"","permalink":"http://ranxb.cn/2018/01/04/汇编语言第十章：CALL和RET指令/","excerpt":"","text":"汇编语言第十章：CALL和RET指令 都是修改ip的，重点不多，会用就行，随便写写。 ret和retfret进行近转移，只修改IPretf进行远转移，修改IP和CS ret指令的操作出栈操作 (IP) = ((ss)*16+sp) (sp) = (sp)+2相当于pop IP retf指令的操作先出ip，再出cs (IP) = ((ss)*16+sp) (sp) = (sp)+2 (CS) = ((ss)*16+sp) (sp) = (sp)+2相当于pop ip；pop cs CALL指令 两步操作 IP或CS和IP压入栈 转移 (CALL的转移位移是16位的，也就是短转移，不支持近转移) 根据位移进行转移的CALL指令先压栈，在转移 (sp) = (sp)-2 ((ss)*16+sp) = ip ip转移 格式：CALL 标号 根据目的地址转移的CALL指令格式： call far prt 标号 实现的是段间转移执行此命令时进行如下操作： push CS push IP CS：IP转移 地址在寄存器中的CALL指令格式： call 16位的reg例如： call ax相当于：push ipjmp ax 转移地址在内存中的CALL指令CALL WORD PRT 地址两个字节16位，只转移IP CALL DWOERD PRT 地址四个字节32位，转移CS和IP RET和CALL的配合使用当正常函数用，没什么区别要先push 前面用到的寄存器的值前面CALL，后面RET MUL指令乘法指令，和除法指令类似，只是要不都是8位的，要不都是16位的。 8位的AL放一个，然后MUL一个8位的内存单元，结果放在AX里面如100*10: mov al,100 mov bl,10 mul bl 最后结果在AX里或者mul一个内存单元，还是例如： mov al,100 mov ds:[0],10 mul byte ptr ds:[0] 16位的AX放一个，然后MUL一个16位寄存器或者内存单元，结果高位在DX里，低位在AX里。例如1000*10： mov ax,1000 mov bx,10 mul bx 结果换成16进制，高位在DX里，低位在AX里。 除法在第八章","categories":[{"name":"汇编语言","slug":"汇编语言","permalink":"http://ranxb.cn/categories/汇编语言/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://ranxb.cn/tags/笔记/"},{"name":"汇编语言","slug":"汇编语言","permalink":"http://ranxb.cn/tags/汇编语言/"}]},{"title":"数字电路第五章：集成双稳态触发器","slug":"数字电路第五章：集成双稳态触发器","date":"2018-01-04T11:31:33.000Z","updated":"2018-01-04T14:53:13.378Z","comments":true,"path":"2018/01/04/数字电路第五章：集成双稳态触发器/","link":"","permalink":"http://ranxb.cn/2018/01/04/数字电路第五章：集成双稳态触发器/","excerpt":"","text":"集成双稳态触发器 主要内容有 触发器的特点及分类 基本的RS触发器 事中控制的RS触发器，D触发器，JK触发器，T触发器的电路结构、逻辑功能及其描述方法。 触发器的性能参数。 触发器的基本特点及分类输入量和输出量的设置 s0和R0代表初始状态预置输入量，X1和X2是正常工作的时候的输入量，Q为输出量，要求有两个相反的所以叫Q和非Q。钟控式的再加一个CP为时钟控制输入量。 触发器输出与约束方程的一般表达式设触发器输出次态的取值记作Qn+1，现态取值记Qn触发器正常时要求R0 = S0 = 1！。 触发器的分类 基本RS双稳态触发器及其分析 本RS触发器是各种触发器电路中结构形式最简单的一种。同时，它又是复杂电路结构触发器的一个基本组成都分。 RS型（set reset）的电路结构和基本原理 习惯上将电路画成图5-4(b)的对称形式。Q和Q称为输出端，并且定义Q=1、Q=0为触发器的1状态， Q=0、Q=1为触发器的0状态。S为置位端或置1输入端，R成为复位端或置0输入端。(1)当S=1，R=0时，Q=1,非Q=0。(2)当S=0，R=1时，Q=0,非Q=1。(3)当S=R=0时，电路维持原来状态不变。(4)当S=R=1时，Q = 非Q= 0，既不是定义的1状态， 也不是定义的0状态。真值表如下输入信号在S或R为1的全部作用时间里， 都能直接改变输出端Q和Q的状态，这就是基本RS触发器的工作特点。这个缘故，也把S(非S)叫做直接置位端; 把R(非R)叫做直接复位端 时钟RS触发器及其分析触发器翻转的状态仍由输入控制端的电平情况决定，但翻转的时刻应由统一的脉冲信号来进行控制，这类控制信号称为时钟脉冲，CP (Clock Pulse)表示。这类触发器成为同步触发器 时钟RS触发器结构与工作特性 真值表如下（即为只有CP为一时即触发） 一般在使用同步触发器时，有时还需要在cp信号来之前将触发器预置成指定状态，所以可能会出现专门的异步置位输入端S和异步复位输入端R，使触发器置于指定状态。 空翻现象如果CP=1的期间内输入信号多次发生变化，则触发器的状态也会发生多次翻转，这就降低了电路的抗干扰能力，也叫“空翻”现象。 主从触发器 主从RS触发器动作特点：主从RS触发器的动作分两步完成。先在CP=1期间，主触发器接收输入驱动RS信号进行主触发器的状态修改，但从触发器不动作。第二步，在CP=0时刻，从触发器按照此时主触发器的状态进行动作。 主从RS触发器解决了空翻问题，但在CP=1期间，RS仍存在约束条件。RS = 0 (约束条件）特征表如下： 时钟D触发器及其分析电路结构与工作原理为了适用于单端输入信号的场合，在有些集成电路中也把同步RS触发器作成下图的结构形式 通常把这种电路叫D型触发器(或D型锁存器)。 逻辑功能及其描述方法功能真值表和激励表RS触发器演变而来，它克服了RS触发器在 S=R=1时，次态不定的功能不完善缺点。 D触发器的空翻D触发器依然存在“空翻”现象，实际广泛使用的集成D触 发器采用了维持阻塞结构，称为维持阻塞D触发器。 维持阻塞D触发器状态变化产升在时钟脉冲的上升沿，其次态决定于该时刻前瞬间输入信号D。 时钟JK触发器及其分析为了消除时钟控制RS 触发器输入信号的约束条件，又使触发器有两个输入端，可在时钟控制RS触发器中增加两条交叉反馈线，并将输入端S改为J，R改为K。 逻辑功能及其描述方法功能真值表和激励表 特征方程： Qn+1 = J 非Q + 非k Q 主从集成JK触发器和RS触发差不多 时钟T触发器及其分析T触发器可看成是JK触发器在J=K条件下的特例T触发器的逻辑功能可概括为：T=0时触发器保持原状太不变；T=1时触发器翻转。 特征方程总结","categories":[{"name":"数字电路","slug":"数字电路","permalink":"http://ranxb.cn/categories/数字电路/"}],"tags":[{"name":"数字电路","slug":"数字电路","permalink":"http://ranxb.cn/tags/数字电路/"},{"name":"笔记","slug":"笔记","permalink":"http://ranxb.cn/tags/笔记/"}]},{"title":"数字电路电路板汇总","slug":"数字电路电路板汇总","date":"2018-01-04T03:22:16.000Z","updated":"2018-01-04T11:25:38.584Z","comments":true,"path":"2018/01/04/数字电路电路板汇总/","link":"","permalink":"http://ranxb.cn/2018/01/04/数字电路电路板汇总/","excerpt":"","text":"数字电路电路板汇总变量译码器74138三输入、八输出。s1为一，s2和s3为零即可正常工作。根据二进制输入输出十进制的特定端口。两个同时使用的时候，低位s1接1，s2接高位s1作为输入的第四端口。如图 7448显示译码器TS547显示器数据选择器74LS153针脚如图所示真值表如图所示做题时会给多个输入端，此时想A0A1当成两个输入端，再从D端口中根据选择器的输出表达式连接相应第三段口即可，例如： 多位数值比较器7485下图为数值比较器7485的单位针脚图下图为用多个数值比较器7485的多位数值比较器的基本原理 奇偶校验器74LS280四位二进制奇偶校验的真值表奇偶校验位逻辑表达式 74LS280奇偶校验/发生器 实际应用如下","categories":[{"name":"数字电路","slug":"数字电路","permalink":"http://ranxb.cn/categories/数字电路/"}],"tags":[{"name":"数字电路","slug":"数字电路","permalink":"http://ranxb.cn/tags/数字电路/"},{"name":"笔记","slug":"笔记","permalink":"http://ranxb.cn/tags/笔记/"}]},{"title":"汇编第九章：转移指令的原理","slug":"汇编第九章：转移指令的原理","date":"2017-12-30T09:41:24.000Z","updated":"2017-12-30T13:30:04.582Z","comments":true,"path":"2017/12/30/汇编第九章：转移指令的原理/","link":"","permalink":"http://ranxb.cn/2017/12/30/汇编第九章：转移指令的原理/","excerpt":"","text":"汇编第九章：转移指令的原理 概括地讲，转移指令就是可以控制CPU执行内存中某处代码的指令。表现为可以修改IP或者同时修改CS和IP的指令。 以下讨论8086转移行为的分类第一类：只修改IP的转移行为叫做段内转移 根据转一指令对IP的修改范围不同，段内转移可分为。 短转移：IP的修改范围为-128 ～ 127. 近转移：IP的修改范围为-32768 ～ 32767. 第二类：同时修改CS和IP的转移行为叫段间转移 转一指令的分类 无条件转移指令，例如jmp 条件转移指令 循环指令，例如loop 过程 中断 本章主要通过深入学习无条件转移指令jmp来理解CPU执行转移指令的基本原理 offset功能是取得标号地址的偏移地址 code segment start: mov ax,offset start ;相当于mov ax,0 s: mov ax,offset s ;相当于mov ax,3 jmpjmp为无条件跳转指令，可以只修改IP，也可以同时修改CS和IP。jmp指令要给出两种信息： 转移的目的地址 转移的距离（段间转移、段内转移、段内近转移） 依据位移进行转移的jmp指令NO.1 jmp short 标号（转到标号处执行指令） 这种格式实现的事段内短转移，他对IP的修改范围是-128 ～ 127，转移指令结束后，CS:IP应该指向标号指令。 根据机器码可得出CPU执行jmp指令时机器码中并不需要转移的目的地址 CPU执行指令的过程 从CS:IP执行内存单元读取指令，读取的指令进入指令缓冲器; (IP) = (IP) + 读取的长度，从而指向下一个指令; 执行指令。转到(1)，重复. 由此可得，执行jmp并不需要目的地址，而是需要位移地址short的位移量存储空间占一个字节，8个二进制位，首位为符号位，用补码表示，因此可表示的位移量为-128 ～ 127。同理，near的位移量储存空间占两个字节，16个二进制位，首位为符号位，用补码表示，因此可表示的位移量为-32768 ～ 32767。 由上引入近转移 jmp near ptr 标号（段内近转移） 转移的目的地址在指令中的jmp指令前面讲的是段内转移，因此jmp只需要位移地址即可进行对IP的修改。 jmp far ptr 标号 以上实现的是段间转移，又称远转移。可以让(CS) = 标号所在的段地址;(IP) = 标号所在的偏移地址。 转移地址在寄存器中的jmp指令jmp 16位reg 功能：(IP) = (16位reg)用寄存器中的值修改IP。 转移地址在内存中的jmp指令 两种格式 段内转移 jmp word ptr 内存单元地址 ;(段内转移) 从内存单元地址处开始存放着一个字，是转移的目的的偏移地址。例如： mov ax,0123H mov ds:[0],ax jmp word ptr ds:[0] 执行后(IP) = 0123H 段间转移 jmp dword ptr 内存单元地址 ;(段间转移) 从内存单元地址处开始存放着两个字节，是转移的目的的段地址和偏移地址，高地址是段地址，低地址是偏移地址(CS) = 内存单元地址+2(IP) = 内存单元地址比如一下指令： mov ax,0123H mov ds:[0],ax mov ax,4567H mov ds:[2],ax jmp dword ptr ds:[0] 执行完后(CS) = 4567H,(IP) = 0123H。 jcxz指令jcxz是有条件转移指令，所有的有条件转移指令都是短转移指令，对应的机器码中包含的是转移位移，不是目的地址。对IP的修改范围都是-128 ~ 127。 jcxz == jmp when cx is zero当cx为零时，执行转移指令，若不为零，则不转移使用格式： jcxz 标号 loop指令loop指令位循环指令，所有的循环指令都是短转移。详见第五章 根据位移进行转移的意义jmp short x jmp near ptr x jcxz x loop 以上都是根据转移的位移量进行转移的，这样有利于程序在内存中的浮动装配，意思就是把这段程序装在内存中的任意一段空间内都可以执行，不会因为转移的地址不同而导致程序不能执行。 编译器对转移位移超界的检测jmp超界编译器会报错，别的没其他知识点","categories":[{"name":"汇编语言","slug":"汇编语言","permalink":"http://ranxb.cn/categories/汇编语言/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://ranxb.cn/tags/笔记/"},{"name":"汇编语言","slug":"汇编语言","permalink":"http://ranxb.cn/tags/汇编语言/"}]},{"title":"汇编第八章：数据处理的两个基本问题","slug":"汇编第八章：数据处理的两个基本问题","date":"2017-12-28T19:23:25.000Z","updated":"2017-12-30T09:40:34.461Z","comments":true,"path":"2017/12/29/汇编第八章：数据处理的两个基本问题/","link":"","permalink":"http://ranxb.cn/2017/12/29/汇编第八章：数据处理的两个基本问题/","excerpt":"","text":"汇编第八章：数据处理的两个基本问题 章前言说的是对前面所有的内容是有总结性的，这里主要探讨两个问题： 处理的数据在什么地方？ 处理的数据有多长？ 定义两个符号reg和sregreg代表寄存器，包括：ax,bx,cx,dx,ah,al,bh,bl,ch,cl,dh,dl,sp,bp,si,disreg代表段寄存器，包括：ds,ss,cs,es bx、si、di、bp的使用规则 三个规则，一会总结，字比较多，等会打。 只有这四个寄存器可以用在[…]中进行寻址 mov ax,[bx] mov ax,[bx+si] 以下的是错误的 mov ax,[cx] mov ax,[ax] 这四个可以单独出现，但是组合的情况只有四种可以使用：bx和si、bx和di、bp和si、bp和di。 mov ax,[bx+si] mov ax,[bx+di] mov ax,[bp+si] mov ax,[bp+di+idata] 以下的是错误的 mov ax.[bx+dp] mov ax,[si+di] 只要使用[…]中bp寄存器时，若没有显式的给出段寄存器，则默认为段地址在ss中 mov ax,[bp] ;(ax) = ((ss)*16+(bp)) 机器指令处理的数据在什么地方机器指令都是经过处理过的数据：1、读取。2、存入。3、运行 所有处理的数据可以在三个地方：CPU内部、内存、端口（后面说先不用管）例如： mov bx,[0] ;内存 mov bx,ax ;CPU内部ax寄存器 mov bx,1 ;CPU内部指令缓冲器 汇编语言中数据位置的表达汇编语言用3个概念来表达数据的位置： 立即数[idata]例如： mov ax,1 add bx,2000H or bx,00010000B mov al,’a’ 以上 寄存器例如 mov ax,bx push ds以上 段地址和偏移地址例如 mov ax,[bx] ;段地址默认在ds中 寻址方式五种寻址方式： [idata] 直接寻址 [bx] 寄存器间接寻址 [bx+idata] 寄存器相对寻址 [bx+si] 基址变址寻址 [bx+si+idata] 相对基址变址寻址 总结：有两个寄存器就是基址变址，只要有idata就是相对（只有idata是直接寻址，只有一个寄存器是寄存器间接寻址） 指令要处理的数据有多长 通过寄存器名可以致命处理的数据长度 在没有寄存器的情况下，用操作符“X ptr”指明要操作的长度，X可以是byte或者是word。例如 mov word prt ds:[0],1 inc word prt [bx] mov byte ptr ds:[0],1 add byte ptr [bx],2 寻址的综合应用 主要就是类c语言的数组的操作，看看书看就行了。 div 两种div方式！(被除数是除号之前的。) 16位寄存器除以8位寄存器：16位做被除数放在AX里面。商在AL里，余数在AH里 32位寄存器除以16位寄存器：高16位放在DX，低16位放在AX里，共32位做被除数。商在AX里，余数在DX里。 商都放在低位寄存器中，余数放在高位，除数放在一个内存单元或者reg中例如： 16位/8位： div byte ptr ds:[0] ;(al) = (ax)/((ds)*16+0) ;(ah) = (ax)mod((ds)*16+0) 32位/8位： div word ptr ds:[0] ;(ax) = [(dx)*10000H + (ax)] / ((ds)*16+0) ;(dx) = [(dx)*10000H + (ax)] mod ((ds)*16+0) 实际应用，例如100001/100,100001 = 186A1H mov dx,1H mov ax,86A1H mov bx,100 div bx ;商在AX里，余数在DX里 dd dd（define double）,用于定义双精度字节，一个双精度占2个字，4个字节。 data segment db 1 dw 1 dd 1 data ends 上面这段： 1. 第一个数据是01H，在data:[0]处 2. 第二个数据是0001H，在data:[1] - data:[2]处 3. 第三个数据是00000001H，在data:[3] - data:[6]处 dup和dd一样都是一个操作符，它是和db、dw、dd等数据定义伪指令配合使用的，用来进行数据的重复，比如： db 3 dup (0) 定义了3个字节，他们的值都是0，相当于 db 0,0,0 又例如： db 3 dup (0,1,2) 定义了9个字节，分别是0,1,2,0,1,2,0,1,2,相当于 db 0,1,2,0,1,2,0,1,2 使用规范如下 db 重复次数 dup (内容) ;(重复的字节型数据) dw 重复次数 dup (内容) ;(重复的字型数据) dd 重复次数 dup (内容) ;(重复的双精度字型数据)","categories":[{"name":"汇编语言","slug":"汇编语言","permalink":"http://ranxb.cn/categories/汇编语言/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://ranxb.cn/tags/笔记/"},{"name":"汇编语言","slug":"汇编语言","permalink":"http://ranxb.cn/tags/汇编语言/"}]},{"title":"汇编第七章：更灵活的定位内存地址的方式","slug":"汇编第七章：更灵活的定位内存地址的方式","date":"2017-12-28T18:46:40.000Z","updated":"2017-12-28T19:12:36.919Z","comments":true,"path":"2017/12/29/汇编第七章：更灵活的定位内存地址的方式/","link":"","permalink":"http://ranxb.cn/2017/12/29/汇编第七章：更灵活的定位内存地址的方式/","excerpt":"","text":"汇编第七章：更灵活的定位内存地址的方式and、or指令and 按位与 mov al,01100011B and al,00111011B 结果为al = 00100011B or 按位和 mov al,01100011B or al,00111011B 结果为al = 01111011B 关于ASCII码data segment db &apos;unIX&apos; data ends 相当于 data segment db 75H,6EH,49H,58H data ends 一个字母一个字节 小写字母ASCII码比大写字母大 将’a’的ASCII码减20H就可以变成大写字母’A’ 将’A’的ASCII码加20H就可以变成小写字母’a’ 当ASCII码大于61H的时候是小写字母 ASCII码的二进制形式第五位为1时是小写字母，0时大写字母 根据上面第五条可以进行大小写转换！ and al,11101111B 可以把字母变成大写 or al,00010000B 可以把字母变成小写 [bx+idata][bx+idata]表示一个内存单元,他的偏移地址是(bx)+idata(bx的值加上idata) mov ax,[bx+200] == ax = ((dx)*16 + (bx) + 200) 该指令也可以写成 mov ax,[200+bx] mov ax,200[bx] mov ax,[bx].200 因此，[bx+idata]的方式为高级语言实现数组提供了便利机制 C语言：a[i],b[i] 汇编语言：0[bx],5[bx]([bx+0],[bx+5]) SI和DISI和DI是8086中和bx相似的寄存器，但是不能像bx一样分成两个八位寄存器来使用因此我们可以更灵活的使用：[bx+si]类似的方式表示一个内存一个内存单元例如： mov ax,[bx+si] 意为(ax) = (dx*16) + (bx) + (si)也可以写成 mov ax,[bx][si] 不同的寻址方式的灵活应用 [idata]用一个常量来表示地址，可用于直接定位一个内存 [bx]用一个变量来表示一个内存，可用于间接定位一个内存单元 [bx+idata]用一个变量和一个常量来表示内存地址，可在一个起始地址的基础上用变量简介定位一个内存，例如数组。 [bx+si]用两个变量表示一个内存地址 [bx+si+idata]用两个变量和一个常量表示一个内存地址 一道大题问题7.9（先复习，回头再写）","categories":[{"name":"汇编语言","slug":"汇编语言","permalink":"http://ranxb.cn/categories/汇编语言/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://ranxb.cn/tags/笔记/"},{"name":"汇编语言","slug":"汇编语言","permalink":"http://ranxb.cn/tags/汇编语言/"}]},{"title":"现代第二章","slug":"现代第二章","date":"2017-12-28T12:08:13.000Z","updated":"2017-12-28T19:34:15.439Z","comments":true,"path":"2017/12/28/现代第二章/","link":"","permalink":"http://ranxb.cn/2017/12/28/现代第二章/","excerpt":"","text":"矩阵向量引入线性相关无关性向量的秩矩阵的运算1）！*不可逆乘* 2）一个行 * 一个列 = 一个数 3）对角全为一的矩阵是单位矩阵计为E 4）单位矩阵相当于乘法中的1 5）任何矩阵与单位矩阵相乘都等于本身 6）若AB == BA ，则称AB是可交换的 7）矩阵的乘法不满足消除律 8）矩阵的转置计为A 9）（AB）t == Bt*At 10) (kA)t == kAt 11）如果At == A，那么这个矩阵式是对称的 12）如果At == -A，那么这个矩阵式是反对称的 13）对角矩阵是只有对角线上的矩阵，A = diag(a,b,c,d...) 14）对角矩阵的数都一样的时候是数量矩阵，全是一的时候单位矩阵。 可交换矩阵(逆矩阵)可交换矩阵的充要条件： (1) 设A , B 至少有一个为零矩阵,则A , B 可交换; (2) 设A , B 至少有一个为单位矩阵, 则A , B可交换; (3) 设A , B 至少有一个为数量矩阵, 则A , B可交换; (4) 设A , B 均为对角矩阵,则A , B 可交换; (5) 设A , B 均为准对角矩阵（准对角矩阵是分块矩阵概念下的一种矩阵。即除去主对角线上分块矩阵不为零矩阵外，其余分块矩阵均为零矩阵）,且对角线上的子块均可交换，则A , B 可交换; (6) 设A*是A 的伴随矩阵,则A*与A可交换; (7) 设A可逆,则A 与其逆矩阵可交换; 注：A的逆矩阵经过数乘变换所得到的矩阵也可以与A进行交换。 (8)（n=0,1..., ）可与 (m=0,1..., )交换.这一点由矩阵乘法的结合律证明。 求所有可交换矩阵 求A的所有可交换矩阵，所以设AZ == ZA，Z = [a,b;c,d]，求出Z即可～ 矩阵的初等变化及其标准型","categories":[{"name":"线性代数","slug":"线性代数","permalink":"http://ranxb.cn/categories/线性代数/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://ranxb.cn/tags/笔记/"},{"name":"线性代数","slug":"线性代数","permalink":"http://ranxb.cn/tags/线性代数/"}]},{"title":"汇编第六章：包含多个短的程序","slug":"汇编第六章：包含多个短的程序","date":"2017-12-28T12:07:59.000Z","updated":"2017-12-28T18:21:14.005Z","comments":true,"path":"2017/12/28/汇编第六章：包含多个短的程序/","link":"","permalink":"http://ranxb.cn/2017/12/28/汇编第六章：包含多个短的程序/","excerpt":"","text":"汇编第六章：包含多个短的程序 dw == define word 一个dw：16位两字节 start…end start如果程序入口不是我们想要执行的指令可以使用start指令指明程序入口所在 assume cs:code code segment . . . dw 0123h,1456h;数据 . . . start: . . . mov ax,0;代码 . . . mov ax,4c00H int 21H code ends end start 一个段的容量不能大于64kb因此可以考虑使用多个段来存放数据、代码、和栈。stack == 栈 8086不允许将一个数值直接送入段寄存器，例如“mov ds,data”。data也会被编译器处理为表示一个段地址的数值 data、satck、code也仅仅是命名而已，就跟标号一样，需要用assume将他们和cpu联系起来因此程序有以下模板 assume cs:code,ss:stack,ds:data data segment dw .......... data ends stack segment dw 0,0,0,0,0,0..... stack ends code segment start: mov ax,data ;数据段空间 mov ds,ax mov bx,0 mov ax,stack ;栈空间 mov ss,ax mov sp,0 . . . code ends start end","categories":[{"name":"汇编语言","slug":"汇编语言","permalink":"http://ranxb.cn/categories/汇编语言/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://ranxb.cn/tags/笔记/"},{"name":"汇编语言","slug":"汇编语言","permalink":"http://ranxb.cn/tags/汇编语言/"}]},{"title":"汇编第五章 [BX]和loop指令","slug":"汇编第五章-BX-和loop指令","date":"2017-12-28T12:07:35.000Z","updated":"2017-12-28T19:33:59.114Z","comments":true,"path":"2017/12/28/汇编第五章-BX-和loop指令/","link":"","permalink":"http://ranxb.cn/2017/12/28/汇编第五章-BX-和loop指令/","excerpt":"","text":"汇编第五章 [BX]和loop指令[bx]表示偏移地址ss:ip 表示栈段push ax的具体流程 push ax: sp = sp - 2; (ss:sp) = ax; pop ax的具体操作 pop ax: ax = (ss:sp); sp+=2; inc ax ax的内容加1 mov ax,2000H 其中ah = 20 al = 00 当 BE 21000H 00 21001H . . . mov ax,2100H; mox dx,ax; mov bx,0; mov ax,[bx] 此时 ax = 00BE ！！意为先存低位，在存高位。 LOOP指令LOOP执行顺序 LOOP执行顺序： 1.CX--; 2.CX==0?顺序执行:循环 CX设置循环次数 例如： mov cx,11 L:add ax,1 LOOP L 将ffff传入ax中的时候要前面加零 mov ax,0ffffH mov dx,ax . . . 汇编语言程序中，数据不能以字母开头 DEBUG和汇编编译器MASM对指令的不同处理DEBUG中：mov al,[0] ;含义：(al) = ((dx)16+0)源程序中: mov al,[0]* ;含义：(al) = 0 在源程序中，如果用指令访问一个内存单元，则在指令中必须用“[…]”来表示内存单元，如果在“[]”里直接用一个常量idata直接给出内存单元的偏移地址，就要在”[]”的前面显示的给出段地址所在的段寄存器。 例如： mov ax,dx:[0] 段前缀以上这样的表示方法dx叫做段前缀类似的比如 mov ax,ds:[0] mov ax,cx:[0] mov ax,ss:[0] mov ax,es:[0] 等等ds:、cx:、ss:、es:、都叫做段前缀 一段安全的空间直接向内存中写入数据时，要用：0:200 ～ 0:2ff","categories":[{"name":"汇编语言","slug":"汇编语言","permalink":"http://ranxb.cn/categories/汇编语言/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://ranxb.cn/tags/笔记/"},{"name":"汇编语言","slug":"汇编语言","permalink":"http://ranxb.cn/tags/汇编语言/"}]},{"title":"汇编语言中寄存器ESP和EBP的理解","slug":"汇编语言中寄存器ESP和EBP的理解","date":"2017-11-04T04:31:45.000Z","updated":"2017-12-28T19:25:54.068Z","comments":true,"path":"2017/11/04/汇编语言中寄存器ESP和EBP的理解/","link":"","permalink":"http://ranxb.cn/2017/11/04/汇编语言中寄存器ESP和EBP的理解/","excerpt":"","text":"汇编语言中寄存器ESP和EBP的理解 学校在做信息活动月，有个活动是对xp系统中的一个应用程序进行反汇编，了解他的运行机制，但是在中间有一部分对寄存器的概念有点生疏，所以在网上看到一个好的材料，所以码一下 一直对寄存器ESP和EBP的概念总是有些混淆，查看定义ESP是栈顶指针，EBP是存取堆栈指针。还是不能很透彻理解。之后借于一段汇编代码，总算是对两者有个比较清晰的理解。下面是按调用约定__stdcall 调用函数test(int p1,int p2)的汇编代码 ;假设执行函数前堆栈指针ESP为NN push p2 ;参数2入栈, ESP -= 4h , ESP = NN - 4h push p1 ;参数1入栈, ESP -= 4h , ESP = NN - 8h call test ;压入返回地址 ESP -= 4h, ESP = NN - 0Ch ;//进入函数内 看完汇编后,再看EBP和ESP的定义,哦,豁然开朗,原来ESP就是一直指向栈顶的指针,而EBP只是存取某时刻的栈顶指针,以方便对栈的操作,如获取函数参数、局部变量等。 { push ebp ;保护先前EBP指针， EBP入栈， ESP-=4h, ESP = NN - 10h mov ebp, esp ;设置EBP指针指向栈顶 NN-10h mov eax, dword ptr [ebp+0ch] ;ebp+0ch为NN-4h,即参数2的位置 mov ebx, dword ptr [ebp+08h] ;ebp+08h为NN-8h,即参数1的位置 sub esp, 8 ;局部变量所占空间ESP-=8, ESP = NN-18h ... add esp, 8 ;释放局部变量, ESP+=8, ESP = NN-10h pop ebp ;出栈,恢复EBP, ESP+=4, ESP = NN-0Ch ret 8 ;ret返回,弹出返回地址,ESP+=4, ESP=NN-08h, 后面加操作数8为平衡堆栈,ESP+=8,ESP=NN, 恢复进入函数前的堆栈. } 转自：通过一段汇编，加深对寄存器ESP和EBP的理解","categories":[{"name":"汇编语言","slug":"汇编语言","permalink":"http://ranxb.cn/categories/汇编语言/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://ranxb.cn/tags/笔记/"},{"name":"汇编语言","slug":"汇编语言","permalink":"http://ranxb.cn/tags/汇编语言/"}]},{"title":"成都的流水账","slug":"成都的流水账","date":"2017-11-03T09:57:01.000Z","updated":"2017-11-03T10:03:42.908Z","comments":true,"path":"2017/11/03/成都的流水账/","link":"","permalink":"http://ranxb.cn/2017/11/03/成都的流水账/","excerpt":"","text":"成都的流水账 我文笔也不好，今天在图书馆心情复杂也不知道干点啥，我就记一记流水账吧。 那我就开始了～等等～脑婆叫我去吃饭！","categories":[],"tags":[]},{"title":"数电笔记：第一章数字逻辑基础","slug":"数电笔记：第一章数字逻辑基础","date":"2017-10-29T15:05:21.000Z","updated":"2017-12-28T12:12:28.786Z","comments":true,"path":"2017/10/29/数电笔记：第一章数字逻辑基础/","link":"","permalink":"http://ranxb.cn/2017/10/29/数电笔记：第一章数字逻辑基础/","excerpt":"","text":"数电笔记2017-10-29第一章 数字逻辑基础 模拟信号电信号 二进制的转换按权展开 整数转换除2取余 纯小数转换乘2取整 十进制转R进制数的转换整数转换除R取余 纯小数转换乘R取整 二、八、十六进制数之间的转换三位二进制为一个八进制四位二进制为一个十六进制 例如：二进制转八进制从小数点向左或向右分别按三位一组转换为八进制，最后不满三位的用零补齐 带符号数的代码表示一个带符号的数由两部分组成：一部分表示数的符号；另一部分表示数的数值。在计算机中习惯用0表示正数、1用来表示负数。 为了在计算机中防止电路过于复杂，使乘法变成加法运算，人们提出了3种机器数的表示形式，称为：原码、补码、反码。 原码 原码又称为“符号–数值表示”特点： 当N为正数时，N的原码与N的区别仅为最高位增加一位用0表示的符号位，对本身数值并无影响。 当N为负数时，N的原码与N的区别是在最高位增加一位用1表示的符号位。 在原码表示中，有两种零，即为正负零。0.000和1.000 反码 反码又被称为“对1的补数”。对于负数，反码的数值是将原码数值按位求反，即原码的某位为1，反码相应为0.对于正数反码与原码相同 补码计算机中的运算码制和字符的代码表示 8421码 余3码 2421码 余3循环码 可靠性编码 格雷码（循环码） 奇偶校验码","categories":[{"name":"数字电路","slug":"数字电路","permalink":"http://ranxb.cn/categories/数字电路/"}],"tags":[{"name":"数字电路","slug":"数字电路","permalink":"http://ranxb.cn/tags/数字电路/"},{"name":"笔记","slug":"笔记","permalink":"http://ranxb.cn/tags/笔记/"}]},{"title":"Fragment的应用","slug":"Fragment的应用","date":"2017-10-25T16:33:22.000Z","updated":"2017-10-25T16:37:44.099Z","comments":true,"path":"2017/10/26/Fragment的应用/","link":"","permalink":"http://ranxb.cn/2017/10/26/Fragment的应用/","excerpt":"","text":"Fragment的应用准备 新建一个类，并继承Fragment（android.support.v4.app) 为这个类创建一个布局文件作为fragment 重写onCreatView()方法要求其返回一个view 静态加载 建一个active以用来展示静态加载demo 注意：新建的xml文件中需要添加xml布局文件的ID xml文件中添加一个fragment，其中添加 android:name=”刚刚建的fragment的包名” 预览种可能无法显示fragment，需要添加 tools:layout=”@layout/fragment_test” 在主active中添加按钮并跳转到xml文件定义的fragment_demo中 startActivity(new Intent(this,DemoFragmentActivity.class)); 动态加载 在刚才的那个xml文件中新建一个framelayout标签（容器布局）以用来存放fragment，并添加ID 添加一个button用来触发动态加载并创建事件addfragment（）； 创建一个fragment管理器 FragmentManager fragmentManager = getSupportFragmentManager(); (如果主类使用继承的是activity的话则获取方法为getFragmentManager();) 创建一个FragmentTransaction开启事务，并用刚才的管理器获取到FragmentTransaction对象 FragmentTransaction transaction = fragmentManager.beginTransaction(); 新建一个刚才的fragment类 通过fragmentTransaction事务添加fragment transaction.add(添加到的容器的ID，添加的fragment对象)； 提交事务方可加载fragment transition.commit(); 动态加载的典型代码 public void addFragment(View view){ FragmentManager fragmentManager = getSupportFragmentManager(); FragmentTransaction transaction = fragmentManager.beginTransaction(); FragmentDemo fragmentDemo = new FragmentDemo(); transaction.add(R.id.framelayout，fragmentDemo)； transition.commit(); }","categories":[{"name":"Android","slug":"Android","permalink":"http://ranxb.cn/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://ranxb.cn/tags/Android/"},{"name":"Fragment","slug":"Fragment","permalink":"http://ranxb.cn/tags/Fragment/"},{"name":"入门","slug":"入门","permalink":"http://ranxb.cn/tags/入门/"}]},{"title":"我勒个去成都！！！————写在前面","slug":"我勒个去成都！！！————写在前面","date":"2017-09-28T16:37:22.000Z","updated":"2017-09-28T16:38:59.000Z","comments":true,"path":"2017/09/29/我勒个去成都！！！————写在前面/","link":"","permalink":"http://ranxb.cn/2017/09/29/我勒个去成都！！！————写在前面/","excerpt":"","text":"我勒个去成都！！！————写在前面提前的准备 一共两个背包一个小提箱；箱子里主要放衣服杂物不常用的东西；背包里面电脑相机卫生纸日常用的还有。。零食？ 身份证 学生证 手机 充电宝 流量 银行卡 各种充电器 电脑可以选择性的带一个🐒 相机（不带脚架） 各种衣服 伞！！！！！！！ 衣物 看天气预报大多是阴天和雨天？？难道是因为比较潮？？ 30号到成都当晚阴天18度，然后1号到4号之间持续有雨有点蛋疼，56两天继续阴天，7号早上多云但是晚上走的时候继续下雨，8号早上到兰州6、7度，有点冷。。。综合来看的话。。。。不需要太薄的衣服。。。日常衬衫+薄外套全部大概准备三套左右差不多～别穿的太少 带上伞！！！交通市区交通出租车成都出租车白天(6-23点)起步价8元(速腾2.0和1.4T为9元),包2 公里,后1.9元/公里，10公里到60公里2.85元/公里。夜间(23-6点)起 步价9元(速腾2.0和1.4T为10元),包2公里,后2.2元/公里，10公里到 60公里3.3元/公里。打车后记径索要计秳収票。由亍公交车票价格不便宜，人多时比较合算。 公交车🚌成都市公交网络四通八达，可以到达任何事被近郊的旅游景区、景点。市内公交车分普通车和高档车两种，市区内的车次基本以两元为主以两元为主。 地铁🚇一共两条线，均为分段收费，起步价两元，全程五元。 火三轮？？我也不知道是干啥的，可以去瞅瞅。起步大概是2～5元。 其他景区交通 成都机场-峨眉山 収车时间:14:00，票价36元成都机场-宜宾 収车时间:14:00，票价95元成都机场-乐山 収车时间:14:00、15:50，票价46元。 新南门车站(成都市旅游集散中心)位于新南路，成都新南门大桥边。可乘6、28、49、55路到达。发往地区:成都周边，以及川内知名的旅游景区。 TIPS:(我在百度攻略上看的） 什邡、绵竹两个地震遗址专线车已开通，票价98元， 费用包括:去去回程车票、餐费、保险、导游、地震遗址安全维护费。 路线为成都—幸汉—什邡—蓥华—绵竹—汉旺—绵竹—德阳—成都。 上午8:00发车， 晚上6时过卲可返回成都。 游览地点汇总宽窄巷子宽巷子的闲生活，窄巷子的慢生活，井巷子的新生活成为了成都的“上海新天地”触摸历史痕迹，体味成都原滋原味的休闲生活方式， 门票/开放时间: 全天开放无门票地址: 青羊区同仁路以东长顺街以西交通: 公交车“长顺上街”站下车地铁2号线“人民公园”站下车。 宽窄巷子旅游最佳时间: 1、清晨: 人很少，拍风景和拍人像都很不错。 2、下午: 特别是出太阳的下午，来宽窄巷子会很 挤，很多人在茶馆喝茶，打牌，掏耳朵。这是宽窄 巷子最成都的一个表现。来一杯盖碗茶，晒一下午 的太阳。这时候，就不那么适合拍照啦~ 3、晚上: 宽窄巷子里有一些酒吧，经常会举办各种各样的party, 价格和品质都不菲。当然，环保一点的办法是， 吃过晚饭之后到宽窄巷子散步，很惬意。很悠闲。 4、如果周末来，在井巷子还能看到创意集市哦~ 武侯祠我也不知道干啥的我就瞎转吧，是个历史遗迹啥的，就不废话了～ 门票:60元，学生半价。开放时间:夏 7:30-21:00冬 8:00-18:30地址:武侯区武侯祠多街231号交通:公交车在“武侯祠”站下车 锦里这名字吉利，可以多转转。400米长的老街上，传统小吃，饮食，客栈遍巷。感觉能玩两三天，我感觉旅店可以定在这附近。 全天开放无门票地址:武侯区武侯祠多街231号交通:同武侯祠 杜甫草堂春熙路文殊院望江楼大熊猫基地稻城都江堰青城山好吃的！！！ 田姗平给的清单全吃一遍！！！","categories":[{"name":"成都游记","slug":"成都游记","permalink":"http://ranxb.cn/categories/成都游记/"}],"tags":[{"name":"游记","slug":"游记","permalink":"http://ranxb.cn/tags/游记/"},{"name":"随笔","slug":"随笔","permalink":"http://ranxb.cn/tags/随笔/"},{"name":"成都","slug":"成都","permalink":"http://ranxb.cn/tags/成都/"}]},{"title":"在Android中Menu的使用","slug":"在Android中Menu的使用","date":"2017-09-27T16:58:26.000Z","updated":"2017-09-27T17:05:24.000Z","comments":true,"path":"2017/09/28/在Android中Menu的使用/","link":"","permalink":"http://ranxb.cn/2017/09/28/在Android中Menu的使用/","excerpt":"","text":"在Android中Menu的使用Menu的分类 选项菜单(Options Menu);当用户触发 menu 项时弹出的菜单 上下文菜单(Context Menu):用户长按那个控件时弹出的类似对话框 弹出菜单，当用户点击某个 View 视图是弹出的菜单 前提准备 java创建了menu对象 使用XML方法定义Menu要在XML文件中正确填写并添加ID 使用XML定义Menu XML文件的基本属性 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:id=&quot;@+id/daxiao&quot; android:title=&quot;设置字体大小&quot; android:orderInCategory=&quot;3&quot;&gt; &lt;/item&gt; &lt;item android:id=&quot;@+id/yanse&quot; android:title=&quot;设置字体颜色&quot; android:orderInCategory=&quot;2&quot; &gt; &lt;/item&gt; &lt;item android:id=&quot;@+id/shuxing&quot; android:title=&quot;设置字体属性&quot; android:orderInCategory=&quot;1&quot;&gt; &lt;/item&gt; &lt;/menu&gt; &lt;!-- android:id=&quot;@+id/lalala_mune&quot; 设置id android:title=&quot;设置字体大小&quot; 设置title android:orderInCategory=&quot;3&quot; 显示顺序 --&gt; Menu 菜单的嵌套使用规则 Item 中可以嵌套 menu，但是不能嵌套 group Menu 中既可以嵌套 group，又可以嵌套 item。 Group 中只能嵌套 item，不能嵌套 menu 选项菜单的添加添加XML文件中的Menu 选项菜单需要重写在在java代码中重写onCreateOptionsMenu(Menu menu)方法 public boolean onCreateOptionsMenu(Menu menu) { /*第一步需要加载菜单选项*/ /*菜单填充器将菜单获取然后添加至active中*/ /*第一种比较麻烦的方法*/ /*MenuInflater inflater = getMenuInflater(); inflater.inflate(R.menu.options_menu,menu);*/ /*第二种方法*/ getMenuInflater().inflate(R.menu.options_menu,menu); return true; } 在Java代码中动态定义Menu 可以在java代码中的onCreateOptionsMenu(Menu menu)方法中使用menu.add()方法动态定义增加Menu /*另外可以通过代码添加menu项*/ //menu.add(group id,itmeid 自己设置);里面填menu的分组 group可以是itme的父标签 menu.add(Menu.NONE,ITMEID,Menu.NONE,&quot;lalala我是后设置的&quot;); 上下文菜单 定义后添加的方法与选项菜单类似当用户长按 Activity 页面时，弹出的菜单我们称为上下文菜单。我们经常在 Windows 中用鼠标右键单击弹出的菜单就是上下文菜单。 覆盖 Activity 的 onCreateContextMenu()方法，调用 Menu 的 add 方法添加菜单项MenuItem 覆盖 onContextItemSelected()方法，响应菜单单击事件 调用 registerForContextMenu()方法，为视图注册上下文菜单 子菜单 定义后添加的方法与选项菜单类似子菜单就是将相同功能的分组进行多级显示的一种菜单，比如，Windows 的“文件”菜单中就有“新建”，“打开”，“关闭”等子菜单。创建子菜单的方法 覆盖 Activity 的 onCreateOptionsMenu()方法，调用 Menu 的 addSubMenu()方法 添加子菜单项 调用 SubMenu 的 add()饭饭，添加子菜单项 覆盖 onCreateItemSelected()方法，响应菜单单击事件 添加单击事件选项菜单 以下为对于使用XML文件加载的选项菜单为例选项菜单需要重写onOptionsItemSelected(MenuItem item)方法使其触发 /** * !!只针对选项菜单!! * 当选项菜单被选中时调用的方法 * @param item 表示菜单项对象 * @return false表示不进行处理 */ @Override public boolean onOptionsItemSelected(MenuItem item) { //对于使用XML文件加载的菜单 int itemid = item.getItemId();//获取触发的item的id float a; switch (itemid) { case R.id.daxiao: a = ceshi.getTextSize(); Toast.makeText(MainActivity.this,&quot;&quot;+a,Toast.LENGTH_SHORT).show(); if (a==100) ceshi.setTextSize(TypedValue.COMPLEX_UNIT_PX,50); else ceshi.setTextSize(TypedValue.COMPLEX_UNIT_PX,100); break; case R.id.yanse: //随机生成颜色 int red = (int) (Math.random()*256); int green = (int) (Math.random()*256); int blue = (int) (Math.random()*256); ceshi.setTextColor(Color.rgb(red,green,blue)); break; } return super.onOptionsItemSelected(item); } 上下文菜单上下文菜单:上下文菜单是和某一种控件绑定使用的，也就是说每个控件只有注册了上下文菜单，并且长 按时弹出的菜单就是上下文菜单，上下文菜单加载菜单是通过重写 onCreateContextMenu()来完成的，上下文菜单的 点击事件是通过抽重写 onContextItemSelected()方法来实现的 PopMenu是通过创建 popMenu 的对象，再通过菜单加载器将其加载进来的， popMenu 的点击事件是通过 popMenu.setOnMenuItemClickListener()方法实现的。","categories":[{"name":"Android","slug":"Android","permalink":"http://ranxb.cn/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://ranxb.cn/tags/Android/"},{"name":"入门","slug":"入门","permalink":"http://ranxb.cn/tags/入门/"}]},{"title":"Linux的常用命令（持续更新）","slug":"Linux的常用命令（持续更新）","date":"2017-09-08T03:16:06.000Z","updated":"2017-09-08T03:30:38.000Z","comments":true,"path":"2017/09/08/Linux的常用命令（持续更新）/","link":"","permalink":"http://ranxb.cn/2017/09/08/Linux的常用命令（持续更新）/","excerpt":"","text":"Linux的常用命令行基本入门操作cd --更换当前目录或文件夹 rm --删除文件（删除目录加 -r 控制符） mkdir --创建文件夹 rmdir --删除文件夹（只能是空的） pwd --显示当前目录 cp --复制文件 ls --显示当前目录下的文件 mvdir --移动文件夹（可用作重命名操作） 网络操作","categories":[{"name":"Linux","slug":"Linux","permalink":"http://ranxb.cn/categories/Linux/"}],"tags":[{"name":"入门","slug":"入门","permalink":"http://ranxb.cn/tags/入门/"},{"name":"Linux","slug":"Linux","permalink":"http://ranxb.cn/tags/Linux/"}]},{"title":"近期的一些更新计划","slug":"近期的一些更新计划","date":"2017-09-05T01:17:45.000Z","updated":"2017-09-08T03:31:04.000Z","comments":true,"path":"2017/09/05/近期的一些更新计划/","link":"","permalink":"http://ranxb.cn/2017/09/05/近期的一些更新计划/","excerpt":"","text":"近期的一些更新计划 刚接触Blog没多久所以想写的东西有点多，但是这玩意吧~他得用MarkDown语法写，挺别扭的，我还得学一学，所以先列一下自己最近想要写的一些东西（可能刚开始都是比较基础的，但是还是主要做给自己看，相当于笔记的东西吧，但是因为在公网上，还是认认真真写比较好）。 MarkDown的一些基本语法Linux的一些命令操作（持续更新）常用的默认网络端口号Linux布置http环境个人Blog——Hexo在GitHub上的配置","categories":[{"name":"随笔","slug":"随笔","permalink":"http://ranxb.cn/categories/随笔/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://ranxb.cn/tags/随笔/"}]},{"title":"第一篇文章","slug":"第一篇文章","date":"2017-09-03T14:42:24.000Z","updated":"2017-09-08T03:34:51.000Z","comments":true,"path":"2017/09/03/第一篇文章/","link":"","permalink":"http://ranxb.cn/2017/09/03/第一篇文章/","excerpt":"","text":"这是第一篇文章～ 我就试试看能不能成功。 我的第一篇文章","categories":[{"name":"hexo","slug":"hexo","permalink":"http://ranxb.cn/categories/hexo/"}],"tags":[{"name":"入门","slug":"入门","permalink":"http://ranxb.cn/tags/入门/"},{"name":"hexo","slug":"hexo","permalink":"http://ranxb.cn/tags/hexo/"},{"name":"新手","slug":"新手","permalink":"http://ranxb.cn/tags/新手/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-08-31T16:00:39.000Z","updated":"2017-09-08T03:32:46.000Z","comments":true,"path":"2017/09/01/hello-world/","link":"","permalink":"http://ranxb.cn/2017/09/01/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://ranxb.cn/tags/hexo/"}]}]}